(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["laravel-modeler-query"] = factory(require("vue"));
	else
		root["laravel-modeler-query"] = factory(root["Vue"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__8bbf__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fae3");
/******/ })
/************************************************************************/
/******/ ({

/***/ "00b4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");

var DELEGATES_TO_EXEC = function () {
  var execCalled = false;
  var re = /[ac]/;
  re.exec = function () {
    execCalled = true;
    return /./.exec.apply(this, arguments);
  };
  return re.test('abc') === true && execCalled;
}();

var Error = global.Error;
var un$Test = uncurryThis(/./.test);

// `RegExp.prototype.test` method
// https://tc39.es/ecma262/#sec-regexp.prototype.test
$({ target: 'RegExp', proto: true, forced: !DELEGATES_TO_EXEC }, {
  test: function (str) {
    var exec = this.exec;
    if (!isCallable(exec)) return un$Test(this, str);
    var result = call(exec, this, str);
    if (result !== null && !isObject(result)) {
      throw new Error('RegExp exec method returned something other than an Object or null');
    }
    return !!result;
  }
});


/***/ }),

/***/ "00ee":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "0366":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var aCallable = __webpack_require__("59ed");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : bind ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "057f":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__("c6b6");
var toIndexedObject = __webpack_require__("fc6a");
var $getOwnPropertyNames = __webpack_require__("241c").f;
var arraySlice = __webpack_require__("f36a");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "06cf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var call = __webpack_require__("c65b");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createPropertyDescriptor = __webpack_require__("5c6c");
var toIndexedObject = __webpack_require__("fc6a");
var toPropertyKey = __webpack_require__("a04b");
var hasOwn = __webpack_require__("1a2d");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "07fa":
/***/ (function(module, exports, __webpack_require__) {

var toLength = __webpack_require__("50c4");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "0b42":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isArray = __webpack_require__("e8b5");
var isConstructor = __webpack_require__("68ee");
var isObject = __webpack_require__("861d");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');
var Array = global.Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "0cfb":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var createElement = __webpack_require__("cc12");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "0d51":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

var String = global.String;

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "107c":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ "1148":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var toIntegerOrInfinity = __webpack_require__("5926");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");

var RangeError = global.RangeError;

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = toString(requireObjectCoercible(this));
  var result = '';
  var n = toIntegerOrInfinity(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "1276":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var isRegExp = __webpack_require__("44e7");
var anObject = __webpack_require__("825a");
var requireObjectCoercible = __webpack_require__("1d80");
var speciesConstructor = __webpack_require__("4840");
var advanceStringIndex = __webpack_require__("8aa5");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var getMethod = __webpack_require__("dc4a");
var arraySlice = __webpack_require__("f36a");
var callRegExpExec = __webpack_require__("14c3");
var regexpExec = __webpack_require__("9263");
var stickyHelpers = __webpack_require__("9f7f");
var fails = __webpack_require__("d039");

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 0xFFFFFFFF;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis(/./.exec);
var push = uncurryThis($push);
var stringSlice = uncurryThis(''.slice);

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

// @@split logic
fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = toString(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return call(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = call(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice(string, lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, '')) push(output, '');
      } else push(output, stringSlice(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
      return splitter
        ? call(splitter, separator, O, limit)
        : call(internalSplit, toString(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (string, limit) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

      if (res.done) return res.value;

      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          push(A, stringSlice(S, p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push(A, z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      push(A, stringSlice(S, p));
      return A;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);


/***/ }),

/***/ "14c3":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("c6b6");
var regexpExec = __webpack_require__("9263");

var TypeError = global.TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ "1626":
/***/ (function(module, exports) {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "1a2d":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toObject = __webpack_require__("7b0b");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "1be4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "1c7e":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "1d80":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

var TypeError = global.TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "1dde":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "23cb":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "23e7":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var setGlobal = __webpack_require__("ce4e");
var copyConstructorProperties = __webpack_require__("e893");
var isForced = __webpack_require__("94ca");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "241c":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "2532":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var toString = __webpack_require__("577e");
var correctIsRegExpLogic = __webpack_require__("ab13");

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ "26ee":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5ea3");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),

/***/ "2a62":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var getMethod = __webpack_require__("dc4a");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "2a95":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Schema; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/* eslint no-console:0 */
var formatRegExp = /%[sdj%]/g;
var warning = function warning() {}; // don't print warning message when in production env or node runtime

if (typeof process !== 'undefined' && Object({"NODE_ENV":"production","BASE_URL":"/"}) && "production" !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function (error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var i = 0;
  var len = args.length;

  if (typeof template === 'function') {
    return template.apply(null, args);
  }

  if (typeof template === 'string') {
    var str = template.replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });
    return str;
  }

  return template;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors || []);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}

var AsyncValidationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncValidationError, _Error);

  function AsyncValidationError(errors, fields) {
    var _this;

    _this = _Error.call(this, 'Async Validation Error') || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }

  return AsyncValidationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };

      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });

    _pending["catch"](function (e) {
      return e;
    });

    return _pending;
  }

  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function (resolve, reject) {
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };

    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }

    objArrKeys.forEach(function (key) {
      var arr = objArr[key];

      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function (e) {
    return e;
  });
  return pending;
}

function isErrorObj(obj) {
  return !!(obj && obj.message !== undefined);
}

function getValue(value, path) {
  var v = value;

  for (var i = 0; i < path.length; i++) {
    if (v == undefined) {
      return v;
    }

    v = v[path[i]];
  }

  return v;
}

function complementError(rule, source) {
  return function (oe) {
    var fieldValue;

    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }

    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }

    return {
      message: typeof oe === 'function' ? oe() : oe,
      fieldValue: fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if (typeof value === 'object' && typeof target[s] === 'object') {
          target[s] = _extends({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}

var required$1 = function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};

/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

var whitespace = function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};

/* eslint max-len:0 */

var pattern$2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return typeof value === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === 'string' && value.length <= 2048 && !!value.match(pattern$2.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern$2.hex);
  }
};

var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    required$1(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};

var range = function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};

var ENUM$1 = 'enum';

var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];

  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
  }
};

var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};

var rules = {
  required: required$1,
  whitespace: whitespace,
  type: type$1,
  range: range,
  "enum": enumerable$1,
  pattern: pattern$1
};

var string = function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
};

var method = function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var number = function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (value === '') {
      value = undefined;
    }

    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var _boolean = function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var regexp = function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var integer = function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var floatFn = function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var array = function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if ((value === undefined || value === null) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'array');

    if (value !== undefined && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var object = function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var ENUM = 'enum';

var enumerable = function enumerable(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var pattern = function pattern(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      rules.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var date = function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value, 'date') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'date')) {
      var dateObject;

      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }

      rules.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
};

var required = function required(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value;
  rules.required(rule, value, source, errors, options, type);
  callback(errors);
};

var type = function type(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var any = function any(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);
  }

  callback(errors);
};

var validators = {
  string: string,
  method: method,
  number: number,
  "boolean": _boolean,
  regexp: regexp,
  integer: integer,
  "float": floatFn,
  array: array,
  object: object,
  "enum": enumerable,
  pattern: pattern,
  date: date,
  url: type,
  hex: type,
  email: type,
  required: required,
  any: any
};

function newMessages() {
  return {
    "default": 'Validation error on field %s',
    required: '%s is required',
    "enum": '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();

/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

var Schema = /*#__PURE__*/function () {
  // ========================= Static =========================
  // ======================== Instance ========================
  function Schema(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }

  var _proto = Schema.prototype;

  _proto.define = function define(rules) {
    var _this = this;

    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if (typeof rules !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    Object.keys(rules).forEach(function (name) {
      var item = rules[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };

  _proto.messages = function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  };

  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;

    if (o === void 0) {
      o = {};
    }

    if (oc === void 0) {
      oc = function oc() {};
    }

    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }

      return Promise.resolve(source);
    }

    function complete(results) {
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          var _errors;

          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }

      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }

    if (options.messages) {
      var messages$1 = this.messages();

      if (messages$1 === messages) {
        messages$1 = newMessages();
      }

      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }

    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = _extends({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        } // Fill validator. Skip if nothing need to validate


        rule.validator = _this2.getValidationMethod(rule);

        if (!rule.validator) {
          return;
        }

        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }

      function cb(e) {
        if (e === void 0) {
          e = [];
        }

        var errorList = Array.isArray(e) ? e : [e];

        if (!options.suppressWarning && errorList.length) {
          Schema.warning('async-validator:', errorList);
        }

        if (errorList.length && rule.message !== undefined) {
          errorList = [].concat(rule.message);
        } // Fill error info


        var filledErrors = errorList.map(complementError(rule, source));

        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }

        if (!deep) {
          doIt(filledErrors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message !== undefined) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }

            return doIt(filledErrors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            Object.keys(data.value).map(function (key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }

          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function (field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema(paredFieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            var finalErrors = [];

            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }

            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }

            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }

      var res;

      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options);

        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    }, source);
  };

  _proto.getType = function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  };

  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return validators.required;
    }

    return validators[this.getType(rule)] || undefined;
  };

  return Schema;
}();

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  validators[type] = validator;
};

Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;


//# sourceMappingURL=index.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "2ba4":
/***/ (function(module, exports) {

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (bind ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "2d00":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var userAgent = __webpack_require__("342f");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "2f74":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (stubFalse);


/***/ }),

/***/ "342f":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "35a1":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");
var getMethod = __webpack_require__("dc4a");
var Iterators = __webpack_require__("3f8c");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "35b3":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");

// `Number.EPSILON` constant
// https://tc39.es/ecma262/#sec-number.epsilon
$({ target: 'Number', stat: true }, {
  EPSILON: Math.pow(2, -52)
});


/***/ }),

/***/ "37e8":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var anObject = __webpack_require__("825a");
var toIndexedObject = __webpack_require__("fc6a");
var objectKeys = __webpack_require__("df75");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "3a9b":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "3bbe":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");

var String = global.String;
var TypeError = global.TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw TypeError("Can't set " + String(argument) + ' as a prototype');
};


/***/ }),

/***/ "3ca3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;
var toString = __webpack_require__("577e");
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "3f8c":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "408a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ "428f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global;


/***/ }),

/***/ "4362":
/***/ (function(module, exports, __webpack_require__) {

exports.nextTick = function nextTick(fn) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    setTimeout(function () {
        fn.apply(null, args);
    }, 0);
};

exports.platform = exports.arch = 
exports.execPath = exports.title = 'browser';
exports.pid = 1;
exports.browser = true;
exports.env = {};
exports.argv = [];

exports.binding = function (name) {
	throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    exports.cwd = function () { return cwd };
    exports.chdir = function (dir) {
        if (!path) path = __webpack_require__("df7c");
        cwd = path.resolve(dir, cwd);
    };
})();

exports.exit = exports.kill = 
exports.umask = exports.dlopen = 
exports.uptime = exports.memoryUsage = 
exports.uvCounters = function() {};
exports.features = {};


/***/ }),

/***/ "44ad":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");

var Object = global.Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "44d2":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var create = __webpack_require__("7c73");
var definePropertyModule = __webpack_require__("9bf2");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "44e7":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "4840":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aConstructor = __webpack_require__("5087");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ "485a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");

var TypeError = global.TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "4930":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__("2d00");
var fails = __webpack_require__("d039");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "4d64":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "4de4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $filter = __webpack_require__("b727").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "4df4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var bind = __webpack_require__("0366");
var call = __webpack_require__("c65b");
var toObject = __webpack_require__("7b0b");
var callWithSafeIterationClosing = __webpack_require__("9bdd");
var isArrayIteratorMethod = __webpack_require__("e95a");
var isConstructor = __webpack_require__("68ee");
var lengthOfArrayLike = __webpack_require__("07fa");
var createProperty = __webpack_require__("8418");
var getIterator = __webpack_require__("9a1f");
var getIteratorMethod = __webpack_require__("35a1");

var Array = global.Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "5087":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isConstructor = __webpack_require__("68ee");
var tryToString = __webpack_require__("0d51");

var TypeError = global.TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "50c4":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "5692":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("c430");
var store = __webpack_require__("c6cd");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.19.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "56ef":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var uncurryThis = __webpack_require__("e330");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var anObject = __webpack_require__("825a");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "577e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var classof = __webpack_require__("f5df");

var String = global.String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ "5899":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "58a8":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var requireObjectCoercible = __webpack_require__("1d80");
var toString = __webpack_require__("577e");
var whitespaces = __webpack_require__("5899");

var replace = uncurryThis(''.replace);
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "58e0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("26ee");
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("2f74");



/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];

/* harmony default export */ __webpack_exports__["a"] = (isBuffer);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("dd40")(module)))

/***/ }),

/***/ "5926":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- safe
  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
};


/***/ }),

/***/ "59ed":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var tryToString = __webpack_require__("0d51");

var TypeError = global.TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "5a34":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isRegExp = __webpack_require__("44e7");

var TypeError = global.TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "5c6c":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "5e77":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var hasOwn = __webpack_require__("1a2d");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "5ea3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "6547":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toIntegerOrInfinity = __webpack_require__("5926");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "65f0":
/***/ (function(module, exports, __webpack_require__) {

var arraySpeciesConstructor = __webpack_require__("0b42");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "68ee":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("f5df");
var getBuiltIn = __webpack_require__("d066");
var inspectSource = __webpack_require__("8925");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function (argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function (argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
    // we can't check .prototype since constructors produced by .bind haven't it
  } return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
};

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "69f3":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");
var hasOwn = __webpack_require__("1a2d");
var shared = __webpack_require__("c6cd");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "6dd8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["a"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "6eeb":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var hasOwn = __webpack_require__("1a2d");
var createNonEnumerableProperty = __webpack_require__("9112");
var setGlobal = __webpack_require__("ce4e");
var inspectSource = __webpack_require__("8925");
var InternalStateModule = __webpack_require__("69f3");
var CONFIGURABLE_FUNCTION_NAME = __webpack_require__("5e77").CONFIGURABLE;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "7156":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var setPrototypeOf = __webpack_require__("d2bb");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "7418":
/***/ (function(module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "746f":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var hasOwn = __webpack_require__("1a2d");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineProperty = __webpack_require__("9bf2").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "7839":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "785a":
/***/ (function(module, exports, __webpack_require__) {

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__("cc12");

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ "7b0b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var requireObjectCoercible = __webpack_require__("1d80");

var Object = global.Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "7c73":
/***/ (function(module, exports, __webpack_require__) {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__("825a");
var defineProperties = __webpack_require__("37e8");
var enumBugKeys = __webpack_require__("7839");
var hiddenKeys = __webpack_require__("d012");
var html = __webpack_require__("1be4");
var documentCreateElement = __webpack_require__("cc12");
var sharedKey = __webpack_require__("f772");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "7db0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $find = __webpack_require__("b727").find;
var addToUnscopables = __webpack_require__("44d2");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "7dd0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var call = __webpack_require__("c65b");
var IS_PURE = __webpack_require__("c430");
var FunctionName = __webpack_require__("5e77");
var isCallable = __webpack_require__("1626");
var createIteratorConstructor = __webpack_require__("9ed3");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");
var IteratorsCore = __webpack_require__("ae93");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "7f9a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var inspectSource = __webpack_require__("8925");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "825a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var String = global.String;
var TypeError = global.TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ "83ab":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "8418":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPropertyKey = __webpack_require__("a04b");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "861d":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8925":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var isCallable = __webpack_require__("1626");
var store = __webpack_require__("c6cd");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "8aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;

/***/ }),

/***/ "90e3":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "9112":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "9263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var toString = __webpack_require__("577e");
var regexpFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");
var shared = __webpack_require__("5692");
var create = __webpack_require__("7c73");
var getInternalState = __webpack_require__("69f3").get;
var UNSUPPORTED_DOT_ALL = __webpack_require__("fce3");
var UNSUPPORTED_NCG = __webpack_require__("107c");

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  // eslint-disable-next-line max-statements -- TODO
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "94ca":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "99af":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var createProperty = __webpack_require__("8418");
var arraySpeciesCreate = __webpack_require__("65f0");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
var TypeError = global.TypeError;

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "9a1f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var aCallable = __webpack_require__("59ed");
var anObject = __webpack_require__("825a");
var tryToString = __webpack_require__("0d51");
var getIteratorMethod = __webpack_require__("35a1");

var TypeError = global.TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "9bdd":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var iteratorClose = __webpack_require__("2a62");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ "9bf2":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DESCRIPTORS = __webpack_require__("83ab");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");
var anObject = __webpack_require__("825a");
var toPropertyKey = __webpack_require__("a04b");

var TypeError = global.TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9ed3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
var create = __webpack_require__("7c73");
var createPropertyDescriptor = __webpack_require__("5c6c");
var setToStringTag = __webpack_require__("d44e");
var Iterators = __webpack_require__("3f8c");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "9f7f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;

exports.UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ "a04b":
/***/ (function(module, exports, __webpack_require__) {

var toPrimitive = __webpack_require__("c04e");
var isSymbol = __webpack_require__("d9b5");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "a4d3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_SYMBOL = __webpack_require__("4930");
var fails = __webpack_require__("d039");
var hasOwn = __webpack_require__("1a2d");
var isArray = __webpack_require__("e8b5");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var isPrototypeOf = __webpack_require__("3a9b");
var isSymbol = __webpack_require__("d9b5");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toIndexedObject = __webpack_require__("fc6a");
var toPropertyKey = __webpack_require__("a04b");
var $toString = __webpack_require__("577e");
var createPropertyDescriptor = __webpack_require__("5c6c");
var nativeObjectCreate = __webpack_require__("7c73");
var objectKeys = __webpack_require__("df75");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertyNamesExternal = __webpack_require__("057f");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var arraySlice = __webpack_require__("f36a");
var redefine = __webpack_require__("6eeb");
var shared = __webpack_require__("5692");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");
var uid = __webpack_require__("90e3");
var wellKnownSymbol = __webpack_require__("b622");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineWellKnownSymbol = __webpack_require__("746f");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");
var $forEach = __webpack_require__("b727").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  redefine(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = $toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (isCallable($replacer)) value = call($replacer, this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return apply($stringify, null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if (!SymbolPrototype[TO_PRIMITIVE]) {
  var valueOf = SymbolPrototype.valueOf;
  // eslint-disable-next-line no-unused-vars -- required for .length
  redefine(SymbolPrototype, TO_PRIMITIVE, function (hint) {
    // TODO: improve hint logic
    return call(valueOf, this);
  });
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "a630":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var from = __webpack_require__("4df4");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "a9e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var hasOwn = __webpack_require__("1a2d");
var inheritIfRequired = __webpack_require__("7156");
var isPrototypeOf = __webpack_require__("3a9b");
var isSymbol = __webpack_require__("d9b5");
var toPrimitive = __webpack_require__("c04e");
var fails = __webpack_require__("d039");
var getOwnPropertyNames = __webpack_require__("241c").f;
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var defineProperty = __webpack_require__("9bf2").f;
var thisNumberValue = __webpack_require__("408a");
var trim = __webpack_require__("58a8").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var arraySlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = arraySlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
    var dummy = this;
    // check on 1..constructor(foo) case
    return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); })
      ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "ab13":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "ac1f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var exec = __webpack_require__("9263");

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "ad6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "ae93":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var create = __webpack_require__("7c73");
var getPrototypeOf = __webpack_require__("e163");
var redefine = __webpack_require__("6eeb");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  redefine(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "b041":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classof = __webpack_require__("f5df");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "b0c0":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var FUNCTION_NAME_EXISTS = __webpack_require__("5e77").EXISTS;
var uncurryThis = __webpack_require__("e330");
var defineProperty = __webpack_require__("9bf2").f;

var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis(FunctionPrototype.toString);
var nameRE = /^\s*function ([^ (]*)/;
var regExpExec = uncurryThis(nameRE.exec);
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "b622":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var shared = __webpack_require__("5692");
var hasOwn = __webpack_require__("1a2d");
var uid = __webpack_require__("90e3");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "b680":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var toIntegerOrInfinity = __webpack_require__("5926");
var thisNumberValue = __webpack_require__("408a");
var $repeat = __webpack_require__("1148");
var fails = __webpack_require__("d039");

var RangeError = global.RangeError;
var String = global.String;
var floor = Math.floor;
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var un$ToFixed = uncurryThis(1.0.toFixed);

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var multiply = function (data, n, c) {
  var index = -1;
  var c2 = c;
  while (++index < 6) {
    c2 += n * data[index];
    data[index] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (data, n) {
  var index = 6;
  var c = 0;
  while (--index >= 0) {
    c += data[index];
    data[index] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var dataToString = function (data) {
  var index = 6;
  var s = '';
  while (--index >= 0) {
    if (s !== '' || index === 0 || data[index] !== 0) {
      var t = String(data[index]);
      s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
    }
  } return s;
};

var FORCED = fails(function () {
  return un$ToFixed(0.00008, 3) !== '0.000' ||
    un$ToFixed(0.9, 0) !== '1' ||
    un$ToFixed(1.255, 2) !== '1.25' ||
    un$ToFixed(1000000000000000128.0, 0) !== '1000000000000000128';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  un$ToFixed({});
});

// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toIntegerOrInfinity(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(data, 0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(data, 1e7, 0);
          j -= 7;
        }
        multiply(data, pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(data, 1 << 23);
          j -= 23;
        }
        divide(data, 1 << j);
        multiply(data, 1, 1);
        divide(data, 2);
        result = dataToString(data);
      } else {
        multiply(data, 0, z);
        multiply(data, 1 << -e, 0);
        result = dataToString(data) + repeat('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat('0', fractDigits - k) + result
        : stringSlice(result, 0, k - fractDigits) + '.' + stringSlice(result, k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ "b727":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var uncurryThis = __webpack_require__("e330");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var arraySpeciesCreate = __webpack_require__("65f0");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "c04e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var isObject = __webpack_require__("861d");
var isSymbol = __webpack_require__("d9b5");
var getMethod = __webpack_require__("dc4a");
var ordinaryToPrimitive = __webpack_require__("485a");
var wellKnownSymbol = __webpack_require__("b622");

var TypeError = global.TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "c430":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "c65b":
/***/ (function(module, exports) {

var call = Function.prototype.call;

module.exports = call.bind ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "c6b6":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "c6cd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setGlobal = __webpack_require__("ce4e");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c6eb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5ea3");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ __webpack_exports__["a"] = (nodeUtil);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("dd40")(module)))

/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "ca84":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var hasOwn = __webpack_require__("1a2d");
var toIndexedObject = __webpack_require__("fc6a");
var indexOf = __webpack_require__("4d64").indexOf;
var hiddenKeys = __webpack_require__("d012");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "caad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $includes = __webpack_require__("4d64").includes;
var addToUnscopables = __webpack_require__("44d2");

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "cc12":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "ce4e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "d012":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "d039":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "d066":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "d1e7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "d28b":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("746f");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "d2bb":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__("e330");
var anObject = __webpack_require__("825a");
var aPossiblePrototype = __webpack_require__("3bbe");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "d3b7":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var redefine = __webpack_require__("6eeb");
var toString = __webpack_require__("b041");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "d44e":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;
var hasOwn = __webpack_require__("1a2d");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !hasOwn(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "d784":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var uncurryThis = __webpack_require__("e330");
var redefine = __webpack_require__("6eeb");
var regexpExec = __webpack_require__("9263");
var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var createNonEnumerableProperty = __webpack_require__("9112");

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });

    redefine(String.prototype, KEY, methods[0]);
    redefine(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "d81d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $map = __webpack_require__("b727").map;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "d9b5":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var isCallable = __webpack_require__("1626");
var isPrototypeOf = __webpack_require__("3a9b");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var Object = global.Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
};


/***/ }),

/***/ "da84":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "dc4a":
/***/ (function(module, exports, __webpack_require__) {

var aCallable = __webpack_require__("59ed");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ "dd40":
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "ddb0":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var DOMTokenListPrototype = __webpack_require__("785a");
var ArrayIteratorMethods = __webpack_require__("e260");
var createNonEnumerableProperty = __webpack_require__("9112");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ "df75":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "df7c":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "dff1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("26ee");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneBuffer);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("dd40")(module)))

/***/ }),

/***/ "e01a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var hasOwn = __webpack_require__("1a2d");
var isCallable = __webpack_require__("1626");
var isPrototypeOf = __webpack_require__("3a9b");
var toString = __webpack_require__("577e");
var defineProperty = __webpack_require__("9bf2").f;
var copyConstructorProperties = __webpack_require__("e893");

var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
  var symbolToString = uncurryThis(SymbolPrototype.toString);
  var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineProperty(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = symbolValueOf(this);
      var string = symbolToString(symbol);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "e163":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var hasOwn = __webpack_require__("1a2d");
var isCallable = __webpack_require__("1626");
var toObject = __webpack_require__("7b0b");
var sharedKey = __webpack_require__("f772");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var IE_PROTO = sharedKey('IE_PROTO');
var Object = global.Object;
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "e177":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "e260":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("fc6a");
var addToUnscopables = __webpack_require__("44d2");
var Iterators = __webpack_require__("3f8c");
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "e330":
/***/ (function(module, exports) {

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var callBind = bind && bind.bind(call);

module.exports = bind ? function (fn) {
  return fn && callBind(call, fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "e538":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "e893":
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__("1a2d");
var ownKeys = __webpack_require__("56ef");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "e8b5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "e95a":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "e9c4":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var apply = __webpack_require__("2ba4");
var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");

var Array = global.Array;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var fix = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

var FORCED = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  // https://github.com/tc39/proposal-well-formed-stringify
  $({ target: 'JSON', stat: true, forced: FORCED }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      for (var i = 0, l = arguments.length, args = Array(l); i < l; i++) args[i] = arguments[i];
      var result = apply($stringify, null, args);
      return typeof result == 'string' ? replace(result, tester, fix) : result;
    }
  });
}


/***/ }),

/***/ "f36a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "f5df":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var isCallable = __webpack_require__("1626");
var classofRaw = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Object = global.Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "f772":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5692");
var uid = __webpack_require__("90e3");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "fae3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Schema", function() { return /* reexport */ Schema; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js






function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__("a630");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js
var es_regexp_test = __webpack_require__("00b4");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js








function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js







function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.epsilon.js
var es_number_epsilon = __webpack_require__("35b3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.to-fixed.js
var es_number_to_fixed = __webpack_require__("b680");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.json.stringify.js
var es_json_stringify = __webpack_require__("e9c4");

// CONCATENATED MODULE: ./node_modules/@jsplumb/util/js/jsplumb.util.es.js
function filterList(list, value, missingIsFalse) {
  if (list === "*") {
    return true;
  }
  return list.length > 0 ? list.indexOf(value) !== -1 : !missingIsFalse;
}
function extend(o1, o2, keys) {
  var i;
  o1 = o1 || {};
  o2 = o2 || {};
  var _o1 = o1,
      _o2 = o2;
  if (keys) {
    for (i = 0; i < keys.length; i++) {
      _o1[keys[i]] = _o2[keys[i]];
    }
  } else {
    for (i in _o2) {
      _o1[i] = _o2[i];
    }
  }
  return o1;
}
function isNumber(n) {
  return Object.prototype.toString.call(n) === "[object Number]";
}
function isString(s) {
  return typeof s === "string";
}
function isBoolean(s) {
  return typeof s === "boolean";
}
function isObject(o) {
  return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function isFunction(o) {
  return Object.prototype.toString.call(o) === "[object Function]";
}
function isNamedFunction(o) {
  return isFunction(o) && o.name != null && o.name.length > 0;
}
function isEmpty(o) {
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      return false;
    }
  }
  return true;
}
function clone(a) {
  if (isString(a)) {
    return "" + a;
  } else if (isBoolean(a)) {
    return !!a;
  } else if (isDate(a)) {
    return new Date(a.getTime());
  } else if (isFunction(a)) {
    return a;
  } else if (Array.isArray(a)) {
    var _b = [];
    for (var i = 0; i < a.length; i++) {
      _b.push(clone(a[i]));
    }
    return _b;
  } else if (isObject(a)) {
    var c = {};
    for (var j in a) {
      c[j] = clone(a[j]);
    }
    return c;
  } else {
    return a;
  }
}
function filterNull(obj) {
  var o = {};
  for (var k in obj) {
    if (obj[k] != null) {
      o[k] = obj[k];
    }
  }
  return o;
}
function merge(a, b, collations, overwrites) {
  var cMap = {},
      ar,
      i,
      oMap = {};
  collations = collations || [];
  overwrites = overwrites || [];
  for (i = 0; i < collations.length; i++) {
    cMap[collations[i]] = true;
  }
  for (i = 0; i < overwrites.length; i++) {
    oMap[overwrites[i]] = true;
  }
  var c = clone(a);
  for (i in b) {
    if (c[i] == null || oMap[i]) {
      c[i] = b[i];
    } else if (cMap[i]) {
      ar = [];
      ar.push.apply(ar, Array.isArray(c[i]) ? c[i] : [c[i]]);
      ar.push(b[i]);
      c[i] = ar;
    } else if (isString(b[i]) || isBoolean(b[i]) || isFunction(b[i]) || isNumber(b[i])) {
      c[i] = b[i];
    } else {
      if (Array.isArray(b[i])) {
        ar = [];
        if (Array.isArray(c[i])) {
          ar.push.apply(ar, c[i]);
        }
        ar.push.apply(ar, b[i]);
        c[i] = ar;
      } else if (isObject(b[i])) {
        if (!isObject(c[i])) {
          c[i] = {};
        }
        for (var j in b[i]) {
          c[i][j] = b[i][j];
        }
      }
    }
  }
  return c;
}
function _areEqual(a, b) {
  if (a != null && b == null) {
    return false;
  } else {
    if ((a == null || isString(a) || isBoolean(a) || isNumber(a)) && a !== b) {
      return false;
    } else {
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false;
        } else {
          if (!arraysEqual(a, b)) {
            return false;
          }
        }
      } else if (isObject(a)) {
        if (!isObject(a)) {
          return false;
        } else {
          if (!objectsEqual(a, b)) {
            return false;
          }
        }
      }
    }
  }
  return true;
}
function arraysEqual(a, b) {
  if (a == null && b == null) {
    return true;
  } else if (a == null && b != null) {
    return false;
  } else if (a != null && b == null) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  } else {
    for (var i = 0; i < a.length; i++) {
      if (!_areEqual(a[i], b[i])) {
        return false;
      }
    }
  }
  return true;
}
function objectsEqual(a, b) {
  if (a == null && b == null) {
    return true;
  } else if (a == null && b != null) {
    return false;
  } else if (a != null && b == null) {
    return false;
  }
  for (var key in a) {
    var va = a[key],
        vb = b[key];
    if (!_areEqual(va, vb)) {
      return false;
    }
  }
  return true;
}
function replace(inObj, path, value) {
  if (inObj == null) {
    return;
  }
  var q = inObj,
      t = q;
  path.replace(/([^\.])+/g, function (term, lc, pos, str) {
    var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
        last = pos + term.length >= str.length,
        _getArray = function _getArray() {
      return t[array[1]] || function () {
        t[array[1]] = [];
        return t[array[1]];
      }();
    };
    if (last) {
      if (array) {
        _getArray()[array[3]] = value;
      } else {
        t[term] = value;
      }
    } else {
      if (array) {
        var _a2 = _getArray();
        t = _a2[array[3]] || function () {
          _a2[array[3]] = {};
          return _a2[array[3]];
        }();
      } else {
        t = t[term] || function () {
          t[term] = {};
          return t[term];
        }();
      }
    }
    return "";
  });
  return inObj;
}
function functionChain(successValue, failValue, fns) {
  for (var i = 0; i < fns.length; i++) {
    var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
    if (o === failValue) {
      return o;
    }
  }
  return successValue;
}
function populate(model, values, functionPrefix, doNotExpandFunctions) {
  var getValue = function getValue(fromString) {
    var matches = fromString.match(/(\${.*?})/g);
    if (matches != null) {
      for (var i = 0; i < matches.length; i++) {
        var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
        if (val != null) {
          fromString = fromString.replace(matches[i], val);
        }
      }
    }
    return fromString;
  };
  var _one = function _one(d) {
    if (d != null) {
      if (isString(d)) {
        return getValue(d);
      } else if (isFunction(d) && !doNotExpandFunctions && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
        return d(values);
      } else if (Array.isArray(d)) {
        var r = [];
        for (var i = 0; i < d.length; i++) {
          r.push(_one(d[i]));
        }
        return r;
      } else if (isObject(d)) {
        var s = {};
        for (var j in d) {
          s[j] = _one(d[j]);
        }
        return s;
      } else {
        return d;
      }
    }
  };
  return _one(model);
}
function forEach(a, f) {
  if (a) {
    for (var i = 0; i < a.length; i++) {
      f(a[i]);
    }
  } else {
    return null;
  }
}
function findWithFunction(a, f) {
  if (a) {
    for (var i = 0; i < a.length; i++) {
      if (f(a[i])) {
        return i;
      }
    }
  }
  return -1;
}
function findAllWithFunction(a, predicate) {
  var o = [];
  if (a) {
    for (var i = 0; i < a.length; i++) {
      if (predicate(a[i])) {
        o.push(i);
      }
    }
  }
  return o;
}
function getWithFunction(a, f) {
  var idx = findWithFunction(a, f);
  return idx === -1 ? null : a[idx];
}
function getAllWithFunction(a, f) {
  var indexes = findAllWithFunction(a, f);
  return indexes.map(function (i) {
    return a[i];
  });
}
function getFromSetWithFunction(s, f) {
  var out = null;
  s.forEach(function (t) {
    if (f(t)) {
      out = t;
    }
  });
  return out;
}
function setToArray(s) {
  var a = [];
  s.forEach(function (t) {
    a.push(t);
  });
  return a;
}
function removeWithFunction(a, f) {
  var idx = findWithFunction(a, f);
  if (idx > -1) {
    a.splice(idx, 1);
  }
  return idx !== -1;
}
function fromArray(a) {
  if (Array.fromArray != null) {
    return Array.from(a);
  } else {
    var arr = [];
    Array.prototype.push.apply(arr, a);
    return arr;
  }
}
function jsplumb_util_es_remove(l, v) {
  var idx = l.indexOf(v);
  if (idx > -1) {
    l.splice(idx, 1);
  }
  return idx !== -1;
}
function addWithFunction(list, item, hashFunction) {
  if (findWithFunction(list, hashFunction) === -1) {
    list.push(item);
  }
}
function addToDictionary(map, key, value, insertAtStart) {
  var l = map[key];
  if (l == null) {
    l = [];
    map[key] = l;
  }
  l[insertAtStart ? "unshift" : "push"](value);
  return l;
}
function addToList(map, key, value, insertAtStart) {
  var l = map.get(key);
  if (l == null) {
    l = [];
    map.set(key, l);
  }
  l[insertAtStart ? "unshift" : "push"](value);
  return l;
}
function suggest(list, item, insertAtHead) {
  if (list.indexOf(item) === -1) {
    if (insertAtHead) {
      list.unshift(item);
    } else {
      list.push(item);
    }
    return true;
  }
  return false;
}
var lut = [];
for (var jsplumb_util_es_i = 0; jsplumb_util_es_i < 256; jsplumb_util_es_i++) {
  lut[jsplumb_util_es_i] = (jsplumb_util_es_i < 16 ? '0' : '') + jsplumb_util_es_i.toString(16);
}
function jsplumb_util_es_uuid() {
  var d0 = Math.random() * 0xffffffff | 0;
  var d1 = Math.random() * 0xffffffff | 0;
  var d2 = Math.random() * 0xffffffff | 0;
  var d3 = Math.random() * 0xffffffff | 0;
  return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
}
function rotatePoint(point, center, rotation) {
  var radial = {
    x: point.x - center.x,
    y: point.y - center.y
  },
      cr = Math.cos(rotation / 360 * Math.PI * 2),
      sr = Math.sin(rotation / 360 * Math.PI * 2);
  return {
    x: radial.x * cr - radial.y * sr + center.x,
    y: radial.y * cr + radial.x * sr + center.y,
    cr: cr,
    sr: sr
  };
}
function rotateAnchorOrientation(orientation, rotation) {
  var r = rotatePoint({
    x: orientation[0],
    y: orientation[1]
  }, {
    x: 0,
    y: 0
  }, rotation);
  return [Math.round(r.x), Math.round(r.y)];
}
function fastTrim(s) {
  if (s == null) {
    return null;
  }
  var str = s.replace(/^\s\s*/, ''),
      ws = /\s/,
      i = str.length;
  while (ws.test(str.charAt(--i))) {}
  return str.slice(0, i + 1);
}
function jsplumb_util_es_each(obj, fn) {
  obj = obj.length == null || typeof obj === "string" ? [obj] : obj;
  for (var _i = 0; _i < obj.length; _i++) {
    fn(obj[_i]);
  }
}
function jsplumb_util_es_map(obj, fn) {
  var o = [];
  for (var _i2 = 0; _i2 < obj.length; _i2++) {
    o.push(fn(obj[_i2]));
  }
  return o;
}
var logEnabled = true;
function log() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof console !== "undefined") {
    try {
      var msg = arguments[arguments.length - 1];
      console.log(msg);
    } catch (e) {}
  }
}
function jsplumb_util_es_wrap(wrappedFunction, newFunction, returnOnThisValue) {
  return function () {
    var r = null;
    try {
      if (newFunction != null) {
        r = newFunction.apply(this, arguments);
      }
    } catch (e) {
      log("jsPlumb function failed : " + e);
    }
    if (wrappedFunction != null && (returnOnThisValue == null || r !== returnOnThisValue)) {
      try {
        r = wrappedFunction.apply(this, arguments);
      } catch (e) {
        log("wrapped function failed : " + e);
      }
    }
    return r;
  };
}
function getsert(map, key, valueGenerator) {
  if (!map.has(key)) {
    map.set(key, valueGenerator());
  }
  return map.get(key);
}
function isAssignableFrom(object, cls) {
  var proto = object.__proto__;
  while (proto != null) {
    if (proto instanceof cls) {
      return true;
    } else {
      proto = proto.__proto__;
    }
  }
  return false;
}
function insertSorted(value, array, comparator, sortDescending) {
  if (array.length === 0) {
    array.push(value);
  } else {
    var flip = sortDescending ? -1 : 1;
    var min = 0;
    var max = array.length;
    var index = Math.floor((min + max) / 2);
    while (max > min) {
      var c = comparator(value, array[index]) * flip;
      if (c < 0) {
        max = index;
      } else {
        min = index + 1;
      }
      index = Math.floor((min + max) / 2);
    }
    array.splice(index, 0, value);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var EventGenerator = function () {
  function EventGenerator() {
    _classCallCheck(this, EventGenerator);
    _defineProperty(this, "_listeners", {});
    _defineProperty(this, "eventsSuspended", false);
    _defineProperty(this, "tick", false);
    _defineProperty(this, "eventsToDieOn", {
      "ready": true
    });
    _defineProperty(this, "queue", []);
  }
  _createClass(EventGenerator, [{
    key: "fire",
    value: function fire(event, value, originalEvent) {
      var ret = null;
      if (!this.tick) {
        this.tick = true;
        if (!this.eventsSuspended && this._listeners[event]) {
          var l = this._listeners[event].length,
              i = 0,
              _gone = false;
          if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
            while (!_gone && i < l && ret !== false) {
              if (this.eventsToDieOn[event]) {
                this._listeners[event][i].apply(this, [value, originalEvent]);
              } else {
                try {
                  ret = this._listeners[event][i].apply(this, [value, originalEvent]);
                } catch (e) {
                  log("jsPlumb: fire failed for event " + event + " : " + (e.message || e));
                }
              }
              i++;
              if (this._listeners == null || this._listeners[event] == null) {
                _gone = true;
              }
            }
          }
        }
        this.tick = false;
        this._drain();
      } else {
        this.queue.unshift(arguments);
      }
      return ret;
    }
  }, {
    key: "_drain",
    value: function _drain() {
      var n = this.queue.pop();
      if (n) {
        this.fire.apply(this, n);
      }
    }
  }, {
    key: "unbind",
    value: function unbind(eventOrListener, listener) {
      if (arguments.length === 0) {
        this._listeners = {};
      } else if (arguments.length === 1) {
        if (typeof eventOrListener === "string") {
          delete this._listeners[eventOrListener];
        } else if (eventOrListener.__jsPlumb) {
          var evt;
          for (var i in eventOrListener.__jsPlumb) {
            evt = eventOrListener.__jsPlumb[i];
            jsplumb_util_es_remove(this._listeners[evt] || [], eventOrListener);
          }
        }
      } else if (arguments.length === 2) {
        jsplumb_util_es_remove(this._listeners[eventOrListener] || [], listener);
      }
      return this;
    }
  }, {
    key: "getListener",
    value: function getListener(forEvent) {
      return this._listeners[forEvent] || [];
    }
  }, {
    key: "isSuspendEvents",
    value: function isSuspendEvents() {
      return this.eventsSuspended;
    }
  }, {
    key: "setSuspendEvents",
    value: function setSuspendEvents(val) {
      this.eventsSuspended = val;
    }
  }, {
    key: "bind",
    value: function bind(event, listener, insertAtStart) {
      var _this = this;
      var _one = function _one(evt) {
        addToDictionary(_this._listeners, evt, listener, insertAtStart);
        listener.__jsPlumb = listener.__jsPlumb || {};
        listener.__jsPlumb[jsplumb_util_es_uuid()] = evt;
      };
      if (typeof event === "string") {
        _one(event);
      } else if (event.length != null) {
        for (var i = 0; i < event.length; i++) {
          _one(event[i]);
        }
      }
      return this;
    }
  }, {
    key: "silently",
    value: function silently(fn) {
      this.setSuspendEvents(true);
      try {
        fn();
      } catch (e) {
        log("Cannot execute silent function " + e);
      }
      this.setSuspendEvents(false);
    }
  }]);
  return EventGenerator;
}();
var OptimisticEventGenerator = function (_EventGenerator) {
  _inherits(OptimisticEventGenerator, _EventGenerator);
  var _super = _createSuper(OptimisticEventGenerator);
  function OptimisticEventGenerator() {
    _classCallCheck(this, OptimisticEventGenerator);
    return _super.apply(this, arguments);
  }
  _createClass(OptimisticEventGenerator, [{
    key: "shouldFireEvent",
    value: function shouldFireEvent(event, value, originalEvent) {
      return true;
    }
  }]);
  return OptimisticEventGenerator;
}(EventGenerator);

var segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1]];
var inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];
var TWO_PI = 2 * Math.PI;
function jsplumb_util_es_add(p1, p2) {
  return {
    x: p1.x + p2.x,
    y: p1.y + p2.y
  };
}
function subtract(p1, p2) {
  return {
    x: p1.x - p2.x,
    y: p1.y - p2.y
  };
}
function gradient(p1, p2) {
  if (p2.x === p1.x) return p2.y > p1.y ? Infinity : -Infinity;else if (p2.y === p1.y) return p2.x > p1.x ? 0 : -0;else return (p2.y - p1.y) / (p2.x - p1.x);
}
function normal(p1, p2) {
  return -1 / gradient(p1, p2);
}
function lineLength(p1, p2) {
  return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
}
function quadrant(p1, p2) {
  if (p2.x > p1.x) {
    return p2.y > p1.y ? 2 : 1;
  } else if (p2.x == p1.x) {
    return p2.y > p1.y ? 2 : 1;
  } else {
    return p2.y > p1.y ? 3 : 4;
  }
}
function jsplumb_util_es_theta(p1, p2) {
  var m = gradient(p1, p2),
      t = Math.atan(m),
      s = quadrant(p1, p2);
  if (s == 4 || s == 3) t += Math.PI;
  if (t < 0) t += 2 * Math.PI;
  return t;
}
function intersects(r1, r2) {
  var x1 = r1.x,
      x2 = r1.x + r1.w,
      y1 = r1.y,
      y2 = r1.y + r1.h,
      a1 = r2.x,
      a2 = r2.x + r2.w,
      b1 = r2.y,
      b2 = r2.y + r2.h;
  return x1 <= a1 && a1 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a2 && a2 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a1 && a1 <= x2 && y1 <= b2 && b2 <= y2 || x1 <= a2 && a1 <= x2 && y1 <= b2 && b2 <= y2 || a1 <= x1 && x1 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x2 && x2 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x1 && x1 <= a2 && b1 <= y2 && y2 <= b2 || a1 <= x2 && x1 <= a2 && b1 <= y2 && y2 <= b2;
}
function toABC(line) {
  var A = line[1].y - line[0].y;
  var B = line[0].x - line[1].x;
  return {
    A: A,
    B: B,
    C: A * line[0].x + B * line[0].y
  };
}
function jsplumb_util_es_lineIntersection(l1, l2) {
  var abc1 = toABC(l1),
      abc2 = toABC(l2),
      det = abc1.A * abc2.B - abc2.A * abc1.B;
  if (det == 0) {
    return null;
  } else {
    var candidate = {
      x: (abc2.B * abc1.C - abc1.B * abc2.C) / det,
      y: (abc1.A * abc2.C - abc2.A * abc1.C) / det
    },
        l1xmin = Math.min(l1[0].x, l1[1].x),
        l1xmax = Math.max(l1[0].x, l1[1].x),
        l1ymin = Math.min(l1[0].y, l1[1].y),
        l1ymax = Math.max(l1[0].y, l1[1].y),
        l2xmin = Math.min(l2[0].x, l2[1].x),
        l2xmax = Math.max(l2[0].x, l2[1].x),
        l2ymin = Math.min(l2[0].y, l2[1].y),
        l2ymax = Math.max(l2[0].y, l2[1].y);
    if (candidate.x >= l1xmin && candidate.x <= l1xmax && candidate.y >= l1ymin && candidate.y <= l1ymax && candidate.x >= l2xmin && candidate.x <= l2xmax && candidate.y >= l2ymin && candidate.y <= l2ymax) {
      return candidate;
    } else {
      return null;
    }
  }
}
function lineRectangleIntersection(line, r) {
  var out = [],
      rectangleLines = [[{
    x: r.x,
    y: r.y
  }, {
    x: r.x + r.w,
    y: r.y
  }], [{
    x: r.x + r.w,
    y: r.y
  }, {
    x: r.x + r.w,
    y: r.y + r.h
  }], [{
    x: r.x,
    y: r.y
  }, {
    x: r.x,
    y: r.y + r.h
  }], [{
    x: r.x,
    y: r.y + r.h
  }, {
    x: r.x + r.w,
    y: r.y + r.h
  }]];
  forEach(rectangleLines, function (rLine) {
    var intersection = jsplumb_util_es_lineIntersection(line, rLine);
    if (intersection != null) {
      out.push(intersection);
    }
  });
  return out;
}
function encloses(r1, r2, allowSharedEdges) {
  var x1 = r1.x,
      x2 = r1.x + r1.w,
      y1 = r1.y,
      y2 = r1.y + r1.h,
      a1 = r2.x,
      a2 = r2.x + r2.w,
      b1 = r2.y,
      b2 = r2.y + r2.h,
      c = function c(v1, v2, v3, v4) {
    return allowSharedEdges ? v1 <= v2 && v3 >= v4 : v1 < v2 && v3 > v4;
  };
  return c(x1, a1, x2, a2) && c(y1, b1, y2, b2);
}
function pointOnLine(fromPoint, toPoint, distance) {
  var m = gradient(fromPoint, toPoint),
      s = quadrant(fromPoint, toPoint),
      segmentMultiplier = distance > 0 ? segmentMultipliers[s] : inverseSegmentMultipliers[s],
      theta = Math.atan(m),
      y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
      x = Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
  return {
    x: fromPoint.x + x,
    y: fromPoint.y + y
  };
}
function perpendicularLineTo(fromPoint, toPoint, length) {
  var m = gradient(fromPoint, toPoint),
      theta2 = Math.atan(-1 / m),
      y = length / 2 * Math.sin(theta2),
      x = length / 2 * Math.cos(theta2);
  return [{
    x: toPoint.x + x,
    y: toPoint.y + y
  }, {
    x: toPoint.x - x,
    y: toPoint.y - y
  }];
}
function snapToGrid(pos, grid, thresholdX, thresholdY) {
  thresholdX = thresholdX == null ? grid.thresholdX == null ? grid.w / 2 : grid.thresholdX : thresholdX;
  thresholdY = thresholdY == null ? grid.thresholdY == null ? grid.h / 2 : grid.thresholdY : thresholdY;
  var _dx = Math.floor(pos.x / grid.w),
      _dxl = grid.w * _dx,
      _dxt = _dxl + grid.w,
      x = Math.abs(pos.x - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos.x) <= thresholdX ? _dxt : pos.x;
  var _dy = Math.floor(pos.y / grid.h),
      _dyl = grid.h * _dy,
      _dyt = _dyl + grid.h,
      y = Math.abs(pos.y - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos.y) <= thresholdY ? _dyt : pos.y;
  return {
    x: x,
    y: y
  };
}



// CONCATENATED MODULE: ./node_modules/@jsplumb/common/js/jsplumb.common.es.js
var PerimeterAnchorShapes;
(function (PerimeterAnchorShapes) {
  PerimeterAnchorShapes["Circle"] = "Circle";
  PerimeterAnchorShapes["Ellipse"] = "Ellipse";
  PerimeterAnchorShapes["Triangle"] = "Triangle";
  PerimeterAnchorShapes["Diamond"] = "Diamond";
  PerimeterAnchorShapes["Rectangle"] = "Rectangle";
  PerimeterAnchorShapes["Square"] = "Square";
})(PerimeterAnchorShapes || (PerimeterAnchorShapes = {}));
var AnchorLocations;
(function (AnchorLocations) {
  AnchorLocations["Assign"] = "Assign";
  AnchorLocations["AutoDefault"] = "AutoDefault";
  AnchorLocations["Bottom"] = "Bottom";
  AnchorLocations["BottomLeft"] = "BottomLeft";
  AnchorLocations["BottomRight"] = "BottomRight";
  AnchorLocations["Center"] = "Center";
  AnchorLocations["Continuous"] = "Continuous";
  AnchorLocations["ContinuousBottom"] = "ContinuousBottom";
  AnchorLocations["ContinuousLeft"] = "ContinuousLeft";
  AnchorLocations["ContinuousRight"] = "ContinuousRight";
  AnchorLocations["ContinuousTop"] = "ContinuousTop";
  AnchorLocations["ContinuousLeftRight"] = "ContinuousLeftRight";
  AnchorLocations["ContinuousTopBottom"] = "ContinuousTopBottom";
  AnchorLocations["Left"] = "Left";
  AnchorLocations["Perimeter"] = "Perimeter";
  AnchorLocations["Right"] = "Right";
  AnchorLocations["Top"] = "Top";
  AnchorLocations["TopLeft"] = "TopLeft";
  AnchorLocations["TopRight"] = "TopRight";
})(AnchorLocations || (AnchorLocations = {}));

function jsplumb_common_es_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function jsplumb_common_es_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function jsplumb_common_es_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) jsplumb_common_es_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) jsplumb_common_es_defineProperties(Constructor, staticProps);
  return Constructor;
}

function jsplumb_common_es_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function noSuchPoint() {
  return {
    d: Infinity,
    x: null,
    y: null,
    l: null,
    x1: null,
    y1: null,
    x2: null,
    y2: null
  };
}
function EMPTY_BOUNDS() {
  return {
    xmin: Infinity,
    xmax: -Infinity,
    ymin: Infinity,
    ymax: -Infinity
  };
}
var AbstractSegment = function () {
  function AbstractSegment(params) {
    jsplumb_common_es_classCallCheck(this, AbstractSegment);
    this.params = params;
    jsplumb_common_es_defineProperty(this, "x1", void 0);
    jsplumb_common_es_defineProperty(this, "x2", void 0);
    jsplumb_common_es_defineProperty(this, "y1", void 0);
    jsplumb_common_es_defineProperty(this, "y2", void 0);
    jsplumb_common_es_defineProperty(this, "extents", EMPTY_BOUNDS());
    jsplumb_common_es_defineProperty(this, "type", void 0);
    this.x1 = params.x1;
    this.y1 = params.y1;
    this.x2 = params.x2;
    this.y2 = params.y2;
  }
  jsplumb_common_es_createClass(AbstractSegment, [{
    key: "findClosestPointOnPath",
    value: function findClosestPointOnPath(x, y) {
      return noSuchPoint();
    }
  }, {
    key: "lineIntersection",
    value: function lineIntersection(x1, y1, x2, y2) {
      return [];
    }
  }, {
    key: "boxIntersection",
    value: function boxIntersection(x, y, w, h) {
      var a = [];
      a.push.apply(a, this.lineIntersection(x, y, x + w, y));
      a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
      a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
      a.push.apply(a, this.lineIntersection(x, y + h, x, y));
      return a;
    }
  }, {
    key: "boundingBoxIntersection",
    value: function boundingBoxIntersection(box) {
      return this.boxIntersection(box.x, box.y, box.w, box.h);
    }
  }]);
  return AbstractSegment;
}();

var UNDEFINED = "undefined";
var DEFAULT = "default";
var TRUE = "true";
var FALSE = "false";
var WILDCARD = "*";



// CONCATENATED MODULE: ./node_modules/@jsplumb/core/js/jsplumb.core.es.js



function jsplumb_core_es_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function jsplumb_core_es_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function jsplumb_core_es_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) jsplumb_core_es_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) jsplumb_core_es_defineProperties(Constructor, staticProps);
  return Constructor;
}

function jsplumb_core_es_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function jsplumb_core_es_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) jsplumb_core_es_setPrototypeOf(subClass, superClass);
}

function jsplumb_core_es_getPrototypeOf(o) {
  jsplumb_core_es_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return jsplumb_core_es_getPrototypeOf(o);
}

function jsplumb_core_es_setPrototypeOf(o, p) {
  jsplumb_core_es_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return jsplumb_core_es_setPrototypeOf(o, p);
}

function jsplumb_core_es_isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function jsplumb_core_es_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function jsplumb_core_es_possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return jsplumb_core_es_assertThisInitialized(self);
}

function jsplumb_core_es_createSuper(Derived) {
  var hasNativeReflectConstruct = jsplumb_core_es_isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = jsplumb_core_es_getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = jsplumb_core_es_getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return jsplumb_core_es_possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = jsplumb_core_es_getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function jsplumb_core_es_slicedToArray(arr, i) {
  return jsplumb_core_es_arrayWithHoles(arr) || jsplumb_core_es_iterableToArrayLimit(arr, i) || jsplumb_core_es_unsupportedIterableToArray(arr, i) || jsplumb_core_es_nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || jsplumb_core_es_unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return jsplumb_core_es_arrayLikeToArray(arr);
}

function jsplumb_core_es_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function jsplumb_core_es_iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function jsplumb_core_es_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return jsplumb_core_es_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jsplumb_core_es_arrayLikeToArray(o, minLen);
}

function jsplumb_core_es_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function jsplumb_core_es_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var endpointMap = {};
var endpointComputers = {};
var jsplumb_core_es_handlers = {};
var EndpointFactory = {
  get: function get(ep, name, params) {
    var e = endpointMap[name];
    if (!e) {
      throw {
        message: "jsPlumb: unknown endpoint type '" + name + "'"
      };
    } else {
      return new e(ep, params);
    }
  },
  clone: function clone(epr) {
    var handler = jsplumb_core_es_handlers[epr.type];
    return EndpointFactory.get(epr.endpoint, epr.type, handler.getParams(epr));
  },
  compute: function compute(endpoint, anchorPoint, orientation, endpointStyle) {
    var c = endpointComputers[endpoint.type];
    if (c != null) {
      return c(endpoint, anchorPoint, orientation, endpointStyle);
    } else {
      log("jsPlumb: cannot find endpoint calculator for endpoint of type ", endpoint.type);
    }
  },
  registerHandler: function registerHandler(eph) {
    jsplumb_core_es_handlers[eph.type] = eph;
    endpointMap[eph.type] = eph.cls;
    endpointComputers[eph.type] = eph.compute;
  }
};

var jsplumb_core_es_EndpointRepresentation = function () {
  function EndpointRepresentation(endpoint, params) {
    jsplumb_core_es_classCallCheck(this, EndpointRepresentation);
    this.endpoint = endpoint;
    jsplumb_core_es_defineProperty(this, "typeId", void 0);
    jsplumb_core_es_defineProperty(this, "x", void 0);
    jsplumb_core_es_defineProperty(this, "y", void 0);
    jsplumb_core_es_defineProperty(this, "w", void 0);
    jsplumb_core_es_defineProperty(this, "h", void 0);
    jsplumb_core_es_defineProperty(this, "computedValue", void 0);
    jsplumb_core_es_defineProperty(this, "bounds", EMPTY_BOUNDS());
    jsplumb_core_es_defineProperty(this, "classes", []);
    jsplumb_core_es_defineProperty(this, "instance", void 0);
    jsplumb_core_es_defineProperty(this, "type", void 0);
    params = params || {};
    this.instance = endpoint.instance;
    if (endpoint.cssClass) {
      this.classes.push(endpoint.cssClass);
    }
    if (params.cssClass) {
      this.classes.push(params.cssClass);
    }
  }
  jsplumb_core_es_createClass(EndpointRepresentation, [{
    key: "addClass",
    value: function addClass(c) {
      this.classes.push(c);
      this.instance.addEndpointClass(this.endpoint, c);
    }
  }, {
    key: "removeClass",
    value: function removeClass(c) {
      this.classes = this.classes.filter(function (_c) {
        return _c !== c;
      });
      this.instance.removeEndpointClass(this.endpoint, c);
    }
  }, {
    key: "compute",
    value: function compute(anchorPoint, orientation, endpointStyle) {
      this.computedValue = EndpointFactory.compute(this, anchorPoint, orientation, endpointStyle);
      this.bounds.xmin = this.x;
      this.bounds.ymin = this.y;
      this.bounds.xmax = this.x + this.w;
      this.bounds.ymax = this.y + this.h;
    }
  }, {
    key: "setVisible",
    value: function setVisible(v) {
      this.instance.setEndpointVisible(this.endpoint, v);
    }
  }]);
  return EndpointRepresentation;
}();

var DotEndpoint = function (_EndpointRepresentati) {
  jsplumb_core_es_inherits(DotEndpoint, _EndpointRepresentati);
  var _super = jsplumb_core_es_createSuper(DotEndpoint);
  function DotEndpoint(endpoint, params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, DotEndpoint);
    _this = _super.call(this, endpoint, params);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "radius", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "defaultOffset", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "defaultInnerRadius", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", DotEndpoint.type);
    params = params || {};
    _this.radius = params.radius || 5;
    _this.defaultOffset = 0.5 * _this.radius;
    _this.defaultInnerRadius = _this.radius / 3;
    return _this;
  }
  return DotEndpoint;
}(jsplumb_core_es_EndpointRepresentation);
jsplumb_core_es_defineProperty(DotEndpoint, "type", "Dot");
var DotEndpointHandler = {
  type: DotEndpoint.type,
  cls: DotEndpoint,
  compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
    var x = anchorPoint.curX - ep.radius,
        y = anchorPoint.curY - ep.radius,
        w = ep.radius * 2,
        h = ep.radius * 2;
    if (endpointStyle && endpointStyle.stroke) {
      var lw = endpointStyle.strokeWidth || 1;
      x -= lw;
      y -= lw;
      w += lw * 2;
      h += lw * 2;
    }
    ep.x = x;
    ep.y = y;
    ep.w = w;
    ep.h = h;
    return [x, y, w, h, ep.radius];
  },
  getParams: function getParams(ep) {
    return {
      radius: ep.radius
    };
  }
};

var BlankEndpoint = function (_EndpointRepresentati) {
  jsplumb_core_es_inherits(BlankEndpoint, _EndpointRepresentati);
  var _super = jsplumb_core_es_createSuper(BlankEndpoint);
  function BlankEndpoint(endpoint, params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, BlankEndpoint);
    _this = _super.call(this, endpoint, params);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", BlankEndpoint.type);
    return _this;
  }
  return BlankEndpoint;
}(jsplumb_core_es_EndpointRepresentation);
jsplumb_core_es_defineProperty(BlankEndpoint, "type", "Blank");
var BlankEndpointHandler = {
  type: BlankEndpoint.type,
  cls: BlankEndpoint,
  compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
    ep.x = anchorPoint.curX;
    ep.y = anchorPoint.curY;
    ep.w = 10;
    ep.h = 0;
    return [anchorPoint.curX, anchorPoint.curY, 10, 0];
  },
  getParams: function getParams(ep) {
    return {};
  }
};

var RectangleEndpoint = function (_EndpointRepresentati) {
  jsplumb_core_es_inherits(RectangleEndpoint, _EndpointRepresentati);
  var _super = jsplumb_core_es_createSuper(RectangleEndpoint);
  function RectangleEndpoint(endpoint, params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, RectangleEndpoint);
    _this = _super.call(this, endpoint, params);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "width", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "height", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", RectangleEndpoint.type);
    params = params || {};
    _this.width = params.width || 10;
    _this.height = params.height || 10;
    return _this;
  }
  jsplumb_core_es_createClass(RectangleEndpoint, null, [{
    key: "_getParams",
    value: function _getParams(ep) {
      return {
        width: ep.width,
        height: ep.height
      };
    }
  }]);
  return RectangleEndpoint;
}(jsplumb_core_es_EndpointRepresentation);
jsplumb_core_es_defineProperty(RectangleEndpoint, "type", "Rectangle");
var RectangleEndpointHandler = {
  type: RectangleEndpoint.type,
  cls: RectangleEndpoint,
  compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
    var width = endpointStyle.width || ep.width,
        height = endpointStyle.height || ep.height,
        x = anchorPoint.curX - width / 2,
        y = anchorPoint.curY - height / 2;
    ep.x = x;
    ep.y = y;
    ep.w = width;
    ep.h = height;
    return [x, y, width, height];
  },
  getParams: function getParams(ep) {
    return {
      width: ep.width,
      height: ep.height
    };
  }
};

var jsplumb_core_es_AbstractConnector = function () {
  function AbstractConnector(connection, params) {
    jsplumb_core_es_classCallCheck(this, AbstractConnector);
    this.connection = connection;
    jsplumb_core_es_defineProperty(this, "type", void 0);
    jsplumb_core_es_defineProperty(this, "edited", false);
    jsplumb_core_es_defineProperty(this, "stub", void 0);
    jsplumb_core_es_defineProperty(this, "sourceStub", void 0);
    jsplumb_core_es_defineProperty(this, "targetStub", void 0);
    jsplumb_core_es_defineProperty(this, "maxStub", void 0);
    jsplumb_core_es_defineProperty(this, "typeId", void 0);
    jsplumb_core_es_defineProperty(this, "gap", void 0);
    jsplumb_core_es_defineProperty(this, "sourceGap", void 0);
    jsplumb_core_es_defineProperty(this, "targetGap", void 0);
    jsplumb_core_es_defineProperty(this, "segments", []);
    jsplumb_core_es_defineProperty(this, "totalLength", 0);
    jsplumb_core_es_defineProperty(this, "segmentProportions", []);
    jsplumb_core_es_defineProperty(this, "segmentProportionalLengths", []);
    jsplumb_core_es_defineProperty(this, "paintInfo", null);
    jsplumb_core_es_defineProperty(this, "strokeWidth", void 0);
    jsplumb_core_es_defineProperty(this, "x", void 0);
    jsplumb_core_es_defineProperty(this, "y", void 0);
    jsplumb_core_es_defineProperty(this, "w", void 0);
    jsplumb_core_es_defineProperty(this, "h", void 0);
    jsplumb_core_es_defineProperty(this, "segment", void 0);
    jsplumb_core_es_defineProperty(this, "bounds", EMPTY_BOUNDS());
    jsplumb_core_es_defineProperty(this, "cssClass", void 0);
    jsplumb_core_es_defineProperty(this, "hoverClass", void 0);
    jsplumb_core_es_defineProperty(this, "geometry", void 0);
    this.stub = params.stub || this.getDefaultStubs();
    this.sourceStub = Array.isArray(this.stub) ? this.stub[0] : this.stub;
    this.targetStub = Array.isArray(this.stub) ? this.stub[1] : this.stub;
    this.gap = params.gap || 0;
    this.sourceGap = Array.isArray(this.gap) ? this.gap[0] : this.gap;
    this.targetGap = Array.isArray(this.gap) ? this.gap[1] : this.gap;
    this.maxStub = Math.max(this.sourceStub, this.targetStub);
    this.cssClass = params.cssClass || "";
    this.hoverClass = params.hoverClass || "";
  }
  jsplumb_core_es_createClass(AbstractConnector, [{
    key: "getTypeDescriptor",
    value: function getTypeDescriptor() {
      return "connector";
    }
  }, {
    key: "getIdPrefix",
    value: function getIdPrefix() {
      return "_jsplumb_connector";
    }
  }, {
    key: "setGeometry",
    value: function setGeometry(g, internal) {
      this.geometry = g;
      this.edited = g != null && !internal;
    }
  }, {
    key: "exportGeometry",
    value: function exportGeometry() {
      return this.geometry;
    }
  }, {
    key: "importGeometry",
    value: function importGeometry(g) {
      this.geometry = g;
      return true;
    }
  }, {
    key: "resetGeometry",
    value: function resetGeometry() {
      this.geometry = null;
      this.edited = false;
    }
  }, {
    key: "resetBounds",
    value: function resetBounds() {
      this.bounds = EMPTY_BOUNDS();
    }
  }, {
    key: "findSegmentForPoint",
    value: function findSegmentForPoint(x, y) {
      var out = {
        d: Infinity,
        s: null,
        x: null,
        y: null,
        l: null,
        x1: null,
        y1: null,
        x2: null,
        y2: null,
        index: null,
        connectorLocation: null
      };
      for (var i = 0; i < this.segments.length; i++) {
        var _s = this.segments[i].findClosestPointOnPath(x, y);
        if (_s.d < out.d) {
          out.d = _s.d;
          out.l = _s.l;
          out.x = _s.x;
          out.y = _s.y;
          out.s = this.segments[i];
          out.x1 = _s.x1;
          out.x2 = _s.x2;
          out.y1 = _s.y1;
          out.y2 = _s.y2;
          out.index = i;
          out.connectorLocation = this.segmentProportions[i][0] + _s.l * (this.segmentProportions[i][1] - this.segmentProportions[i][0]);
        }
      }
      return out;
    }
  }, {
    key: "lineIntersection",
    value: function lineIntersection(x1, y1, x2, y2) {
      var out = [];
      for (var i = 0; i < this.segments.length; i++) {
        out.push.apply(out, this.segments[i].lineIntersection(x1, y1, x2, y2));
      }
      return out;
    }
  }, {
    key: "boxIntersection",
    value: function boxIntersection(x, y, w, h) {
      var out = [];
      for (var i = 0; i < this.segments.length; i++) {
        out.push.apply(out, this.segments[i].boxIntersection(x, y, w, h));
      }
      return out;
    }
  }, {
    key: "boundingBoxIntersection",
    value: function boundingBoxIntersection(box) {
      var out = [];
      for (var i = 0; i < this.segments.length; i++) {
        out.push.apply(out, this.segments[i].boundingBoxIntersection(box));
      }
      return out;
    }
  }, {
    key: "_updateSegmentProportions",
    value: function _updateSegmentProportions() {
      var curLoc = 0;
      for (var i = 0; i < this.segments.length; i++) {
        var sl = this.segments[i].getLength();
        this.segmentProportionalLengths[i] = sl / this.totalLength;
        this.segmentProportions[i] = [curLoc, curLoc += sl / this.totalLength];
      }
    }
  }, {
    key: "_findSegmentForLocation",
    value: function _findSegmentForLocation(location, absolute) {
      var idx, i, inSegmentProportion;
      if (absolute) {
        location = location > 0 ? location / this.totalLength : (this.totalLength + location) / this.totalLength;
      }
      if (location === 1) {
        idx = this.segments.length - 1;
        inSegmentProportion = 1;
      } else if (location === 0) {
        inSegmentProportion = 0;
        idx = 0;
      } else {
        if (location >= 0.5) {
          idx = 0;
          inSegmentProportion = 0;
          for (i = this.segmentProportions.length - 1; i > -1; i--) {
            if (this.segmentProportions[i][1] >= location && this.segmentProportions[i][0] <= location) {
              idx = i;
              inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
              break;
            }
          }
        } else {
          idx = this.segmentProportions.length - 1;
          inSegmentProportion = 1;
          for (i = 0; i < this.segmentProportions.length; i++) {
            if (this.segmentProportions[i][1] >= location) {
              idx = i;
              inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
              break;
            }
          }
        }
      }
      return {
        segment: this.segments[idx],
        proportion: inSegmentProportion,
        index: idx
      };
    }
  }, {
    key: "_addSegment",
    value: function _addSegment(clazz, params) {
      if (params.x1 === params.x2 && params.y1 === params.y2) {
        return;
      }
      var s = new clazz(params);
      this.segments.push(s);
      this.totalLength += s.getLength();
      this.updateBounds(s);
    }
  }, {
    key: "_clearSegments",
    value: function _clearSegments() {
      this.totalLength = 0;
      this.segments.length = 0;
      this.segmentProportions.length = 0;
      this.segmentProportionalLengths.length = 0;
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.totalLength;
    }
  }, {
    key: "_prepareCompute",
    value: function _prepareCompute(params) {
      this.strokeWidth = params.strokeWidth;
      var x1 = params.sourcePos.curX,
          x2 = params.targetPos.curX,
          y1 = params.sourcePos.curY,
          y2 = params.targetPos.curY,
          segment = quadrant({
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      }),
          swapX = x2 < x1,
          swapY = y2 < y1,
          so = [params.sourcePos.ox, params.sourcePos.oy],
          to = [params.targetPos.ox, params.targetPos.oy],
          x = swapX ? x2 : x1,
          y = swapY ? y2 : y1,
          w = Math.abs(x2 - x1),
          h = Math.abs(y2 - y1);
      if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
        var index = w > h ? 0 : 1,
            oIndex = [1, 0][index],
            v1 = index === 0 ? x1 : y1,
            v2 = index === 0 ? x2 : y2;
        so[index] = v1 > v2 ? -1 : 1;
        to[index] = v1 > v2 ? 1 : -1;
        so[oIndex] = 0;
        to[oIndex] = 0;
      }
      var sx = swapX ? w + this.sourceGap * so[0] : this.sourceGap * so[0],
          sy = swapY ? h + this.sourceGap * so[1] : this.sourceGap * so[1],
          tx = swapX ? this.targetGap * to[0] : w + this.targetGap * to[0],
          ty = swapY ? this.targetGap * to[1] : h + this.targetGap * to[1],
          oProduct = so[0] * to[0] + so[1] * to[1];
      var result = {
        sx: sx,
        sy: sy,
        tx: tx,
        ty: ty,
        xSpan: Math.abs(tx - sx),
        ySpan: Math.abs(ty - sy),
        mx: (sx + tx) / 2,
        my: (sy + ty) / 2,
        so: so,
        to: to,
        x: x,
        y: y,
        w: w,
        h: h,
        segment: segment,
        startStubX: sx + so[0] * this.sourceStub,
        startStubY: sy + so[1] * this.sourceStub,
        endStubX: tx + to[0] * this.targetStub,
        endStubY: ty + to[1] * this.targetStub,
        isXGreaterThanStubTimes2: Math.abs(sx - tx) > this.sourceStub + this.targetStub,
        isYGreaterThanStubTimes2: Math.abs(sy - ty) > this.sourceStub + this.targetStub,
        opposite: oProduct === -1,
        perpendicular: oProduct === 0,
        orthogonal: oProduct === 1,
        sourceAxis: so[0] === 0 ? "y" : "x",
        points: [x, y, w, h, sx, sy, tx, ty],
        stubs: [this.sourceStub, this.targetStub]
      };
      result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
      return result;
    }
  }, {
    key: "updateBounds",
    value: function updateBounds(segment) {
      var segBounds = segment.extents;
      this.bounds.xmin = Math.min(this.bounds.xmin, segBounds.xmin);
      this.bounds.xmax = Math.max(this.bounds.xmax, segBounds.xmax);
      this.bounds.ymin = Math.min(this.bounds.ymin, segBounds.ymin);
      this.bounds.ymax = Math.max(this.bounds.ymax, segBounds.ymax);
    }
  }, {
    key: "dumpSegmentsToConsole",
    value: function dumpSegmentsToConsole() {
      log("SEGMENTS:");
      for (var i = 0; i < this.segments.length; i++) {
        log(this.segments[i].type, "" + this.segments[i].getLength(), "" + this.segmentProportions[i]);
      }
    }
  }, {
    key: "pointOnPath",
    value: function pointOnPath(location, absolute) {
      var seg = this._findSegmentForLocation(location, absolute);
      return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || {
        x: 0,
        y: 0
      };
    }
  }, {
    key: "gradientAtPoint",
    value: function gradientAtPoint(location, absolute) {
      var seg = this._findSegmentForLocation(location, absolute);
      return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
    }
  }, {
    key: "pointAlongPathFrom",
    value: function pointAlongPathFrom(location, distance, absolute) {
      var seg = this._findSegmentForLocation(location, absolute);
      return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || {
        x: 0,
        y: 0
      };
    }
  }, {
    key: "compute",
    value: function compute(params) {
      this.paintInfo = this._prepareCompute(params);
      this._clearSegments();
      this._compute(this.paintInfo, params);
      this.x = this.paintInfo.points[0];
      this.y = this.paintInfo.points[1];
      this.w = this.paintInfo.points[2];
      this.h = this.paintInfo.points[3];
      this.segment = this.paintInfo.segment;
      this._updateSegmentProportions();
    }
  }, {
    key: "setAnchorOrientation",
    value: function setAnchorOrientation(idx, orientation) {}
  }]);
  return AbstractConnector;
}();

var jsplumb_core_es_StraightSegment = function (_AbstractSegment) {
  jsplumb_core_es_inherits(StraightSegment, _AbstractSegment);
  var _super = jsplumb_core_es_createSuper(StraightSegment);
  function StraightSegment(params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, StraightSegment);
    _this = _super.call(this, params);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "length", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "m", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "m2", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", StraightSegment.segmentType);
    _this._setCoordinates({
      x1: params.x1,
      y1: params.y1,
      x2: params.x2,
      y2: params.y2
    });
    return _this;
  }
  jsplumb_core_es_createClass(StraightSegment, [{
    key: "getPath",
    value: function getPath(isFirstSegment) {
      return (isFirstSegment ? "M " + this.x1 + " " + this.y1 + " " : "") + "L " + this.x2 + " " + this.y2;
    }
  }, {
    key: "_recalc",
    value: function _recalc() {
      this.length = Math.sqrt(Math.pow(this.x2 - this.x1, 2) + Math.pow(this.y2 - this.y1, 2));
      this.m = gradient({
        x: this.x1,
        y: this.y1
      }, {
        x: this.x2,
        y: this.y2
      });
      this.m2 = -1 / this.m;
      this.extents = {
        xmin: Math.min(this.x1, this.x2),
        ymin: Math.min(this.y1, this.y2),
        xmax: Math.max(this.x1, this.x2),
        ymax: Math.max(this.y1, this.y2)
      };
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.length;
    }
  }, {
    key: "getGradient",
    value: function getGradient() {
      return this.m;
    }
  }, {
    key: "_setCoordinates",
    value: function _setCoordinates(coords) {
      this.x1 = coords.x1;
      this.y1 = coords.y1;
      this.x2 = coords.x2;
      this.y2 = coords.y2;
      this._recalc();
    }
  }, {
    key: "pointOnPath",
    value: function pointOnPath(location, absolute) {
      if (location === 0 && !absolute) {
        return {
          x: this.x1,
          y: this.y1
        };
      } else if (location === 1 && !absolute) {
        return {
          x: this.x2,
          y: this.y2
        };
      } else {
        var l = absolute ? location > 0 ? location : this.length + location : location * this.length;
        return pointOnLine({
          x: this.x1,
          y: this.y1
        }, {
          x: this.x2,
          y: this.y2
        }, l);
      }
    }
  }, {
    key: "gradientAtPoint",
    value: function gradientAtPoint(location, absolute) {
      return this.m;
    }
  }, {
    key: "pointAlongPathFrom",
    value: function pointAlongPathFrom(location, distance, absolute) {
      var p = this.pointOnPath(location, absolute),
          farAwayPoint = distance <= 0 ? {
        x: this.x1,
        y: this.y1
      } : {
        x: this.x2,
        y: this.y2
      };
      if (distance <= 0 && Math.abs(distance) > 1) {
        distance *= -1;
      }
      return pointOnLine(p, farAwayPoint, distance);
    }
  }, {
    key: "within",
    value: function within(a, b, c) {
      return c >= Math.min(a, b) && c <= Math.max(a, b);
    }
  }, {
    key: "closest",
    value: function closest(a, b, c) {
      return Math.abs(c - a) < Math.abs(c - b) ? a : b;
    }
  }, {
    key: "findClosestPointOnPath",
    value: function findClosestPointOnPath(x, y) {
      var out = {
        d: Infinity,
        x: null,
        y: null,
        l: null,
        x1: this.x1,
        x2: this.x2,
        y1: this.y1,
        y2: this.y2
      };
      if (this.m === 0) {
        out.y = this.y1;
        out.x = this.within(this.x1, this.x2, x) ? x : this.closest(this.x1, this.x2, x);
      } else if (this.m === Infinity || this.m === -Infinity) {
        out.x = this.x1;
        out.y = this.within(this.y1, this.y2, y) ? y : this.closest(this.y1, this.y2, y);
      } else {
        var b = this.y1 - this.m * this.x1,
            b2 = y - this.m2 * x,
        _x1 = (b2 - b) / (this.m - this.m2),
            _y1 = this.m * _x1 + b;
        out.x = this.within(this.x1, this.x2, _x1) ? _x1 : this.closest(this.x1, this.x2, _x1);
        out.y = this.within(this.y1, this.y2, _y1) ? _y1 : this.closest(this.y1, this.y2, _y1);
      }
      var fractionInSegment = lineLength({
        x: out.x,
        y: out.y
      }, {
        x: this.x1,
        y: this.y1
      });
      out.d = lineLength({
        x: x,
        y: y
      }, out);
      out.l = fractionInSegment / length;
      return out;
    }
  }, {
    key: "_pointLiesBetween",
    value: function _pointLiesBetween(q, p1, p2) {
      return p2 > p1 ? p1 <= q && q <= p2 : p1 >= q && q >= p2;
    }
  }, {
    key: "lineIntersection",
    value: function lineIntersection(_x1, _y1, _x2, _y2) {
      var m2 = Math.abs(gradient({
        x: _x1,
        y: _y1
      }, {
        x: _x2,
        y: _y2
      })),
          m1 = Math.abs(this.m),
          b = m1 === Infinity ? this.x1 : this.y1 - m1 * this.x1,
          out = [],
          b2 = m2 === Infinity ? _x1 : _y1 - m2 * _x1;
      if (m2 !== m1) {
        if (m2 === Infinity && m1 === 0) {
          if (this._pointLiesBetween(_x1, this.x1, this.x2) && this._pointLiesBetween(this.y1, _y1, _y2)) {
            out.push({
              x: _x1,
              y: this.y1
            });
          }
        } else if (m2 === 0 && m1 === Infinity) {
          if (this._pointLiesBetween(_y1, this.y1, this.y2) && this._pointLiesBetween(this.x1, _x1, _x2)) {
            out.push({
              x: this.x1,
              y: _y1
            });
          }
        } else {
          var X, Y;
          if (m2 === Infinity) {
            X = _x1;
            if (this._pointLiesBetween(X, this.x1, this.x2)) {
              Y = m1 * _x1 + b;
              if (this._pointLiesBetween(Y, _y1, _y2)) {
                out.push({
                  x: X,
                  y: Y
                });
              }
            }
          } else if (m2 === 0) {
            Y = _y1;
            if (this._pointLiesBetween(Y, this.y1, this.y2)) {
              X = (_y1 - b) / m1;
              if (this._pointLiesBetween(X, _x1, _x2)) {
                out.push({
                  x: X,
                  y: Y
                });
              }
            }
          } else {
            X = (b2 - b) / (m1 - m2);
            Y = m1 * X + b;
            if (this._pointLiesBetween(X, this.x1, this.x2) && this._pointLiesBetween(Y, this.y1, this.y2)) {
              out.push({
                x: X,
                y: Y
              });
            }
          }
        }
      }
      return out;
    }
  }, {
    key: "boxIntersection",
    value: function boxIntersection(x, y, w, h) {
      var a = [];
      a.push.apply(a, this.lineIntersection(x, y, x + w, y));
      a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
      a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
      a.push.apply(a, this.lineIntersection(x, y + h, x, y));
      return a;
    }
  }]);
  return StraightSegment;
}(AbstractSegment);
jsplumb_core_es_defineProperty(jsplumb_core_es_StraightSegment, "segmentType", "Straight");

var StraightConnector = function (_AbstractConnector) {
  jsplumb_core_es_inherits(StraightConnector, _AbstractConnector);
  var _super = jsplumb_core_es_createSuper(StraightConnector);
  function StraightConnector() {
    var _this;
    jsplumb_core_es_classCallCheck(this, StraightConnector);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", StraightConnector.type);
    return _this;
  }
  jsplumb_core_es_createClass(StraightConnector, [{
    key: "getDefaultStubs",
    value: function getDefaultStubs() {
      return [0, 0];
    }
  }, {
    key: "_compute",
    value: function _compute(paintInfo, p) {
      this._addSegment(jsplumb_core_es_StraightSegment, {
        x1: paintInfo.sx,
        y1: paintInfo.sy,
        x2: paintInfo.startStubX,
        y2: paintInfo.startStubY
      });
      this._addSegment(jsplumb_core_es_StraightSegment, {
        x1: paintInfo.startStubX,
        y1: paintInfo.startStubY,
        x2: paintInfo.endStubX,
        y2: paintInfo.endStubY
      });
      this._addSegment(jsplumb_core_es_StraightSegment, {
        x1: paintInfo.endStubX,
        y1: paintInfo.endStubY,
        x2: paintInfo.tx,
        y2: paintInfo.ty
      });
      this.geometry = {
        source: p.sourcePos,
        target: p.targetPos
      };
    }
  }]);
  return StraightConnector;
}(jsplumb_core_es_AbstractConnector);
jsplumb_core_es_defineProperty(StraightConnector, "type", "Straight");

var connectorMap = {};
var Connectors = {
  get: function get(connection, name, params) {
    var c = connectorMap[name];
    if (!c) {
      throw {
        message: "jsPlumb: unknown connector type '" + name + "'"
      };
    } else {
      return new c(connection, params);
    }
  },
  register: function register(name, conn) {
    connectorMap[name] = conn;
  }
};

function cls() {
  for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {
    className[_key] = arguments[_key];
  }
  return className.map(function (cn) {
    return "." + cn;
  }).join(",");
}
function jsplumb_core_es_classList() {
  for (var _len2 = arguments.length, className = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    className[_key2] = arguments[_key2];
  }
  return className.join(" ");
}
function jsplumb_core_es_att() {
  for (var _len3 = arguments.length, attName = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    attName[_key3] = arguments[_key3];
  }
  return attName.map(function (an) {
    return "[" + an + "]";
  }).join(",");
}
var SOURCE = "source";
var TARGET = "target";
var BLOCK = "block";
var NONE = "none";
var SOURCE_INDEX = 0;
var TARGET_INDEX = 1;
var ABSOLUTE = "absolute";
var FIXED = "fixed";
var STATIC = "static";
var ATTRIBUTE_GROUP = "data-jtk-group";
var ATTRIBUTE_MANAGED = "data-jtk-managed";
var ATTRIBUTE_NOT_DRAGGABLE = "data-jtk-not-draggable";
var ATTRIBUTE_TABINDEX = "tabindex";
var ATTRIBUTE_SCOPE = "data-jtk-scope";
var ATTRIBUTE_SCOPE_PREFIX = ATTRIBUTE_SCOPE + "-";
var CHECK_CONDITION = "checkCondition";
var CHECK_DROP_ALLOWED = "checkDropAllowed";
var CLASS_CONNECTOR = "jtk-connector";
var CLASS_CONNECTOR_OUTLINE = "jtk-connector-outline";
var CLASS_CONNECTED = "jtk-connected";
var CLASS_ENDPOINT = "jtk-endpoint";
var CLASS_ENDPOINT_CONNECTED = "jtk-endpoint-connected";
var CLASS_ENDPOINT_FULL = "jtk-endpoint-full";
var CLASS_ENDPOINT_DROP_ALLOWED = "jtk-endpoint-drop-allowed";
var CLASS_ENDPOINT_DROP_FORBIDDEN = "jtk-endpoint-drop-forbidden";
var CLASS_ENDPOINT_ANCHOR_PREFIX = "jtk-endpoint-anchor";
var CLASS_GROUP_COLLAPSED = "jtk-group-collapsed";
var CLASS_GROUP_EXPANDED = "jtk-group-expanded";
var CLASS_OVERLAY = "jtk-overlay";
var EVENT_ANCHOR_CHANGED = "anchor:changed";
var EVENT_CONNECTION = "connection";
var EVENT_INTERNAL_CONNECTION = "internal.connection";
var EVENT_CONNECTION_DETACHED = "connection:detach";
var EVENT_CONNECTION_MOVED = "connection:move";
var EVENT_CONTAINER_CHANGE = "container:change";
var EVENT_ENDPOINT_REPLACED = "endpoint:replaced";
var EVENT_INTERNAL_ENDPOINT_UNREGISTERED = "internal.endpoint:unregistered";
var EVENT_INTERNAL_CONNECTION_DETACHED = "internal.connection:detached";
var EVENT_MANAGE_ELEMENT = "element:manage";
var EVENT_GROUP_ADDED = "group:added";
var EVENT_GROUP_COLLAPSE = "group:collapse";
var EVENT_GROUP_EXPAND = "group:expand";
var EVENT_GROUP_MEMBER_ADDED = "group:member:added";
var EVENT_GROUP_MEMBER_REMOVED = "group:member:removed";
var EVENT_GROUP_REMOVED = "group:removed";
var EVENT_MAX_CONNECTIONS = "maxConnections";
var EVENT_NESTED_GROUP_ADDED = "group:nested:added";
var EVENT_NESTED_GROUP_REMOVED = "group:nested:removed";
var EVENT_UNMANAGE_ELEMENT = "element:unmanage";
var EVENT_ZOOM = "zoom";
var IS_DETACH_ALLOWED = "isDetachAllowed";
var INTERCEPT_BEFORE_DRAG = "beforeDrag";
var INTERCEPT_BEFORE_DROP = "beforeDrop";
var INTERCEPT_BEFORE_DETACH = "beforeDetach";
var INTERCEPT_BEFORE_START_DETACH = "beforeStartDetach";
var SELECTOR_MANAGED_ELEMENT = jsplumb_core_es_att(ATTRIBUTE_MANAGED);
var ERROR_SOURCE_ENDPOINT_FULL = "Cannot establish connection: source endpoint is full";
var ERROR_TARGET_ENDPOINT_FULL = "Cannot establish connection: target endpoint is full";
var ERROR_SOURCE_DOES_NOT_EXIST = "Cannot establish connection: source does not exist";
var ERROR_TARGET_DOES_NOT_EXIST = "Cannot establish connection: target does not exist";
var KEY_CONNECTION_OVERLAYS = "connectionOverlays";

function isFullOverlaySpec(o) {
  return o.type != null && o.options != null;
}
function convertToFullOverlaySpec(spec) {
  var o = null;
  if (isString(spec)) {
    o = {
      type: spec,
      options: {}
    };
  } else {
    o = spec;
  }
  o.options.id = o.options.id || jsplumb_util_es_uuid();
  return o;
}
var jsplumb_core_es_Overlay = function (_EventGenerator) {
  jsplumb_core_es_inherits(Overlay, _EventGenerator);
  var _super = jsplumb_core_es_createSuper(Overlay);
  function Overlay(instance, component, p) {
    var _this;
    jsplumb_core_es_classCallCheck(this, Overlay);
    _this = _super.call(this);
    _this.instance = instance;
    _this.component = component;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "id", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cssClass", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "visible", true);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "location", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "events", void 0);
    p = p || {};
    _this.id = p.id || jsplumb_util_es_uuid();
    _this.cssClass = p.cssClass || "";
    _this.location = p.location || 0.5;
    _this.events = p.events || {};
    for (var _event in _this.events) {
      _this.bind(_event, _this.events[_event]);
    }
    return _this;
  }
  jsplumb_core_es_createClass(Overlay, [{
    key: "shouldFireEvent",
    value: function shouldFireEvent(event, value, originalEvent) {
      return true;
    }
  }, {
    key: "setVisible",
    value: function setVisible(v) {
      this.visible = v;
      this.instance.setOverlayVisible(this, v);
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      return this.visible;
    }
  }]);
  return Overlay;
}(EventGenerator);

var overlayMap = {};
var OverlayFactory = {
  get: function get(instance, name, component, params) {
    var c = overlayMap[name];
    if (!c) {
      throw {
        message: "jsPlumb: unknown overlay type '" + name + "'"
      };
    } else {
      return new c(instance, component, params);
    }
  },
  register: function register(name, overlay) {
    overlayMap[name] = overlay;
  }
};

var jsplumb_core_es_LabelOverlay = function (_Overlay) {
  jsplumb_core_es_inherits(LabelOverlay, _Overlay);
  var _super = jsplumb_core_es_createSuper(LabelOverlay);
  function LabelOverlay(instance, component, p) {
    var _this;
    jsplumb_core_es_classCallCheck(this, LabelOverlay);
    _this = _super.call(this, instance, component, p);
    _this.instance = instance;
    _this.component = component;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "label", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "labelText", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", LabelOverlay.type);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cachedDimensions", void 0);
    p = p || {
      label: ""
    };
    _this.setLabel(p.label);
    return _this;
  }
  jsplumb_core_es_createClass(LabelOverlay, [{
    key: "getLabel",
    value: function getLabel() {
      if (isFunction(this.label)) {
        return this.label(this);
      } else {
        return this.labelText;
      }
    }
  }, {
    key: "setLabel",
    value: function setLabel(l) {
      this.label = l;
      this.labelText = null;
      this.instance.updateLabel(this);
    }
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return {
        w: 1,
        h: 1
      };
    }
  }, {
    key: "updateFrom",
    value: function updateFrom(d) {
      if (d.label != null) {
        this.setLabel(d.label);
      }
    }
  }]);
  return LabelOverlay;
}(jsplumb_core_es_Overlay);
jsplumb_core_es_defineProperty(jsplumb_core_es_LabelOverlay, "type", "Label");
function isLabelOverlay(o) {
  return o.type === jsplumb_core_es_LabelOverlay.type;
}
OverlayFactory.register("Label", jsplumb_core_es_LabelOverlay);

function _splitType(t) {
  return t == null ? null : t.split(" ");
}
function _mapType(map, obj, typeId) {
  for (var i in obj) {
    map[i] = typeId;
  }
}
var CONNECTOR = "connector";
var MERGE_STRATEGY_OVERRIDE = "override";
var CSS_CLASS = "cssClass";
var DEFAULT_TYPE_KEY = "__default";
var ANCHOR = "anchor";
var ANCHORS = "anchors";
var _internalLabelOverlayId = "__label";
var TYPE_ITEM_OVERLAY = "overlay";
var LOCATION_ATTRIBUTE = "labelLocation";
var ACTION_ADD = "add";
var ACTION_REMOVE = "remove";
function _applyTypes(component, params) {
  if (component.getDefaultType) {
    var td = component.getTypeDescriptor(),
        map = {};
    var defType = component.getDefaultType();
    var o = extend({}, defType);
    _mapType(map, defType, DEFAULT_TYPE_KEY);
    for (var i = 0, j = component._types.length; i < j; i++) {
      var tid = component._types[i];
      if (tid !== DEFAULT_TYPE_KEY) {
        var _t = component.instance.getType(tid, td);
        if (_t != null) {
          var overrides = new Set([CONNECTOR, ANCHOR, ANCHORS]);
          if (_t.mergeStrategy === MERGE_STRATEGY_OVERRIDE) {
            for (var k in _t) {
              overrides.add(k);
            }
          }
          o = merge(o, _t, [CSS_CLASS], setToArray(overrides));
          _mapType(map, _t, tid);
        }
      }
    }
    if (params) {
      o = populate(o, params, "_");
    }
    component.applyType(o, map);
  }
}
function _removeTypeCssHelper(component, typeIndex) {
  var typeId = component._types[typeIndex],
      type = component.instance.getType(typeId, component.getTypeDescriptor());
  if (type != null && type.cssClass) {
    component.removeClass(type.cssClass);
  }
}
function _updateHoverStyle(component) {
  if (component.paintStyle && component.hoverPaintStyle) {
    var mergedHoverStyle = {};
    extend(mergedHoverStyle, component.paintStyle);
    extend(mergedHoverStyle, component.hoverPaintStyle);
    component.hoverPaintStyle = mergedHoverStyle;
  }
}
function _makeLabelOverlay(component, params) {
  var _params = {
    cssClass: params.cssClass,
    id: _internalLabelOverlayId,
    component: component
  },
      mergedParams = extend(_params, params);
  return new jsplumb_core_es_LabelOverlay(component.instance, component, mergedParams);
}
function _processOverlay(component, o) {
  var _newOverlay = null;
  if (isString(o)) {
    _newOverlay = OverlayFactory.get(component.instance, o, component, {});
  } else if (o.type != null && o.options != null) {
    var oa = o;
    var p = extend({}, oa.options);
    _newOverlay = OverlayFactory.get(component.instance, oa.type, component, p);
  } else {
    _newOverlay = o;
  }
  _newOverlay.id = _newOverlay.id || jsplumb_util_es_uuid();
  component.cacheTypeItem(TYPE_ITEM_OVERLAY, _newOverlay, _newOverlay.id);
  component.overlays[_newOverlay.id] = _newOverlay;
  return _newOverlay;
}
var jsplumb_core_es_Component = function (_EventGenerator) {
  jsplumb_core_es_inherits(Component, _EventGenerator);
  var _super = jsplumb_core_es_createSuper(Component);
  function Component(instance, params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, Component);
    _this = _super.call(this);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "defaultLabelLocation", 0.5);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "overlays", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "overlayPositions", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "overlayPlacements", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "clone", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "deleted", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "segment", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "x", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "y", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "w", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "h", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "id", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "visible", true);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "typeId", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "params", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "paintStyle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "hoverPaintStyle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "paintStyleInUse", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_hover", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "lastPaintedAt", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "data", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_defaultType", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "events", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "parameters", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_types", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_typeCache", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cssClass", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "hoverClass", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "beforeDetach", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "beforeDrop", void 0);
    params = params || {};
    _this.cssClass = params.cssClass || "";
    _this.hoverClass = params.hoverClass || instance.defaults.hoverClass;
    _this.beforeDetach = params.beforeDetach;
    _this.beforeDrop = params.beforeDrop;
    _this._types = [];
    _this._typeCache = {};
    _this.parameters = clone(params.parameters || {});
    _this.id = params.id || _this.getIdPrefix() + new Date().getTime();
    _this._defaultType = {
      parameters: _this.parameters,
      scope: params.scope || _this.instance.defaultScope,
      overlays: {}
    };
    if (params.events) {
      for (var evtName in params.events) {
        _this.bind(evtName, params.events[evtName]);
      }
    }
    _this.clone = function () {
      var o = Object.create(_this.constructor.prototype);
      _this.constructor.apply(o, [instance, params]);
      return o;
    };
    _this.overlays = {};
    _this.overlayPositions = {};
    var o = params.overlays || [],
        oo = {};
    var defaultOverlayKey = _this.getDefaultOverlayKey();
    if (defaultOverlayKey) {
      var defaultOverlays = _this.instance.defaults[defaultOverlayKey];
      if (defaultOverlays) {
        o.push.apply(o, _toConsumableArray(defaultOverlays));
      }
      for (var i = 0; i < o.length; i++) {
        var fo = convertToFullOverlaySpec(o[i]);
        oo[fo.options.id] = fo;
      }
    }
    _this._defaultType.overlays = oo;
    if (params.label) {
      _this.getDefaultType().overlays[_internalLabelOverlayId] = {
        type: jsplumb_core_es_LabelOverlay.type,
        options: {
          label: params.label,
          location: params.labelLocation || _this.defaultLabelLocation,
          id: _internalLabelOverlayId
        }
      };
    }
    return _this;
  }
  jsplumb_core_es_createClass(Component, [{
    key: "isDetachAllowed",
    value: function isDetachAllowed(connection) {
      var r = true;
      if (this.beforeDetach) {
        try {
          r = this.beforeDetach(connection);
        } catch (e) {
          log("jsPlumb: beforeDetach callback failed", e);
        }
      }
      return r;
    }
  }, {
    key: "isDropAllowed",
    value: function isDropAllowed(sourceId, targetId, scope, connection, dropEndpoint) {
      var r;
      var payload = {
        sourceId: sourceId,
        targetId: targetId,
        scope: scope,
        connection: connection,
        dropEndpoint: dropEndpoint
      };
      if (this.beforeDrop) {
        try {
          r = this.beforeDrop(payload);
        } catch (e) {
          log("jsPlumb: beforeDrop callback failed", e);
        }
      } else {
        r = this.instance.checkCondition(INTERCEPT_BEFORE_DROP, payload);
      }
      return r;
    }
  }, {
    key: "getDefaultType",
    value: function getDefaultType() {
      return this._defaultType;
    }
  }, {
    key: "appendToDefaultType",
    value: function appendToDefaultType(obj) {
      for (var i in obj) {
        this._defaultType[i] = obj[i];
      }
    }
  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }
  }, {
    key: "cacheTypeItem",
    value: function cacheTypeItem(key, item, typeId) {
      this._typeCache[typeId] = this._typeCache[typeId] || {};
      this._typeCache[typeId][key] = item;
    }
  }, {
    key: "getCachedTypeItem",
    value: function getCachedTypeItem(key, typeId) {
      return this._typeCache[typeId] ? this._typeCache[typeId][key] : null;
    }
  }, {
    key: "setType",
    value: function setType(typeId, params) {
      this.clearTypes();
      this._types = _splitType(typeId) || [];
      _applyTypes(this, params);
    }
  }, {
    key: "getType",
    value: function getType() {
      return this._types;
    }
  }, {
    key: "reapplyTypes",
    value: function reapplyTypes(params) {
      _applyTypes(this, params);
    }
  }, {
    key: "hasType",
    value: function hasType(typeId) {
      return this._types.indexOf(typeId) !== -1;
    }
  }, {
    key: "addType",
    value: function addType(typeId, params) {
      var t = _splitType(typeId),
          _somethingAdded = false;
      if (t != null) {
        for (var i = 0, j = t.length; i < j; i++) {
          if (!this.hasType(t[i])) {
            this._types.push(t[i]);
            _somethingAdded = true;
          }
        }
        if (_somethingAdded) {
          _applyTypes(this, params);
        }
      }
    }
  }, {
    key: "removeType",
    value: function removeType(typeId, params) {
      var _this2 = this;
      var t = _splitType(typeId),
          _cont = false,
          _one = function _one(tt) {
        var idx = _this2._types.indexOf(tt);
        if (idx !== -1) {
          _removeTypeCssHelper(_this2, idx);
          _this2._types.splice(idx, 1);
          return true;
        }
        return false;
      };
      if (t != null) {
        for (var i = 0, j = t.length; i < j; i++) {
          _cont = _one(t[i]) || _cont;
        }
        if (_cont) {
          _applyTypes(this, params);
        }
      }
    }
  }, {
    key: "clearTypes",
    value: function clearTypes(params, doNotRepaint) {
      var i = this._types.length;
      for (var j = 0; j < i; j++) {
        _removeTypeCssHelper(this, 0);
        this._types.splice(0, 1);
      }
      _applyTypes(this, params);
    }
  }, {
    key: "toggleType",
    value: function toggleType(typeId, params) {
      var t = _splitType(typeId);
      if (t != null) {
        for (var i = 0, j = t.length; i < j; i++) {
          var idx = this._types.indexOf(t[i]);
          if (idx !== -1) {
            _removeTypeCssHelper(this, idx);
            this._types.splice(idx, 1);
          } else {
            this._types.push(t[i]);
          }
        }
        _applyTypes(this, params);
      }
    }
  }, {
    key: "applyType",
    value: function applyType(t, params) {
      this.setPaintStyle(t.paintStyle);
      this.setHoverPaintStyle(t.hoverPaintStyle);
      this.mergeParameters(t.parameters);
      this.paintStyleInUse = this.getPaintStyle();
      if (t.overlays) {
        var keep = {},
            i;
        for (i in t.overlays) {
          var existing = this.overlays[t.overlays[i].options.id];
          if (existing) {
            existing.updateFrom(t.overlays[i].options);
            keep[t.overlays[i].options.id] = true;
            this.instance.reattachOverlay(existing, this);
          } else {
            var _c = this.getCachedTypeItem("overlay", t.overlays[i].options.id);
            if (_c != null) {
              this.instance.reattachOverlay(_c, this);
              _c.setVisible(true);
              _c.updateFrom(t.overlays[i].options);
              this.overlays[_c.id] = _c;
            } else {
              _c = this.addOverlay(t.overlays[i]);
            }
            keep[_c.id] = true;
          }
        }
        for (i in this.overlays) {
          if (keep[this.overlays[i].id] == null) {
            this.removeOverlay(this.overlays[i].id, true);
          }
        }
      }
    }
  }, {
    key: "setPaintStyle",
    value: function setPaintStyle(style) {
      this.paintStyle = style;
      this.paintStyleInUse = this.paintStyle;
      _updateHoverStyle(this);
    }
  }, {
    key: "getPaintStyle",
    value: function getPaintStyle() {
      return this.paintStyle;
    }
  }, {
    key: "setHoverPaintStyle",
    value: function setHoverPaintStyle(style) {
      this.hoverPaintStyle = style;
      _updateHoverStyle(this);
    }
  }, {
    key: "getHoverPaintStyle",
    value: function getHoverPaintStyle() {
      return this.hoverPaintStyle;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      for (var i in this.overlays) {
        this.instance.destroyOverlay(this.overlays[i]);
      }
      this.overlays = {};
      this.overlayPositions = {};
      this.unbind();
      this.clone = null;
    }
  }, {
    key: "isHover",
    value: function isHover() {
      return this._hover;
    }
  }, {
    key: "mergeParameters",
    value: function mergeParameters(p) {
      if (p != null) {
        extend(this.parameters, p);
      }
    }
  }, {
    key: "setVisible",
    value: function setVisible(v) {
      this.visible = v;
      if (v) {
        this.showOverlays();
      } else {
        this.hideOverlays();
      }
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      return this.visible;
    }
  }, {
    key: "setAbsoluteOverlayPosition",
    value: function setAbsoluteOverlayPosition(overlay, xy) {
      this.overlayPositions[overlay.id] = xy;
    }
  }, {
    key: "getAbsoluteOverlayPosition",
    value: function getAbsoluteOverlayPosition(overlay) {
      return this.overlayPositions ? this.overlayPositions[overlay.id] : null;
    }
  }, {
    key: "_clazzManip",
    value: function _clazzManip(action, clazz) {
      for (var i in this.overlays) {
        if (action === ACTION_ADD) {
          this.instance.addOverlayClass(this.overlays[i], clazz);
        } else if (action === ACTION_REMOVE) {
          this.instance.removeOverlayClass(this.overlays[i], clazz);
        }
      }
    }
  }, {
    key: "addClass",
    value: function addClass(clazz, cascade) {
      var parts = (this.cssClass || "").split(" ");
      parts.push(clazz);
      this.cssClass = parts.join(" ");
      this._clazzManip(ACTION_ADD, clazz);
    }
  }, {
    key: "removeClass",
    value: function removeClass(clazz, cascade) {
      var parts = (this.cssClass || "").split(" ");
      this.cssClass = parts.filter(function (p) {
        return p !== clazz;
      }).join(" ");
      this._clazzManip(ACTION_REMOVE, clazz);
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return this.cssClass;
    }
  }, {
    key: "shouldFireEvent",
    value: function shouldFireEvent(event, value, originalEvent) {
      return true;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.data;
    }
  }, {
    key: "setData",
    value: function setData(d) {
      this.data = d || {};
    }
  }, {
    key: "mergeData",
    value: function mergeData(d) {
      this.data = extend(this.data, d);
    }
  }, {
    key: "addOverlay",
    value: function addOverlay(overlay) {
      var o = _processOverlay(this, overlay);
      if (this.getData && o.type === jsplumb_core_es_LabelOverlay.type && !isString(overlay)) {
        var d = this.getData(),
            p = overlay.options;
        if (d) {
          var locationAttribute = p.labelLocationAttribute || LOCATION_ATTRIBUTE;
          var loc = d[locationAttribute];
          if (loc) {
            o.location = loc;
          }
        }
      }
      return o;
    }
  }, {
    key: "getOverlay",
    value: function getOverlay(id) {
      return this.overlays[id];
    }
  }, {
    key: "getOverlays",
    value: function getOverlays() {
      return this.overlays;
    }
  }, {
    key: "hideOverlay",
    value: function hideOverlay(id) {
      var o = this.getOverlay(id);
      if (o) {
        o.setVisible(false);
      }
    }
  }, {
    key: "hideOverlays",
    value: function hideOverlays() {
      for (var i in this.overlays) {
        this.overlays[i].setVisible(false);
      }
    }
  }, {
    key: "showOverlay",
    value: function showOverlay(id) {
      var o = this.getOverlay(id);
      if (o) {
        o.setVisible(true);
      }
    }
  }, {
    key: "showOverlays",
    value: function showOverlays() {
      for (var i in this.overlays) {
        this.overlays[i].setVisible(true);
      }
    }
  }, {
    key: "removeAllOverlays",
    value: function removeAllOverlays() {
      for (var i in this.overlays) {
        this.instance.destroyOverlay(this.overlays[i]);
      }
      this.overlays = {};
      this.overlayPositions = null;
      this.overlayPlacements = {};
    }
  }, {
    key: "removeOverlay",
    value: function removeOverlay(overlayId, dontCleanup) {
      var o = this.overlays[overlayId];
      if (o) {
        o.setVisible(false);
        if (!dontCleanup) {
          this.instance.destroyOverlay(o);
        }
        delete this.overlays[overlayId];
        if (this.overlayPositions) {
          delete this.overlayPositions[overlayId];
        }
        if (this.overlayPlacements) {
          delete this.overlayPlacements[overlayId];
        }
      }
    }
  }, {
    key: "removeOverlays",
    value: function removeOverlays() {
      for (var _len = arguments.length, overlays = new Array(_len), _key = 0; _key < _len; _key++) {
        overlays[_key] = arguments[_key];
      }
      for (var i = 0, j = overlays.length; i < j; i++) {
        this.removeOverlay(arguments[i]);
      }
    }
  }, {
    key: "getLabel",
    value: function getLabel() {
      var lo = this.getLabelOverlay();
      return lo != null ? lo.getLabel() : null;
    }
  }, {
    key: "getLabelOverlay",
    value: function getLabelOverlay() {
      return this.getOverlay(_internalLabelOverlayId);
    }
  }, {
    key: "setLabel",
    value: function setLabel(l) {
      var lo = this.getLabelOverlay();
      if (!lo) {
        var _params2 = isString(l) || isFunction(l) ? {
          label: l
        } : l;
        lo = _makeLabelOverlay(this, _params2);
        this.overlays[_internalLabelOverlayId] = lo;
      } else {
        if (isString(l) || isFunction(l)) {
          lo.setLabel(l);
        } else {
          var ll = l;
          if (ll.label) {
            lo.setLabel(ll.label);
          }
          if (ll.location) {
            lo.location = ll.location;
          }
        }
      }
    }
  }]);
  return Component;
}(EventGenerator);

var _opposites, _clockwiseOptions, _antiClockwiseOptions;
var FaceValues;
(function (FaceValues) {
  FaceValues["top"] = "top";
  FaceValues["left"] = "left";
  FaceValues["right"] = "right";
  FaceValues["bottom"] = "bottom";
})(FaceValues || (FaceValues = {}));
var TOP = FaceValues.top;
var LEFT = FaceValues.left;
var RIGHT = FaceValues.right;
var BOTTOM = FaceValues.bottom;
var X_AXIS_FACES = [LEFT, RIGHT];
var Y_AXIS_FACES = [TOP, BOTTOM];
var jsplumb_core_es_LightweightFloatingAnchor = function () {
  function LightweightFloatingAnchor(instance, element) {
    jsplumb_core_es_classCallCheck(this, LightweightFloatingAnchor);
    this.instance = instance;
    this.element = element;
    jsplumb_core_es_defineProperty(this, "isFloating", true);
    jsplumb_core_es_defineProperty(this, "isContinuous", void 0);
    jsplumb_core_es_defineProperty(this, "isDynamic", void 0);
    jsplumb_core_es_defineProperty(this, "locations", [{
      x: 0,
      y: 0,
      ox: 0,
      oy: 0,
      offx: 0,
      offy: 0,
      iox: 0,
      ioy: 0,
      cls: ''
    }]);
    jsplumb_core_es_defineProperty(this, "currentLocation", 0);
    jsplumb_core_es_defineProperty(this, "locked", false);
    jsplumb_core_es_defineProperty(this, "cssClass", '');
    jsplumb_core_es_defineProperty(this, "timestamp", null);
    jsplumb_core_es_defineProperty(this, "type", "Floating");
    jsplumb_core_es_defineProperty(this, "id", jsplumb_util_es_uuid());
    jsplumb_core_es_defineProperty(this, "orientation", [0, 0]);
    jsplumb_core_es_defineProperty(this, "size", void 0);
    this.size = instance.getSize(element);
  }
  jsplumb_core_es_createClass(LightweightFloatingAnchor, [{
    key: "over",
    value: function over(endpoint) {
      this.orientation = this.instance.router.getEndpointOrientation(endpoint);
      this.locations[0].ox = this.orientation[0];
      this.locations[0].oy = this.orientation[1];
    }
  }, {
    key: "out",
    value: function out() {
      this.orientation = null;
      this.locations[0].ox = this.locations[0].iox;
      this.locations[0].oy = this.locations[0].ioy;
    }
  }]);
  return LightweightFloatingAnchor;
}();
var opposites = (_opposites = {}, jsplumb_core_es_defineProperty(_opposites, TOP, BOTTOM), jsplumb_core_es_defineProperty(_opposites, RIGHT, LEFT), jsplumb_core_es_defineProperty(_opposites, LEFT, RIGHT), jsplumb_core_es_defineProperty(_opposites, BOTTOM, TOP), _opposites);
var clockwiseOptions = (_clockwiseOptions = {}, jsplumb_core_es_defineProperty(_clockwiseOptions, TOP, RIGHT), jsplumb_core_es_defineProperty(_clockwiseOptions, RIGHT, BOTTOM), jsplumb_core_es_defineProperty(_clockwiseOptions, LEFT, TOP), jsplumb_core_es_defineProperty(_clockwiseOptions, BOTTOM, LEFT), _clockwiseOptions);
var antiClockwiseOptions = (_antiClockwiseOptions = {}, jsplumb_core_es_defineProperty(_antiClockwiseOptions, TOP, LEFT), jsplumb_core_es_defineProperty(_antiClockwiseOptions, RIGHT, TOP), jsplumb_core_es_defineProperty(_antiClockwiseOptions, LEFT, BOTTOM), jsplumb_core_es_defineProperty(_antiClockwiseOptions, BOTTOM, RIGHT), _antiClockwiseOptions);
function getDefaultFace(a) {
  return a.faces.length === 0 ? TOP : a.faces[0];
}
function _isFaceAvailable(a, face) {
  return a.faces.indexOf(face) !== -1;
}
function _secondBest(a, edge) {
  return (a.clockwise ? clockwiseOptions : antiClockwiseOptions)[edge];
}
function _lastChoice(a, edge) {
  return (a.clockwise ? antiClockwiseOptions : clockwiseOptions)[edge];
}
function isEdgeSupported(a, edge) {
  return a.lockedAxis == null ? a.lockedFace == null ? _isFaceAvailable(a, edge) === true : a.lockedFace === edge : a.lockedAxis.indexOf(edge) !== -1;
}
function verifyFace(a, edge) {
  if (_isFaceAvailable(a, edge)) {
    return edge;
  } else if (_isFaceAvailable(a, opposites[edge])) {
    return opposites[edge];
  } else {
    var secondBest = _secondBest(a, edge);
    if (_isFaceAvailable(a, secondBest)) {
      return secondBest;
    } else {
      var lastChoice = _lastChoice(a, edge);
      if (_isFaceAvailable(a, lastChoice)) {
        return lastChoice;
      }
    }
  }
  return edge;
}
var _top = {
  x: 0.5,
  y: 0,
  ox: 0,
  oy: -1,
  offx: 0,
  offy: 0
},
    _bottom = {
  x: 0.5,
  y: 1,
  ox: 0,
  oy: 1,
  offx: 0,
  offy: 0
},
    _left = {
  x: 0,
  y: 0.5,
  ox: -1,
  oy: 0,
  offx: 0,
  offy: 0
},
    _right = {
  x: 1,
  y: 0.5,
  ox: 1,
  oy: 0,
  offx: 0,
  offy: 0
},
    _topLeft = {
  x: 0,
  y: 0,
  ox: 0,
  oy: -1,
  offx: 0,
  offy: 0
},
    _topRight = {
  x: 1,
  y: 0,
  ox: 1,
  oy: -1,
  offx: 0,
  offy: 0
},
    _bottomLeft = {
  x: 0,
  y: 1,
  ox: 0,
  oy: 1,
  offx: 0,
  offy: 0
},
    _bottomRight = {
  x: 1,
  y: 1,
  ox: 0,
  oy: 1,
  offx: 0,
  offy: 0
},
    _center = {
  x: 0.5,
  y: 0.5,
  ox: 0,
  oy: 0,
  offx: 0,
  offy: 0
};
var namedValues = {
  "Top": [_top],
  "Bottom": [_bottom],
  "Left": [_left],
  "Right": [_right],
  "TopLeft": [_topLeft],
  "TopRight": [_topRight],
  "BottomLeft": [_bottomLeft],
  "BottomRight": [_bottomRight],
  "Center": [_center],
  "AutoDefault": [_top, _left, _bottom, _right]
};
var namedContinuousValues = {
  "Continuous": {
    faces: [TOP, LEFT, BOTTOM, RIGHT]
  },
  "ContinuousTop": {
    faces: [TOP]
  },
  "ContinuousRight": {
    faces: [RIGHT]
  },
  "ContinuousBottom": {
    faces: [BOTTOM]
  },
  "ContinuousLeft": {
    faces: [LEFT]
  },
  "ContinuousLeftRight": {
    faces: [LEFT, RIGHT]
  },
  "ContinuousTopBottom": {
    faces: [TOP, BOTTOM]
  }
};
function getNamedAnchor(name, params) {
  params = params || {};
  if (name === AnchorLocations.Perimeter) {
    return _createPerimeterAnchor(params);
  }
  var a = namedValues[name];
  if (a != null) {
    return _createAnchor(name, jsplumb_util_es_map(a, function (_a) {
      return extend({
        iox: _a.ox,
        ioy: _a.oy
      }, _a);
    }), params);
  }
  a = namedContinuousValues[name];
  if (a != null) {
    return _createContinuousAnchor(name, a.faces, params);
  }
  throw {
    message: "jsPlumb: unknown anchor type '" + name + "'"
  };
}
function _createAnchor(type, locations, params) {
  return {
    type: type,
    locations: locations,
    currentLocation: 0,
    locked: false,
    id: jsplumb_util_es_uuid(),
    isFloating: false,
    isContinuous: false,
    isDynamic: locations.length > 1,
    timestamp: null,
    cssClass: params.cssClass || ""
  };
}
function createFloatingAnchor(instance, element) {
  return new jsplumb_core_es_LightweightFloatingAnchor(instance, element);
}
var PROPERTY_CURRENT_FACE = "currentFace";
function _createContinuousAnchor(type, faces, params) {
  var ca = {
    type: type,
    locations: [],
    currentLocation: 0,
    locked: false,
    id: jsplumb_util_es_uuid(),
    cssClass: params.cssClass || "",
    isFloating: false,
    isContinuous: true,
    timestamp: null,
    faces: params.faces || faces,
    lockedFace: null,
    lockedAxis: null,
    clockwise: !(params.clockwise === false),
    __currentFace: null
  };
  Object.defineProperty(ca, PROPERTY_CURRENT_FACE, {
    get: function get() {
      return this.__currentFace;
    },
    set: function set(f) {
      this.__currentFace = verifyFace(this, f);
    }
  });
  return ca;
}
function isPrimitiveAnchorSpec(sa) {
  return sa.length < 7 && sa.every(isNumber) || sa.length === 7 && sa.slice(0, 5).every(isNumber) && isString(sa[6]);
}
function makeLightweightAnchorFromSpec(spec) {
  if (isString(spec)) {
    return getNamedAnchor(spec, null);
  } else if (Array.isArray(spec)) {
    if (isPrimitiveAnchorSpec(spec)) {
      var _spec = spec;
      return _createAnchor(null, [{
        x: _spec[0],
        y: _spec[1],
        ox: _spec[2],
        oy: _spec[3],
        offx: _spec[4] == null ? 0 : _spec[4],
        offy: _spec[5] == null ? 0 : _spec[5],
        iox: _spec[2],
        ioy: _spec[3],
        cls: _spec[6] || ""
      }], {
        cssClass: _spec[6] || ""
      });
    } else {
      var locations = jsplumb_util_es_map(spec, function (aSpec) {
        if (isString(aSpec)) {
          var a = namedValues[aSpec];
          return a != null ? extend({
            iox: 0,
            ioy: 0,
            cls: ""
          }, a[0]) : null;
        } else if (isPrimitiveAnchorSpec(aSpec)) {
          return {
            x: aSpec[0],
            y: aSpec[1],
            ox: aSpec[2],
            oy: aSpec[3],
            offx: aSpec[4] == null ? 0 : aSpec[4],
            offy: aSpec[5] == null ? 0 : aSpec[5],
            iox: aSpec[2],
            ioy: aSpec[3],
            cls: aSpec[6] || ""
          };
        }
      }).filter(function (ar) {
        return ar != null;
      });
      return _createAnchor("Dynamic", locations, {});
    }
  } else {
    var sa = spec;
    return getNamedAnchor(sa.type, sa.options);
  }
}
function circleGenerator(anchorCount) {
  var r = 0.5,
      step = Math.PI * 2 / anchorCount,
      a = [];
  var current = 0;
  for (var i = 0; i < anchorCount; i++) {
    var x = r + r * Math.sin(current),
        y = r + r * Math.cos(current);
    a.push({
      x: x,
      y: y,
      ox: 0,
      oy: 0,
      offx: 0,
      offy: 0,
      iox: 0,
      ioy: 0,
      cls: ''
    });
    current += step;
  }
  return a;
}
function _path(segments, anchorCount) {
  var anchorsPerFace = anchorCount / segments.length,
      a = [],
      _computeFace = function _computeFace(x1, y1, x2, y2, fractionalLength, ox, oy) {
    anchorsPerFace = anchorCount * fractionalLength;
    var dx = (x2 - x1) / anchorsPerFace,
        dy = (y2 - y1) / anchorsPerFace;
    for (var i = 0; i < anchorsPerFace; i++) {
      a.push({
        x: x1 + dx * i,
        y: y1 + dy * i,
        ox: ox == null ? 0 : ox,
        oy: oy == null ? 0 : oy,
        offx: 0,
        offy: 0,
        iox: 0,
        ioy: 0,
        cls: ''
      });
    }
  };
  for (var i = 0; i < segments.length; i++) {
    _computeFace.apply(null, segments[i]);
  }
  return a;
}
function shapeGenerator(faces, anchorCount) {
  var s = [];
  for (var i = 0; i < faces.length; i++) {
    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length, faces[i][4], faces[i][5]]);
  }
  return _path(s, anchorCount);
}
function rectangleGenerator(anchorCount) {
  return shapeGenerator([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]], anchorCount);
}
function diamondGenerator(anchorCount) {
  return shapeGenerator([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]], anchorCount);
}
function triangleGenerator(anchorCount) {
  return shapeGenerator([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]], anchorCount);
}
function rotate$1(points, amountInDegrees) {
  var o = [],
      theta = amountInDegrees / 180 * Math.PI;
  for (var i = 0; i < points.length; i++) {
    var _x = points[i].x - 0.5,
        _y = points[i].y - 0.5;
    o.push({
      x: 0.5 + (_x * Math.cos(theta) - _y * Math.sin(theta)),
      y: 0.5 + (_x * Math.sin(theta) + _y * Math.cos(theta)),
      ox: points[i].ox,
      oy: points[i].oy,
      offx: 0,
      offy: 0,
      iox: 0,
      ioy: 0,
      cls: ''
    });
  }
  return o;
}
var anchorGenerators = new Map();
anchorGenerators.set(PerimeterAnchorShapes.Circle, circleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Ellipse, circleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Rectangle, rectangleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Square, rectangleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Diamond, diamondGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Triangle, triangleGenerator);
function _createPerimeterAnchor(params) {
  params = params || {};
  var anchorCount = params.anchorCount || 60,
      shape = params.shape;
  if (!shape) {
    throw new Error("no shape supplied to Perimeter Anchor type");
  }
  if (!anchorGenerators.has(shape)) {
    throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
  }
  var da = anchorGenerators.get(shape)(anchorCount);
  if (params.rotation) {
    da = rotate$1(da, params.rotation);
  }
  var a = _createAnchor(AnchorLocations.Perimeter, da, params);
  var aa = extend(a, {
    shape: shape
  });
  return aa;
}

var TYPE_ITEM_ANCHORS = "anchors";
var TYPE_ITEM_CONNECTOR = "connector";
function jsplumb_core_es_prepareEndpoint(conn, existing, index, anchor, element, elementId, endpoint) {
  var e;
  if (existing) {
    conn.endpoints[index] = existing;
    existing.addConnection(conn);
  } else {
    var ep = endpoint || conn.endpointSpec || conn.endpointsSpec[index] || conn.instance.defaults.endpoints[index] || conn.instance.defaults.endpoint;
    var es = conn.endpointStyles[index] || conn.endpointStyle || conn.instance.defaults.endpointStyles[index] || conn.instance.defaults.endpointStyle;
    if (es.fill == null && conn.paintStyle != null) {
      es.fill = conn.paintStyle.stroke;
    }
    if (es.outlineStroke == null && conn.paintStyle != null) {
      es.outlineStroke = conn.paintStyle.outlineStroke;
    }
    if (es.outlineWidth == null && conn.paintStyle != null) {
      es.outlineWidth = conn.paintStyle.outlineWidth;
    }
    var ehs = conn.endpointHoverStyles[index] || conn.endpointHoverStyle || conn.endpointHoverStyle || conn.instance.defaults.endpointHoverStyles[index] || conn.instance.defaults.endpointHoverStyle;
    if (conn.hoverPaintStyle != null) {
      if (ehs == null) {
        ehs = {};
      }
      if (ehs.fill == null) {
        ehs.fill = conn.hoverPaintStyle.stroke;
      }
    }
    var u = conn.uuids ? conn.uuids[index] : null;
    anchor = anchor != null ? anchor : conn.instance.defaults.anchors != null ? conn.instance.defaults.anchors[index] : conn.instance.defaults.anchor;
    e = conn.instance._internal_newEndpoint({
      paintStyle: es,
      hoverPaintStyle: ehs,
      endpoint: ep,
      connections: [conn],
      uuid: u,
      element: element,
      scope: conn.scope,
      anchor: anchor,
      reattachConnections: conn.reattach || conn.instance.defaults.reattachConnections,
      connectionsDetachable: conn.detachable || conn.instance.defaults.connectionsDetachable
    });
    if (existing == null) {
      e.deleteOnEmpty = true;
    }
    conn.endpoints[index] = e;
  }
  return e;
}
var jsplumb_core_es_Connection = function (_Component) {
  jsplumb_core_es_inherits(Connection, _Component);
  var _super = jsplumb_core_es_createSuper(Connection);
  function Connection(instance, params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, Connection);
    _this = _super.call(this, instance, params);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connector", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "defaultLabelLocation", 0.5);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "scope", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "typeId", "_jsplumb_connection");
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "previousConnection", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "sourceId", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "targetId", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "source", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "target", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "detachable", true);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "reattach", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "uuids", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cost", 1);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "directed", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpoints", [null, null]);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointStyles", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointSpec", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointsSpec", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointStyle", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointHoverStyle", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointHoverStyles", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "suspendedEndpoint", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "suspendedIndex", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "suspendedElement", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "suspendedElementId", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "suspendedElementType", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_forceReattach", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_forceDetach", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "proxies", []);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "pending", false);
    _this.id = params.id;
    _this.previousConnection = params.previousConnection;
    _this.source = params.source;
    _this.target = params.target;
    if (params.sourceEndpoint) {
      _this.source = params.sourceEndpoint.element;
      _this.sourceId = params.sourceEndpoint.elementId;
    } else {
      _this.sourceId = instance.getId(_this.source);
    }
    if (params.targetEndpoint) {
      _this.target = params.targetEndpoint.element;
      _this.targetId = params.targetEndpoint.elementId;
    } else {
      _this.targetId = instance.getId(_this.target);
    }
    _this.scope = params.scope;
    var sourceAnchor = params.anchors ? params.anchors[0] : params.anchor;
    var targetAnchor = params.anchors ? params.anchors[1] : params.anchor;
    instance.manage(_this.source);
    instance.manage(_this.target);
    _this.visible = true;
    _this.params = {
      cssClass: params.cssClass,
      hoverClass: params.hoverClass,
      "pointer-events": params["pointer-events"],
      overlays: params.overlays
    };
    _this.lastPaintedAt = null;
    if (params.type) {
      params.endpoints = params.endpoints || _this.instance._deriveEndpointAndAnchorSpec(params.type).endpoints;
    }
    _this.endpointSpec = params.endpoint;
    _this.endpointsSpec = params.endpoints || [null, null];
    _this.endpointStyle = params.endpointStyle;
    _this.endpointHoverStyle = params.endpointHoverStyle;
    _this.endpointStyles = params.endpointStyles || [null, null];
    _this.endpointHoverStyles = params.endpointHoverStyles || [null, null];
    _this.paintStyle = params.paintStyle;
    _this.hoverPaintStyle = params.hoverPaintStyle;
    _this.uuids = params.uuids;
    _this.makeEndpoint(true, _this.source, _this.sourceId, sourceAnchor, params.sourceEndpoint);
    _this.makeEndpoint(false, _this.target, _this.targetId, targetAnchor, params.targetEndpoint);
    if (!_this.scope) {
      _this.scope = _this.endpoints[0].scope;
    }
    if (params.deleteEndpointsOnEmpty != null) {
      _this.endpoints[0].deleteOnEmpty = params.deleteEndpointsOnEmpty;
      _this.endpoints[1].deleteOnEmpty = params.deleteEndpointsOnEmpty;
    }
    var _detachable = _this.instance.defaults.connectionsDetachable;
    if (params.detachable === false) {
      _detachable = false;
    }
    if (_this.endpoints[0].connectionsDetachable === false) {
      _detachable = false;
    }
    if (_this.endpoints[1].connectionsDetachable === false) {
      _detachable = false;
    }
    _this.endpointsSpec = params.endpoints || [null, null];
    _this.endpointSpec = params.endpoint || null;
    var _reattach = params.reattach || _this.endpoints[0].reattachConnections || _this.endpoints[1].reattachConnections || _this.instance.defaults.reattachConnections;
    _this.appendToDefaultType({
      detachable: _detachable,
      reattach: _reattach,
      paintStyle: _this.endpoints[0].connectorStyle || _this.endpoints[1].connectorStyle || params.paintStyle || _this.instance.defaults.paintStyle,
      hoverPaintStyle: _this.endpoints[0].connectorHoverStyle || _this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _this.instance.defaults.hoverPaintStyle
    });
    if (!_this.instance._suspendDrawing) {
      var initialTimestamp = _this.instance._suspendedAt || jsplumb_util_es_uuid();
      _this.instance.paintEndpoint(_this.endpoints[0], {
        timestamp: initialTimestamp
      });
      _this.instance.paintEndpoint(_this.endpoints[1], {
        timestamp: initialTimestamp
      });
    }
    _this.cost = params.cost || _this.endpoints[0].connectionCost;
    _this.directed = params.directed;
    if (params.directed == null) {
      _this.directed = _this.endpoints[0].connectionsDirected;
    }
    var _p = extend({}, _this.endpoints[1].parameters);
    extend(_p, _this.endpoints[0].parameters);
    extend(_p, _this.parameters);
    _this.parameters = _p;
    _this.paintStyleInUse = _this.getPaintStyle() || {};
    _this.setConnector(_this.endpoints[0].connector || _this.endpoints[1].connector || params.connector || _this.instance.defaults.connector, true);
    var data = params.data == null || !isObject(params.data) ? {} : params.data;
    _this.setData(data);
    var _types = [DEFAULT, _this.endpoints[0].edgeType, _this.endpoints[1].edgeType, params.type].join(" ");
    if (/[^\s]/.test(_types)) {
      _this.addType(_types, params.data);
    }
    return _this;
  }
  jsplumb_core_es_createClass(Connection, [{
    key: "getIdPrefix",
    value: function getIdPrefix() {
      return "_jsPlumb_c";
    }
  }, {
    key: "getDefaultOverlayKey",
    value: function getDefaultOverlayKey() {
      return KEY_CONNECTION_OVERLAYS;
    }
  }, {
    key: "getXY",
    value: function getXY() {
      return {
        x: this.connector.x,
        y: this.connector.y
      };
    }
  }, {
    key: "makeEndpoint",
    value: function makeEndpoint(isSource, el, elId, anchor, ep) {
      elId = elId || this.instance.getId(el);
      return jsplumb_core_es_prepareEndpoint(this, ep, isSource ? 0 : 1, anchor, el);
    }
  }, {
    key: "getTypeDescriptor",
    value: function getTypeDescriptor() {
      return Connection.type;
    }
  }, {
    key: "isDetachable",
    value: function isDetachable(ep) {
      return this.detachable === false ? false : ep != null ? ep.connectionsDetachable === true : this.detachable === true;
    }
  }, {
    key: "setDetachable",
    value: function setDetachable(detachable) {
      this.detachable = detachable === true;
    }
  }, {
    key: "isReattach",
    value: function isReattach() {
      return this.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
    }
  }, {
    key: "setReattach",
    value: function setReattach(reattach) {
      this.reattach = reattach === true;
    }
  }, {
    key: "applyType",
    value: function applyType(t, typeMap) {
      var _connector = null;
      if (t.connector != null) {
        _connector = this.getCachedTypeItem(TYPE_ITEM_CONNECTOR, typeMap.connector);
        if (_connector == null) {
          _connector = this.prepareConnector(t.connector, typeMap.connector);
          this.cacheTypeItem(TYPE_ITEM_CONNECTOR, _connector, typeMap.connector);
        }
        this.setPreparedConnector(_connector);
      }
      _get(jsplumb_core_es_getPrototypeOf(Connection.prototype), "applyType", this).call(this, t, typeMap);
      if (t.detachable != null) {
        this.setDetachable(t.detachable);
      }
      if (t.reattach != null) {
        this.setReattach(t.reattach);
      }
      if (t.scope) {
        this.scope = t.scope;
      }
      var _anchors = null;
      if (t.anchor) {
        _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchor);
        if (_anchors == null) {
          _anchors = [makeLightweightAnchorFromSpec(t.anchor), makeLightweightAnchorFromSpec(t.anchor)];
          this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchor);
        }
      } else if (t.anchors) {
        _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchors);
        if (_anchors == null) {
          _anchors = [makeLightweightAnchorFromSpec(t.anchors[0]), makeLightweightAnchorFromSpec(t.anchors[1])];
          this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchors);
        }
      }
      if (_anchors != null) {
        this.instance.router.setConnectionAnchors(this, _anchors);
        if (this.instance.router.isDynamicAnchor(this.endpoints[1])) {
          this.instance.repaint(this.endpoints[1].element);
        }
      }
      this.instance.applyConnectorType(this.connector, t);
    }
  }, {
    key: "addClass",
    value: function addClass(c, cascade) {
      _get(jsplumb_core_es_getPrototypeOf(Connection.prototype), "addClass", this).call(this, c);
      if (cascade) {
        this.endpoints[0].addClass(c);
        this.endpoints[1].addClass(c);
        if (this.suspendedEndpoint) {
          this.suspendedEndpoint.addClass(c);
        }
      }
      if (this.connector) {
        this.instance.addConnectorClass(this.connector, c);
      }
    }
  }, {
    key: "removeClass",
    value: function removeClass(c, cascade) {
      _get(jsplumb_core_es_getPrototypeOf(Connection.prototype), "removeClass", this).call(this, c);
      if (cascade) {
        this.endpoints[0].removeClass(c);
        this.endpoints[1].removeClass(c);
        if (this.suspendedEndpoint) {
          this.suspendedEndpoint.removeClass(c);
        }
      }
      if (this.connector) {
        this.instance.removeConnectorClass(this.connector, c);
      }
    }
  }, {
    key: "setVisible",
    value: function setVisible(v) {
      _get(jsplumb_core_es_getPrototypeOf(Connection.prototype), "setVisible", this).call(this, v);
      if (this.connector) {
        this.instance.setConnectorVisible(this.connector, v);
      }
      this.instance.paintConnection(this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get(jsplumb_core_es_getPrototypeOf(Connection.prototype), "destroy", this).call(this);
      this.endpoints = null;
      this.endpointStyles = null;
      this.source = null;
      this.target = null;
      this.instance.destroyConnector(this);
      this.connector = null;
      this.deleted = true;
    }
  }, {
    key: "getUuids",
    value: function getUuids() {
      return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];
    }
  }, {
    key: "prepareConnector",
    value: function prepareConnector(connectorSpec, typeId) {
      var connectorArgs = {
        cssClass: this.params.cssClass,
        hoverClass: this.params.hoverClass,
        "pointer-events": this.params["pointer-events"]
      },
          connector;
      if (isString(connectorSpec)) {
        connector = this.instance.makeConnector(this, connectorSpec, connectorArgs);
      } else {
        var co = connectorSpec;
        connector = this.instance.makeConnector(this, co.type, merge(co.options, connectorArgs));
      }
      if (typeId != null) {
        connector.typeId = typeId;
      }
      return connector;
    }
  }, {
    key: "setPreparedConnector",
    value: function setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {
      if (this.connector !== connector) {
        var previous,
            previousClasses = "";
        if (this.connector != null) {
          previous = this.connector;
          previousClasses = this.instance.getConnectorClass(this.connector);
          this.instance.destroyConnector(this);
        }
        this.connector = connector;
        if (typeId) {
          this.cacheTypeItem(TYPE_ITEM_CONNECTOR, connector, typeId);
        }
        this.addClass(previousClasses);
        if (previous != null) {
          var o = this.getOverlays();
          for (var i in o) {
            this.instance.reattachOverlay(o[i], this);
          }
        }
        if (!doNotRepaint) {
          this.instance.paintConnection(this);
        }
      }
    }
  }, {
    key: "setConnector",
    value: function setConnector(connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
      var connector = this.prepareConnector(connectorSpec, typeId);
      this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
    }
  }, {
    key: "replaceEndpoint",
    value: function replaceEndpoint(idx, endpointDef) {
      var current = this.endpoints[idx],
          elId = current.elementId,
          ebe = this.instance.getEndpoints(current.element),
          _idx = ebe.indexOf(current),
          _new = jsplumb_core_es_prepareEndpoint(this, null, idx, null, current.element, elId, endpointDef);
      this.endpoints[idx] = _new;
      ebe.splice(_idx, 1, _new);
      current.detachFromConnection(this);
      this.instance.deleteEndpoint(current);
      this.instance.fire(EVENT_ENDPOINT_REPLACED, {
        previous: current,
        current: _new
      });
    }
  }]);
  return Connection;
}(jsplumb_core_es_Component);
jsplumb_core_es_defineProperty(jsplumb_core_es_Connection, "type", "connection");

var typeParameters = ["connectorStyle", "connectorHoverStyle", "connectorOverlays", "connector", "connectionType", "connectorClass", "connectorHoverClass"];
var jsplumb_core_es_Endpoint = function (_Component) {
  jsplumb_core_es_inherits(Endpoint, _Component);
  var _super = jsplumb_core_es_createSuper(Endpoint);
  function Endpoint(instance, params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, Endpoint);
    _this = _super.call(this, instance, params);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connections", []);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpoint", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "element", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "elementId", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "dragAllowedWhenFull", true);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "timestamp", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "portId", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "maxConnections", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "proxiedBy", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorClass", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorHoverClass", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "finalEndpoint", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "enabled", true);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "isSource", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "isTarget", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "isTemporarySource", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectionCost", 1);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectionsDirected", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectionsDetachable", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "reattachConnections", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "currentAnchorClass", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "referenceEndpoint", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "edgeType", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connector", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorOverlays", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorStyle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorHoverStyle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "deleteOnEmpty", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "uuid", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "scope", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_anchor", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "defaultLabelLocation", [0.5, 0.5]);
    _this.appendToDefaultType({
      edgeType: params.edgeType,
      maxConnections: params.maxConnections == null ? _this.instance.defaults.maxConnections : params.maxConnections,
      paintStyle: params.paintStyle || _this.instance.defaults.endpointStyle,
      hoverPaintStyle: params.hoverPaintStyle || _this.instance.defaults.endpointHoverStyle,
      connectorStyle: params.connectorStyle,
      connectorHoverStyle: params.connectorHoverStyle,
      connectorClass: params.connectorClass,
      connectorHoverClass: params.connectorHoverClass,
      connectorOverlays: params.connectorOverlays,
      connector: params.connector
    });
    _this.enabled = !(params.enabled === false);
    _this.visible = true;
    _this.element = params.element;
    _this.uuid = params.uuid;
    _this.portId = params.portId;
    _this.elementId = params.elementId;
    _this.connectionCost = params.connectionCost == null ? 1 : params.connectionCost;
    _this.connectionsDirected = params.connectionsDirected;
    _this.currentAnchorClass = "";
    _this.events = {};
    _this.connectorOverlays = params.connectorOverlays;
    _this.connectorStyle = params.connectorStyle;
    _this.connectorHoverStyle = params.connectorHoverStyle;
    _this.connector = params.connector;
    _this.edgeType = params.edgeType;
    _this.connectorClass = params.connectorClass;
    _this.connectorHoverClass = params.connectorHoverClass;
    _this.deleteOnEmpty = params.deleteOnEmpty === true;
    _this.isSource = params.source || false;
    _this.isTemporarySource = params.isTemporarySource || false;
    _this.isTarget = params.target || false;
    _this.connections = params.connections || [];
    _this.scope = params.scope || instance.defaultScope;
    _this.timestamp = null;
    _this.reattachConnections = params.reattachConnections || instance.defaults.reattachConnections;
    _this.connectionsDetachable = instance.defaults.connectionsDetachable;
    if (params.connectionsDetachable === false) {
      _this.connectionsDetachable = false;
    }
    _this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;
    if (params.onMaxConnections) {
      _this.bind(EVENT_MAX_CONNECTIONS, params.onMaxConnections);
    }
    var ep = params.endpoint || params.existingEndpoint || instance.defaults.endpoint;
    _this.setEndpoint(ep);
    if (params.preparedAnchor != null) {
      _this.setPreparedAnchor(params.preparedAnchor);
    } else {
      var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : instance.defaults.anchor || AnchorLocations.Top;
      _this.setAnchor(anchorParamsToUse);
    }
    var type = [DEFAULT, params.type || ""].join(" ");
    _this.addType(type, params.data);
    return _this;
  }
  jsplumb_core_es_createClass(Endpoint, [{
    key: "getIdPrefix",
    value: function getIdPrefix() {
      return "_jsplumb_e";
    }
  }, {
    key: "getTypeDescriptor",
    value: function getTypeDescriptor() {
      return "endpoint";
    }
  }, {
    key: "getXY",
    value: function getXY() {
      return {
        x: this.endpoint.x,
        y: this.endpoint.y
      };
    }
  }, {
    key: "getDefaultOverlayKey",
    value: function getDefaultOverlayKey() {
      return "endpointOverlays";
    }
  }, {
    key: "_updateAnchorClass",
    value: function _updateAnchorClass() {
      var ac = this._anchor && this._anchor.cssClass;
      if (ac != null && ac.length > 0) {
        var oldAnchorClass = this.instance.endpointAnchorClassPrefix + "-" + this.currentAnchorClass;
        this.currentAnchorClass = ac;
        var anchorClass = this.instance.endpointAnchorClassPrefix + (this.currentAnchorClass ? "-" + this.currentAnchorClass : "");
        if (oldAnchorClass !== anchorClass) {
          this.removeClass(oldAnchorClass);
          this.addClass(anchorClass);
          this.instance.removeClass(this.element, oldAnchorClass);
          this.instance.addClass(this.element, anchorClass);
        }
      }
    }
  }, {
    key: "setPreparedAnchor",
    value: function setPreparedAnchor(anchor) {
      this.instance.router.setAnchor(this, anchor);
      this._updateAnchorClass();
      return this;
    }
  }, {
    key: "_anchorLocationChanged",
    value: function _anchorLocationChanged(currentAnchor) {
      this.fire(EVENT_ANCHOR_CHANGED, {
        endpoint: this,
        anchor: currentAnchor
      });
      this._updateAnchorClass();
    }
  }, {
    key: "setAnchor",
    value: function setAnchor(anchorParams) {
      var a = this.instance.router.prepareAnchor(this, anchorParams);
      this.setPreparedAnchor(a);
      return this;
    }
  }, {
    key: "addConnection",
    value: function addConnection(conn) {
      var wasFull = this.isFull();
      var wasEmpty = this.connections.length === 0;
      this.connections.push(conn);
      if (wasEmpty) {
        this.addClass(this.instance.endpointConnectedClass);
      }
      if (this.isFull()) {
        if (!wasFull) {
          this.addClass(this.instance.endpointFullClass);
        }
      } else if (wasFull) {
        this.removeClass(this.instance.endpointFullClass);
      }
    }
  }, {
    key: "detachFromConnection",
    value: function detachFromConnection(connection, idx, transientDetach) {
      idx = idx == null ? this.connections.indexOf(connection) : idx;
      if (idx >= 0) {
        this.connections.splice(idx, 1);
        this.instance.refreshEndpoint(this);
      }
      if (!transientDetach && this.deleteOnEmpty && this.connections.length === 0) {
        this.instance.deleteEndpoint(this);
      }
    }
  }, {
    key: "deleteEveryConnection",
    value: function deleteEveryConnection(params) {
      var c = this.connections.length;
      for (var i = 0; i < c; i++) {
        this.instance.deleteConnection(this.connections[0], params);
      }
    }
  }, {
    key: "detachFrom",
    value: function detachFrom(otherEndpoint) {
      var c = [];
      for (var i = 0; i < this.connections.length; i++) {
        if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
          c.push(this.connections[i]);
        }
      }
      for (var j = 0, count = c.length; j < count; j++) {
        this.instance.deleteConnection(c[0]);
      }
      return this;
    }
  }, {
    key: "setVisible",
    value: function setVisible(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
      _get(jsplumb_core_es_getPrototypeOf(Endpoint.prototype), "setVisible", this).call(this, v);
      this.endpoint.setVisible(v);
      if (v) {
        this.showOverlays();
      } else {
        this.hideOverlays();
      }
      if (!doNotChangeConnections) {
        for (var i = 0; i < this.connections.length; i++) {
          this.connections[i].setVisible(v);
          if (!doNotNotifyOtherEndpoint) {
            var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
            if (this.connections[i].endpoints[oIdx].connections.length === 1) {
              this.connections[i].endpoints[oIdx].setVisible(v, true, true);
            }
          }
        }
      }
    }
  }, {
    key: "applyType",
    value: function applyType(t, typeMap) {
      _get(jsplumb_core_es_getPrototypeOf(Endpoint.prototype), "applyType", this).call(this, t, typeMap);
      this.setPaintStyle(t.endpointStyle || t.paintStyle);
      this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle);
      this.connectorStyle = t.connectorStyle;
      this.connectorHoverStyle = t.connectorHoverStyle;
      this.connector = t.connector;
      this.connectorOverlays = t.connectorOverlays;
      this.edgeType = t.edgeType;
      if (t.maxConnections != null) {
        this.maxConnections = t.maxConnections;
      }
      if (t.scope) {
        this.scope = t.scope;
      }
      extend(t, typeParameters);
      this.instance.applyEndpointType(this, t);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get(jsplumb_core_es_getPrototypeOf(Endpoint.prototype), "destroy", this).call(this);
      if (this.endpoint != null) {
        this.instance.destroyEndpoint(this);
      }
    }
  }, {
    key: "isFull",
    value: function isFull() {
      return this.maxConnections === 0 ? true : !(this.isFloating() || this.maxConnections < 0 || this.connections.length < this.maxConnections);
    }
  }, {
    key: "isFloating",
    value: function isFloating() {
      return this.instance.router.isFloating(this);
    }
  }, {
    key: "isConnectedTo",
    value: function isConnectedTo(otherEndpoint) {
      var found = false;
      if (otherEndpoint) {
        for (var i = 0; i < this.connections.length; i++) {
          if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
            found = true;
            break;
          }
        }
      }
      return found;
    }
  }, {
    key: "setDragAllowedWhenFull",
    value: function setDragAllowedWhenFull(allowed) {
      this.dragAllowedWhenFull = allowed;
    }
  }, {
    key: "getUuid",
    value: function getUuid() {
      return this.uuid;
    }
  }, {
    key: "connectorSelector",
    value: function connectorSelector() {
      return this.connections[0];
    }
  }, {
    key: "prepareEndpoint",
    value: function prepareEndpoint(ep, typeId) {
      var endpointArgs = {
        cssClass: this.cssClass,
        endpoint: this
      };
      var endpoint;
      if (isAssignableFrom(ep, jsplumb_core_es_EndpointRepresentation)) {
        var epr = ep;
        endpoint = EndpointFactory.clone(epr);
      } else if (isString(ep)) {
        endpoint = EndpointFactory.get(this, ep, endpointArgs);
      } else {
        var fep = ep;
        extend(endpointArgs, fep.options || {});
        endpoint = EndpointFactory.get(this, fep.type, endpointArgs);
      }
      endpoint.typeId = typeId;
      return endpoint;
    }
  }, {
    key: "setEndpoint",
    value: function setEndpoint(ep) {
      var _ep = this.prepareEndpoint(ep);
      this.setPreparedEndpoint(_ep);
    }
  }, {
    key: "setPreparedEndpoint",
    value: function setPreparedEndpoint(ep) {
      if (this.endpoint != null) {
        this.instance.destroyEndpoint(this);
      }
      this.endpoint = ep;
    }
  }, {
    key: "addClass",
    value: function addClass(clazz, cascade) {
      _get(jsplumb_core_es_getPrototypeOf(Endpoint.prototype), "addClass", this).call(this, clazz, cascade);
      if (this.endpoint != null) {
        this.endpoint.addClass(clazz);
      }
    }
  }, {
    key: "removeClass",
    value: function removeClass(clazz, cascade) {
      _get(jsplumb_core_es_getPrototypeOf(Endpoint.prototype), "removeClass", this).call(this, clazz, cascade);
      if (this.endpoint != null) {
        this.endpoint.removeClass(clazz);
      }
    }
  }]);
  return Endpoint;
}(jsplumb_core_es_Component);

var UINode = function UINode(instance, el) {
  jsplumb_core_es_classCallCheck(this, UINode);
  this.instance = instance;
  this.el = el;
  jsplumb_core_es_defineProperty(this, "group", void 0);
};
var jsplumb_core_es_UIGroup = function (_UINode) {
  jsplumb_core_es_inherits(UIGroup, _UINode);
  var _super = jsplumb_core_es_createSuper(UIGroup);
  function UIGroup(instance, el, options) {
    var _this;
    jsplumb_core_es_classCallCheck(this, UIGroup);
    _this = _super.call(this, instance, el);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "children", []);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "collapsed", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "droppable", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "enabled", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "orphan", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "constrain", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "proxied", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "ghost", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "revert", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "prune", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "dropOverride", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "anchor", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpoint", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connections", {
      source: [],
      target: [],
      internal: []
    });
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "manager", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "id", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "elId", void 0);
    var jel = _this.el;
    jel._isJsPlumbGroup = true;
    jel._jsPlumbGroup = jsplumb_core_es_assertThisInitialized(_this);
    _this.elId = instance.getId(el);
    _this.orphan = options.orphan === true;
    _this.revert = _this.orphan === true ? false : options.revert !== false;
    _this.droppable = options.droppable !== false;
    _this.ghost = options.ghost === true;
    _this.enabled = options.enabled !== false;
    _this.prune = _this.orphan !== true && options.prune === true;
    _this.constrain = _this.ghost || options.constrain === true;
    _this.proxied = options.proxied !== false;
    _this.id = options.id || jsplumb_util_es_uuid();
    _this.dropOverride = options.dropOverride === true;
    _this.anchor = options.anchor;
    _this.endpoint = options.endpoint;
    _this.anchor = options.anchor;
    instance.setAttribute(el, ATTRIBUTE_GROUP, "");
    return _this;
  }
  jsplumb_core_es_createClass(UIGroup, [{
    key: "overrideDrop",
    value: function overrideDrop(el, targetGroup) {
      return this.dropOverride && (this.revert || this.prune || this.orphan);
    }
  }, {
    key: "getAnchor",
    value: function getAnchor(conn, endpointIndex) {
      return this.anchor || "Continuous";
    }
  }, {
    key: "getEndpoint",
    value: function getEndpoint(conn, endpointIndex) {
      return this.endpoint || {
        type: DotEndpoint.type,
        options: {
          radius: 10
        }
      };
    }
  }, {
    key: "add",
    value: function add(_el, doNotFireEvent) {
      var dragArea = this.instance.getGroupContentArea(this);
      var __el = _el;
      if (__el._jsPlumbParentGroup != null) {
        if (__el._jsPlumbParentGroup === this) {
          return;
        } else {
          __el._jsPlumbParentGroup.remove(_el, true, doNotFireEvent, false);
        }
      }
      __el._jsPlumbParentGroup = this;
      this.children.push(new UINode(this.instance, _el));
      this.instance._appendElement(__el, dragArea);
      this.manager._updateConnectionsForGroup(this);
    }
  }, {
    key: "resolveNode",
    value: function resolveNode(el) {
      return el == null ? null : getWithFunction(this.children, function (u) {
        return u.el === el;
      });
    }
  }, {
    key: "remove",
    value: function remove(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
      var uiNode = this.resolveNode(el);
      if (uiNode != null) {
        this._doRemove(uiNode, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup);
      }
    }
  }, {
    key: "_doRemove",
    value: function _doRemove(child, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
      var __el = child.el;
      delete __el._jsPlumbParentGroup;
      removeWithFunction(this.children, function (e) {
        return e === child;
      });
      if (manipulateDOM) {
        try {
          this.instance.getGroupContentArea(this).removeChild(__el);
        } catch (e) {
          log("Could not remove element from Group " + e);
        }
      }
      if (!doNotFireEvent) {
        var p = {
          group: this,
          el: __el
        };
        if (targetGroup) {
          p.targetGroup = targetGroup;
        }
        this.instance.fire(EVENT_GROUP_MEMBER_REMOVED, p);
      }
      if (!doNotUpdateConnections) {
        this.manager._updateConnectionsForGroup(this);
      }
    }
  }, {
    key: "removeAll",
    value: function removeAll(manipulateDOM, doNotFireEvent) {
      for (var i = 0, l = this.children.length; i < l; i++) {
        var child = this.children[0];
        this._doRemove(child, manipulateDOM, doNotFireEvent, true);
        this.instance.unmanage(child.el, true);
      }
      this.children.length = 0;
      this.manager._updateConnectionsForGroup(this);
    }
  }, {
    key: "orphanAll",
    value: function orphanAll() {
      var orphanedPositions = {};
      for (var i = 0; i < this.children.length; i++) {
        var newPosition = this.manager.orphan(this.children[i].el, false);
        orphanedPositions[newPosition.id] = newPosition.pos;
      }
      this.children.length = 0;
      return orphanedPositions;
    }
  }, {
    key: "addGroup",
    value: function addGroup(group) {
      if (this.instance.allowNestedGroups && group !== this) {
        if (this.instance.groupManager.isAncestor(this, group)) {
          return false;
        }
        if (group.group != null) {
          group.group.removeGroup(group);
        }
        var groupElId = this.instance.getId(group.el);
        var entry = this.instance.getManagedElements()[groupElId];
        entry.group = this.elId;
        var elpos = this.instance.getOffsetRelativeToRoot(group.el);
        var cpos = this.collapsed ? this.instance.getOffsetRelativeToRoot(this.el) : this.instance.getOffsetRelativeToRoot(this.instance.getGroupContentArea(this));
        group.el._jsPlumbParentGroup = this;
        this.children.push(group);
        this.instance._appendElement(group.el, this.instance.getGroupContentArea(this));
        group.group = this;
        var newPosition = {
          x: elpos.x - cpos.x,
          y: elpos.y - cpos.y
        };
        this.instance.setPosition(group.el, newPosition);
        this.instance.fire(EVENT_NESTED_GROUP_ADDED, {
          parent: this,
          child: group
        });
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "removeGroup",
    value: function removeGroup(group) {
      if (group.group === this) {
        var jel = group.el;
        var d = this.instance.getGroupContentArea(this);
        if (d === jel.parentNode) {
          d.removeChild(group.el);
        }
        var groupElId = this.instance.getId(group.el);
        var entry = this.instance.getManagedElements()[groupElId];
        if (entry) {
          delete entry.group;
        }
        this.children = this.children.filter(function (cg) {
          return cg.id !== group.id;
        });
        delete group.group;
        delete jel._jsPlumbParentGroup;
        this.instance.fire(EVENT_NESTED_GROUP_REMOVED, {
          parent: this,
          child: group
        });
      }
    }
  }, {
    key: "getGroups",
    value: function getGroups() {
      return this.children.filter(function (cg) {
        return cg.constructor === UIGroup;
      });
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.children.filter(function (cg) {
        return cg.constructor === UINode;
      });
    }
  }, {
    key: "collapseParent",
    get: function get() {
      var cg = null;
      if (this.group == null) {
        return null;
      } else {
        var g = this.group;
        while (g != null) {
          if (g.collapsed) {
            cg = g;
          }
          g = g.group;
        }
        return cg;
      }
    }
  }]);
  return UIGroup;
}(UINode);

var jsplumb_core_es_GroupManager = function () {
  function GroupManager(instance) {
    var _this = this;
    jsplumb_core_es_classCallCheck(this, GroupManager);
    this.instance = instance;
    jsplumb_core_es_defineProperty(this, "groupMap", {});
    jsplumb_core_es_defineProperty(this, "_connectionSourceMap", {});
    jsplumb_core_es_defineProperty(this, "_connectionTargetMap", {});
    instance.bind(EVENT_INTERNAL_CONNECTION, function (p) {
      var sourceGroup = _this.getGroupFor(p.source);
      var targetGroup = _this.getGroupFor(p.target);
      if (sourceGroup != null && targetGroup != null && sourceGroup === targetGroup) {
        _this._connectionSourceMap[p.connection.id] = sourceGroup;
        _this._connectionTargetMap[p.connection.id] = sourceGroup;
        suggest(sourceGroup.connections.internal, p.connection);
      } else {
        if (sourceGroup != null) {
          if (p.target._jsPlumbGroup === sourceGroup) {
            suggest(sourceGroup.connections.internal, p.connection);
          } else {
            suggest(sourceGroup.connections.source, p.connection);
          }
          _this._connectionSourceMap[p.connection.id] = sourceGroup;
        }
        if (targetGroup != null) {
          if (p.source._jsPlumbGroup === targetGroup) {
            suggest(targetGroup.connections.internal, p.connection);
          } else {
            suggest(targetGroup.connections.target, p.connection);
          }
          _this._connectionTargetMap[p.connection.id] = targetGroup;
        }
      }
    });
    instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
      _this._cleanupDetachedConnection(p.connection);
    });
    instance.bind(EVENT_CONNECTION_MOVED, function (p) {
      var originalElement = p.originalEndpoint.element,
          originalGroup = _this.getGroupFor(originalElement),
          newEndpoint = p.connection.endpoints[p.index],
          newElement = newEndpoint.element,
          newGroup = _this.getGroupFor(newElement),
          connMap = p.index === 0 ? _this._connectionSourceMap : _this._connectionTargetMap,
          otherConnMap = p.index === 0 ? _this._connectionTargetMap : _this._connectionSourceMap;
      if (newGroup != null) {
        connMap[p.connection.id] = newGroup;
        if (p.connection.source === p.connection.target) {
          otherConnMap[p.connection.id] = newGroup;
        }
      } else {
        delete connMap[p.connection.id];
        if (p.connection.source === p.connection.target) {
          delete otherConnMap[p.connection.id];
        }
      }
      if (originalGroup != null) {
        _this._updateConnectionsForGroup(originalGroup);
      }
      if (newGroup != null) {
        _this._updateConnectionsForGroup(newGroup);
      }
    });
  }
  jsplumb_core_es_createClass(GroupManager, [{
    key: "_cleanupDetachedConnection",
    value: function _cleanupDetachedConnection(conn) {
      conn.proxies.length = 0;
      var group = this._connectionSourceMap[conn.id],
          f;
      if (group != null) {
        f = function f(c) {
          return c.id === conn.id;
        };
        removeWithFunction(group.connections.source, f);
        removeWithFunction(group.connections.target, f);
        removeWithFunction(group.connections.internal, f);
        delete this._connectionSourceMap[conn.id];
      }
      group = this._connectionTargetMap[conn.id];
      if (group != null) {
        f = function f(c) {
          return c.id === conn.id;
        };
        removeWithFunction(group.connections.source, f);
        removeWithFunction(group.connections.target, f);
        removeWithFunction(group.connections.internal, f);
        delete this._connectionTargetMap[conn.id];
      }
    }
  }, {
    key: "addGroup",
    value: function addGroup(params) {
      var jel = params.el;
      if (this.groupMap[params.id] != null) {
        throw new Error("cannot create Group [" + params.id + "]; a Group with that ID exists");
      }
      if (jel._isJsPlumbGroup != null) {
        throw new Error("cannot create Group [" + params.id + "]; the given element is already a Group");
      }
      var group = new jsplumb_core_es_UIGroup(this.instance, params.el, params);
      this.groupMap[group.id] = group;
      if (params.collapsed) {
        this.collapseGroup(group);
      }
      this.instance.manage(group.el);
      this.instance.addClass(group.el, CLASS_GROUP_EXPANDED);
      group.manager = this;
      this._updateConnectionsForGroup(group);
      this.instance.fire(EVENT_GROUP_ADDED, {
        group: group
      });
      return group;
    }
  }, {
    key: "getGroup",
    value: function getGroup(groupId) {
      var group = groupId;
      if (isString(groupId)) {
        group = this.groupMap[groupId];
        if (group == null) {
          throw new Error("No such group [" + groupId + "]");
        }
      }
      return group;
    }
  }, {
    key: "getGroupFor",
    value: function getGroupFor(el) {
      var jel = el;
      var c = this.instance.getContainer();
      var abort = false,
          g = null;
      while (!abort) {
        if (jel == null || jel === c) {
          abort = true;
        } else {
          if (jel._jsPlumbParentGroup) {
            g = jel._jsPlumbParentGroup;
            abort = true;
          } else {
            jel = jel.parentNode;
          }
        }
      }
      return g;
    }
  }, {
    key: "getGroups",
    value: function getGroups() {
      var g = [];
      for (var key in this.groupMap) {
        g.push(this.groupMap[key]);
      }
      return g;
    }
  }, {
    key: "removeGroup",
    value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
      var _this2 = this;
      var actualGroup = this.getGroup(group);
      this.expandGroup(actualGroup, true);
      var newPositions = {};
      forEach(actualGroup.children, function (uiNode) {
        var entry = _this2.instance.getManagedElements()[_this2.instance.getId(uiNode.el)];
        if (entry) {
          delete entry.group;
        }
      });
      if (deleteMembers) {
        forEach(actualGroup.getGroups(), function (cg) {
          return _this2.removeGroup(cg, deleteMembers, manipulateView);
        });
        actualGroup.removeAll(manipulateView, doNotFireEvent);
      } else {
        if (actualGroup.group) {
          forEach(actualGroup.children, function (c) {
            return actualGroup.group.add(c.el);
          });
        }
        newPositions = actualGroup.orphanAll();
      }
      if (actualGroup.group) {
        actualGroup.group.removeGroup(actualGroup);
      }
      this.instance.unmanage(actualGroup.el, true);
      delete this.groupMap[actualGroup.id];
      this.instance.fire(EVENT_GROUP_REMOVED, {
        group: actualGroup
      });
      return newPositions;
    }
  }, {
    key: "removeAllGroups",
    value: function removeAllGroups(deleteMembers, manipulateView, doNotFireEvent) {
      for (var _g in this.groupMap) {
        this.removeGroup(this.groupMap[_g], deleteMembers, manipulateView, doNotFireEvent);
      }
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      for (var key in this.groupMap) {
        f(this.groupMap[key]);
      }
    }
  }, {
    key: "orphan",
    value: function orphan(el, doNotTransferToAncestor) {
      var jel = el;
      if (jel._jsPlumbParentGroup) {
        var currentParent = jel._jsPlumbParentGroup;
        var positionRelativeToGroup = this.instance.getOffset(jel);
        var id = this.instance.getId(jel);
        var pos = this.instance.getOffset(el);
        jel.parentNode.removeChild(jel);
        if (doNotTransferToAncestor !== true && currentParent.group) {
          pos.x += positionRelativeToGroup.x;
          pos.y += positionRelativeToGroup.y;
          this.instance.getGroupContentArea(currentParent.group).appendChild(el);
        } else {
          this.instance._appendElement(el, this.instance.getContainer());
        }
        this.instance.setPosition(el, pos);
        delete jel._jsPlumbParentGroup;
        return {
          id: id,
          pos: pos
        };
      }
    }
  }, {
    key: "_updateConnectionsForGroup",
    value: function _updateConnectionsForGroup(group) {
      var _this3 = this;
      group.connections.source.length = 0;
      group.connections.target.length = 0;
      group.connections.internal.length = 0;
      var members = group.children.slice().map(function (cn) {
        return cn.el;
      });
      var childMembers = [];
      forEach(members, function (member) {
        Array.prototype.push.apply(childMembers, _this3.instance.getSelector(member, SELECTOR_MANAGED_ELEMENT));
      });
      Array.prototype.push.apply(members, childMembers);
      if (members.length > 0) {
        var c1 = this.instance.getConnections({
          source: members,
          scope: WILDCARD
        }, true);
        var c2 = this.instance.getConnections({
          target: members,
          scope: WILDCARD
        }, true);
        var processed = {};
        var gs, gt;
        var oneSet = function oneSet(c) {
          for (var i = 0; i < c.length; i++) {
            if (processed[c[i].id]) {
              continue;
            }
            processed[c[i].id] = true;
            gs = _this3.getGroupFor(c[i].source);
            gt = _this3.getGroupFor(c[i].target);
            if (c[i].source === group.el && gt === group || c[i].target === group.el && gs === group) {
              group.connections.internal.push(c[i]);
            } else if (gs === group) {
              if (gt !== group) {
                group.connections.source.push(c[i]);
              } else {
                group.connections.internal.push(c[i]);
              }
              _this3._connectionSourceMap[c[i].id] = group;
            } else if (gt === group) {
              group.connections.target.push(c[i]);
              _this3._connectionTargetMap[c[i].id] = group;
            }
          }
        };
        oneSet(c1);
        oneSet(c2);
      }
    }
  }, {
    key: "_collapseConnection",
    value: function _collapseConnection(conn, index, group) {
      var otherEl = conn.endpoints[index === 0 ? 1 : 0].element;
      if (otherEl._jsPlumbParentGroup && !otherEl._jsPlumbParentGroup.proxied && otherEl._jsPlumbParentGroup.collapsed) {
        return false;
      }
      var es = conn.endpoints[0].element,
          esg = es._jsPlumbParentGroup,
          esgcp = esg != null ? esg.collapseParent || esg : null,
          et = conn.endpoints[1].element,
          etg = et._jsPlumbParentGroup,
          etgcp = etg != null ? etg.collapseParent || etg : null;
      if (esgcp == null || etgcp == null || esgcp.id !== etgcp.id) {
        var groupEl = group.el;
            this.instance.getId(groupEl);
        this.instance.proxyConnection(conn, index, groupEl,
        function (conn, index) {
          return group.getEndpoint(conn, index);
        }, function (conn, index) {
          return group.getAnchor(conn, index);
        });
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "_expandConnection",
    value: function _expandConnection(c, index, group) {
      this.instance.unproxyConnection(c, index);
    }
  }, {
    key: "isElementDescendant",
    value: function isElementDescendant(el, parentEl) {
      var c = this.instance.getContainer();
      var abort = false;
      while (!abort) {
        if (el == null || el === c) {
          return false;
        } else {
          if (el === parentEl) {
            return true;
          } else {
            el = el.parentNode;
          }
        }
      }
    }
  }, {
    key: "collapseGroup",
    value: function collapseGroup(group) {
      var _this4 = this;
      var actualGroup = this.getGroup(group);
      if (actualGroup == null || actualGroup.collapsed) {
        return;
      }
      var groupEl = actualGroup.el;
      if (actualGroup.collapseParent == null) {
        this.instance.setGroupVisible(actualGroup, false);
        actualGroup.collapsed = true;
        this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
        this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
        if (actualGroup.proxied) {
          var collapsedConnectionIds = new Set();
          var _collapseSet = function _collapseSet(conns, index) {
            for (var i = 0; i < conns.length; i++) {
              var c = conns[i];
              if (_this4._collapseConnection(c, index, actualGroup) === true) {
                collapsedConnectionIds.add(c.id);
              }
            }
          };
          _collapseSet(actualGroup.connections.source, 0);
          _collapseSet(actualGroup.connections.target, 1);
          forEach(actualGroup.getGroups(), function (cg) {
            _this4.cascadeCollapse(actualGroup, cg, collapsedConnectionIds);
          });
        }
        this.instance.revalidate(groupEl);
        this.repaintGroup(actualGroup);
        this.instance.fire(EVENT_GROUP_COLLAPSE, {
          group: actualGroup
        });
      } else {
        actualGroup.collapsed = true;
        this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
        this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
      }
    }
  }, {
    key: "cascadeCollapse",
    value: function cascadeCollapse(collapsedGroup, targetGroup, collapsedIds) {
      var _this5 = this;
      if (collapsedGroup.proxied) {
        var _collapseSet = function _collapseSet(conns, index) {
          for (var i = 0; i < conns.length; i++) {
            var c = conns[i];
            if (!collapsedIds.has(c.id)) {
              if (_this5._collapseConnection(c, index, collapsedGroup) === true) {
                collapsedIds.add(c.id);
              }
            }
          }
        };
        _collapseSet(targetGroup.connections.source, 0);
        _collapseSet(targetGroup.connections.target, 1);
      }
      forEach(targetGroup.getGroups(), function (cg) {
        _this5.cascadeCollapse(collapsedGroup, cg, collapsedIds);
      });
    }
  }, {
    key: "expandGroup",
    value: function expandGroup(group, doNotFireEvent) {
      var _this6 = this;
      var actualGroup = this.getGroup(group);
      if (actualGroup == null) {
        return;
      }
      var groupEl = actualGroup.el;
      if (actualGroup.collapseParent == null) {
        this.instance.setGroupVisible(actualGroup, true);
        actualGroup.collapsed = false;
        this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
        this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
        if (actualGroup.proxied) {
          var _expandSet = function _expandSet(conns, index) {
            for (var i = 0; i < conns.length; i++) {
              var c = conns[i];
              _this6._expandConnection(c, index, actualGroup);
            }
          };
          _expandSet(actualGroup.connections.source, 0);
          _expandSet(actualGroup.connections.target, 1);
          var _expandNestedGroup = function _expandNestedGroup(group, ignoreCollapsedStateForNested) {
            if (ignoreCollapsedStateForNested || group.collapsed) {
              var _collapseSet = function _collapseSet(conns, index) {
                for (var i = 0; i < conns.length; i++) {
                  var c = conns[i];
                  _this6._collapseConnection(c, index, group.collapseParent || group);
                }
              };
              _collapseSet(group.connections.source, 0);
              _collapseSet(group.connections.target, 1);
              forEach(group.connections.internal, function (c) {
                return c.setVisible(false);
              });
              forEach(group.getGroups(), function (g) {
                return _expandNestedGroup(g, true);
              });
            } else {
              _this6.expandGroup(group, true);
            }
          };
          forEach(actualGroup.getGroups(), _expandNestedGroup);
        }
        this.instance.revalidate(groupEl);
        this.repaintGroup(actualGroup);
        if (!doNotFireEvent) {
          this.instance.fire(EVENT_GROUP_EXPAND, {
            group: actualGroup
          });
        }
      } else {
        actualGroup.collapsed = false;
        this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
        this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
      }
    }
  }, {
    key: "toggleGroup",
    value: function toggleGroup(group) {
      group = this.getGroup(group);
      if (group != null) {
        if (group.collapsed) {
          this.expandGroup(group);
        } else {
          this.collapseGroup(group);
        }
      }
    }
  }, {
    key: "repaintGroup",
    value: function repaintGroup(group) {
      var actualGroup = this.getGroup(group);
      var m = actualGroup.children;
      for (var i = 0; i < m.length; i++) {
        this.instance.revalidate(m[i].el);
      }
    }
  }, {
    key: "addToGroup",
    value: function addToGroup(group, doNotFireEvent) {
      var _this7 = this;
      var actualGroup = this.getGroup(group);
      if (actualGroup) {
        var groupEl = actualGroup.el;
        var _one = function _one(el) {
          var jel = el;
          var isGroup = jel._isJsPlumbGroup != null,
              droppingGroup = jel._jsPlumbGroup;
          var currentGroup = jel._jsPlumbParentGroup;
          if (currentGroup !== actualGroup) {
            var entry = _this7.instance.manage(el);
            var elpos = _this7.instance.getOffset(el);
            var cpos = actualGroup.collapsed ? _this7.instance.getOffsetRelativeToRoot(groupEl) : _this7.instance.getOffset(_this7.instance.getGroupContentArea(actualGroup));
            entry.group = actualGroup.elId;
            if (currentGroup != null) {
              currentGroup.remove(el, false, doNotFireEvent, false, actualGroup);
              _this7._updateConnectionsForGroup(currentGroup);
            }
            if (isGroup) {
              actualGroup.addGroup(droppingGroup);
            } else {
              actualGroup.add(el, doNotFireEvent);
            }
            var handleDroppedConnections = function handleDroppedConnections(list, index) {
              var oidx = index === 0 ? 1 : 0;
              list.each(function (c) {
                c.setVisible(false);
                if (c.endpoints[oidx].element._jsPlumbGroup === actualGroup) {
                  c.endpoints[oidx].setVisible(false);
                  _this7._expandConnection(c, oidx, actualGroup);
                } else {
                  c.endpoints[index].setVisible(false);
                  _this7._collapseConnection(c, index, actualGroup);
                }
              });
            };
            if (actualGroup.collapsed) {
              handleDroppedConnections(_this7.instance.select({
                source: el
              }), 0);
              handleDroppedConnections(_this7.instance.select({
                target: el
              }), 1);
            }
            _this7.instance.getId(el);
            var newPosition = {
              x: elpos.x - cpos.x,
              y: elpos.y - cpos.y
            };
            _this7.instance.setPosition(el, newPosition);
            _this7._updateConnectionsForGroup(actualGroup);
            _this7.instance.revalidate(el);
            if (!doNotFireEvent) {
              var p = {
                group: actualGroup,
                el: el,
                pos: newPosition
              };
              if (currentGroup) {
                p.sourceGroup = currentGroup;
              }
              _this7.instance.fire(EVENT_GROUP_MEMBER_ADDED, p);
            }
          }
        };
        for (var _len = arguments.length, el = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          el[_key - 2] = arguments[_key];
        }
        forEach(el, _one);
      }
    }
  }, {
    key: "removeFromGroup",
    value: function removeFromGroup(group, doNotFireEvent) {
      var _this8 = this;
      var actualGroup = this.getGroup(group);
      if (actualGroup) {
        var _one = function _one(_el) {
          if (actualGroup.collapsed) {
            var _expandSet = function _expandSet(conns, index) {
              for (var i = 0; i < conns.length; i++) {
                var c = conns[i];
                if (c.proxies) {
                  for (var j = 0; j < c.proxies.length; j++) {
                    if (c.proxies[j] != null) {
                      var proxiedElement = c.proxies[j].originalEp.element;
                      if (proxiedElement === _el || _this8.isElementDescendant(proxiedElement, _el)) {
                        _this8._expandConnection(c, index, actualGroup);
                      }
                    }
                  }
                }
              }
            };
            _expandSet(actualGroup.connections.source.slice(), 0);
            _expandSet(actualGroup.connections.target.slice(), 1);
          }
          actualGroup.remove(_el, null, doNotFireEvent);
          var entry = _this8.instance.getManagedElements()[_this8.instance.getId(_el)];
          if (entry) {
            delete entry.group;
          }
        };
        for (var _len2 = arguments.length, el = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          el[_key2 - 2] = arguments[_key2];
        }
        forEach(el, _one);
      }
    }
  }, {
    key: "getAncestors",
    value: function getAncestors(group) {
      var ancestors = [];
      var p = group.group;
      while (p != null) {
        ancestors.push(p);
        p = p.group;
      }
      return ancestors;
    }
  }, {
    key: "isAncestor",
    value: function isAncestor(group, possibleAncestor) {
      if (group == null || possibleAncestor == null) {
        return false;
      }
      return this.getAncestors(group).indexOf(possibleAncestor) !== -1;
    }
  }, {
    key: "getDescendants",
    value: function getDescendants(group) {
      var d = [];
      var _one = function _one(g) {
        var childGroups = g.getGroups();
        d.push.apply(d, _toConsumableArray(childGroups));
        forEach(childGroups, _one);
      };
      _one(group);
      return d;
    }
  }, {
    key: "isDescendant",
    value: function isDescendant(possibleDescendant, ancestor) {
      if (possibleDescendant == null || ancestor == null) {
        return false;
      }
      return this.getDescendants(ancestor).indexOf(possibleDescendant) !== -1;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._connectionSourceMap = {};
      this._connectionTargetMap = {};
      this.groupMap = {};
    }
  }]);
  return GroupManager;
}();

var jsplumb_core_es_SelectionBase = function () {
  function SelectionBase(instance, entries) {
    jsplumb_core_es_classCallCheck(this, SelectionBase);
    this.instance = instance;
    this.entries = entries;
  }
  jsplumb_core_es_createClass(SelectionBase, [{
    key: "length",
    get: function get() {
      return this.entries.length;
    }
  }, {
    key: "each",
    value: function each(handler) {
      forEach(this.entries, function (e) {
        return handler(e);
      });
      return this;
    }
  }, {
    key: "get",
    value: function get(index) {
      return this.entries[index];
    }
  }, {
    key: "addClass",
    value: function addClass(clazz, cascade) {
      this.each(function (c) {
        return c.addClass(clazz, cascade);
      });
      return this;
    }
  }, {
    key: "removeClass",
    value: function removeClass(clazz, cascade) {
      this.each(function (c) {
        return c.removeClass(clazz, cascade);
      });
      return this;
    }
  }, {
    key: "removeAllOverlays",
    value: function removeAllOverlays() {
      this.each(function (c) {
        return c.removeAllOverlays();
      });
      return this;
    }
  }, {
    key: "setLabel",
    value: function setLabel(label) {
      this.each(function (c) {
        return c.setLabel(label);
      });
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.entries.length = 0;
      return this;
    }
  }, {
    key: "map",
    value: function map(fn) {
      var a = [];
      this.each(function (e) {
        return a.push(fn(e));
      });
      return a;
    }
  }, {
    key: "addOverlay",
    value: function addOverlay(spec) {
      this.each(function (c) {
        return c.addOverlay(spec);
      });
      return this;
    }
  }, {
    key: "removeOverlay",
    value: function removeOverlay(id) {
      this.each(function (c) {
        return c.removeOverlay(id);
      });
      return this;
    }
  }, {
    key: "removeOverlays",
    value: function removeOverlays() {
      this.each(function (c) {
        return c.removeOverlays();
      });
      return this;
    }
  }, {
    key: "showOverlay",
    value: function showOverlay(id) {
      this.each(function (c) {
        return c.showOverlay(id);
      });
      return this;
    }
  }, {
    key: "hideOverlay",
    value: function hideOverlay(id) {
      this.each(function (c) {
        return c.hideOverlay(id);
      });
      return this;
    }
  }, {
    key: "setPaintStyle",
    value: function setPaintStyle(style) {
      this.each(function (c) {
        return c.setPaintStyle(style);
      });
      return this;
    }
  }, {
    key: "setHoverPaintStyle",
    value: function setHoverPaintStyle(style) {
      this.each(function (c) {
        return c.setHoverPaintStyle(style);
      });
      return this;
    }
  }, {
    key: "setSuspendEvents",
    value: function setSuspendEvents(suspend) {
      this.each(function (c) {
        return c.setSuspendEvents(suspend);
      });
      return this;
    }
  }, {
    key: "setParameter",
    value: function setParameter(name, value) {
      this.each(function (c) {
        return c.parameters[name] = value;
      });
      return this;
    }
  }, {
    key: "setParameters",
    value: function setParameters(p) {
      this.each(function (c) {
        return c.parameters = p;
      });
      return this;
    }
  }, {
    key: "setVisible",
    value: function setVisible(v) {
      this.each(function (c) {
        return c.setVisible(v);
      });
      return this;
    }
  }, {
    key: "addType",
    value: function addType(name) {
      this.each(function (c) {
        return c.addType(name);
      });
      return this;
    }
  }, {
    key: "toggleType",
    value: function toggleType(name) {
      this.each(function (c) {
        return c.toggleType(name);
      });
      return this;
    }
  }, {
    key: "removeType",
    value: function removeType(name) {
      this.each(function (c) {
        return c.removeType(name);
      });
      return this;
    }
  }, {
    key: "bind",
    value: function bind(evt, handler) {
      this.each(function (c) {
        return c.bind(evt, handler);
      });
      return this;
    }
  }, {
    key: "unbind",
    value: function unbind(evt, handler) {
      this.each(function (c) {
        return c.unbind(evt, handler);
      });
      return this;
    }
  }, {
    key: "setHover",
    value: function setHover(h) {
      var _this = this;
      this.each(function (c) {
        return _this.instance.setHover(c, h);
      });
      return this;
    }
  }]);
  return SelectionBase;
}();

var EndpointSelection = function (_SelectionBase) {
  jsplumb_core_es_inherits(EndpointSelection, _SelectionBase);
  var _super = jsplumb_core_es_createSuper(EndpointSelection);
  function EndpointSelection() {
    jsplumb_core_es_classCallCheck(this, EndpointSelection);
    return _super.apply(this, arguments);
  }
  jsplumb_core_es_createClass(EndpointSelection, [{
    key: "setEnabled",
    value: function setEnabled(e) {
      this.each(function (ep) {
        return ep.enabled = e;
      });
      return this;
    }
  }, {
    key: "setAnchor",
    value: function setAnchor(a) {
      this.each(function (ep) {
        return ep.setAnchor(a);
      });
      return this;
    }
  }, {
    key: "deleteEveryConnection",
    value: function deleteEveryConnection() {
      this.each(function (ep) {
        return ep.deleteEveryConnection();
      });
      return this;
    }
  }, {
    key: "deleteAll",
    value: function deleteAll() {
      var _this = this;
      this.each(function (ep) {
        return _this.instance.deleteEndpoint(ep);
      });
      this.clear();
      return this;
    }
  }]);
  return EndpointSelection;
}(jsplumb_core_es_SelectionBase);

var ConnectionSelection = function (_SelectionBase) {
  jsplumb_core_es_inherits(ConnectionSelection, _SelectionBase);
  var _super = jsplumb_core_es_createSuper(ConnectionSelection);
  function ConnectionSelection() {
    jsplumb_core_es_classCallCheck(this, ConnectionSelection);
    return _super.apply(this, arguments);
  }
  jsplumb_core_es_createClass(ConnectionSelection, [{
    key: "setDetachable",
    value: function setDetachable(d) {
      this.each(function (c) {
        return c.setDetachable(d);
      });
      return this;
    }
  }, {
    key: "setReattach",
    value: function setReattach(d) {
      this.each(function (c) {
        return c.setReattach(d);
      });
      return this;
    }
  }, {
    key: "setConnector",
    value: function setConnector(spec) {
      this.each(function (c) {
        return c.setConnector(spec);
      });
      return this;
    }
  }, {
    key: "deleteAll",
    value: function deleteAll() {
      var _this = this;
      this.each(function (c) {
        return _this.instance.deleteConnection(c);
      });
      this.clear();
    }
  }, {
    key: "repaint",
    value: function repaint() {
      var _this2 = this;
      this.each(function (c) {
        return _this2.instance.paintConnection(c);
      });
      return this;
    }
  }]);
  return ConnectionSelection;
}(jsplumb_core_es_SelectionBase);

var Transaction = function Transaction() {
  jsplumb_core_es_classCallCheck(this, Transaction);
  jsplumb_core_es_defineProperty(this, "affectedElements", new Set());
};
function EMPTY_POSITION() {
  return {
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    r: 0,
    c: {
      x: 0,
      y: 0
    },
    x2: 0,
    y2: 0,
    t: {
      x: 0,
      y: 0,
      c: {
        x: 0,
        y: 0
      },
      w: 0,
      h: 0,
      r: 0,
      x2: 0,
      y2: 0,
      cr: 0,
      sr: 0
    },
    dirty: true
  };
}
function rotate(x, y, w, h, r) {
  var center = {
    x: x + w / 2,
    y: y + h / 2
  },
      cr = Math.cos(r / 360 * Math.PI * 2),
      sr = Math.sin(r / 360 * Math.PI * 2),
      _point = function _point(x, y) {
    return {
      x: center.x + Math.round((x - center.x) * cr - (y - center.y) * sr),
      y: center.y + Math.round((y - center.y) * cr - (x - center.x) * sr)
    };
  };
  var p1 = _point(x, y),
      p2 = _point(x + w, y),
      p3 = _point(x + w, y + h),
      p4 = _point(x, y + h),
      c = _point(x + w / 2, y + h / 2);
  var xmin = Math.min(p1.x, p2.x, p3.x, p4.x),
      xmax = Math.max(p1.x, p2.x, p3.x, p4.x),
      ymin = Math.min(p1.y, p2.y, p3.y, p4.y),
      ymax = Math.max(p1.y, p2.y, p3.y, p4.y);
  return {
    x: xmin,
    y: ymin,
    w: xmax - xmin,
    h: ymax - ymin,
    c: c,
    r: r,
    x2: xmax,
    y2: ymax,
    cr: cr,
    sr: sr
  };
}
var entryComparator = function entryComparator(value, arrayEntry) {
  var c = 0;
  if (arrayEntry[1] > value[1]) {
    c = -1;
  } else if (arrayEntry[1] < value[1]) {
    c = 1;
  }
  return c;
};
var reverseEntryComparator = function reverseEntryComparator(value, arrayEntry) {
  return entryComparator(value, arrayEntry) * -1;
};
function _updateElementIndex(id, value, array, sortDescending) {
  insertSorted([id, value], array, entryComparator, sortDescending);
}
function _clearElementIndex(id, array) {
  var idx = findWithFunction(array, function (entry) {
    return entry[0] === id;
  });
  if (idx > -1) {
    array.splice(idx, 1);
  }
}
var jsplumb_core_es_Viewport = function (_EventGenerator) {
  jsplumb_core_es_inherits(Viewport, _EventGenerator);
  var _super = jsplumb_core_es_createSuper(Viewport);
  function Viewport(instance) {
    var _this;
    jsplumb_core_es_classCallCheck(this, Viewport);
    _this = _super.call(this);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_currentTransaction", null);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_sortedElements", {
      xmin: [],
      xmax: [],
      ymin: [],
      ymax: []
    });
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_elementMap", new Map());
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_transformedElementMap", new Map());
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_bounds", {
      minx: 0,
      maxx: 0,
      miny: 0,
      maxy: 0
    });
    return _this;
  }
  jsplumb_core_es_createClass(Viewport, [{
    key: "_updateBounds",
    value: function _updateBounds(id, updatedElement, doNotRecalculateBounds) {
      if (updatedElement != null) {
        _clearElementIndex(id, this._sortedElements.xmin);
        _clearElementIndex(id, this._sortedElements.xmax);
        _clearElementIndex(id, this._sortedElements.ymin);
        _clearElementIndex(id, this._sortedElements.ymax);
        _updateElementIndex(id, updatedElement.t.x, this._sortedElements.xmin, false);
        _updateElementIndex(id, updatedElement.t.x + updatedElement.t.w, this._sortedElements.xmax, true);
        _updateElementIndex(id, updatedElement.t.y, this._sortedElements.ymin, false);
        _updateElementIndex(id, updatedElement.t.y + updatedElement.t.h, this._sortedElements.ymax, true);
        if (doNotRecalculateBounds !== true) {
          this._recalculateBounds();
        }
      }
    }
  }, {
    key: "_recalculateBounds",
    value: function _recalculateBounds() {
      this._bounds.minx = this._sortedElements.xmin.length > 0 ? this._sortedElements.xmin[0][1] : 0;
      this._bounds.maxx = this._sortedElements.xmax.length > 0 ? this._sortedElements.xmax[0][1] : 0;
      this._bounds.miny = this._sortedElements.ymin.length > 0 ? this._sortedElements.ymin[0][1] : 0;
      this._bounds.maxy = this._sortedElements.ymax.length > 0 ? this._sortedElements.ymax[0][1] : 0;
    }
  }, {
    key: "recomputeBounds",
    value: function recomputeBounds() {
      var _this2 = this;
      this._sortedElements.xmin.length = 0;
      this._sortedElements.xmax.length = 0;
      this._sortedElements.ymin.length = 0;
      this._sortedElements.ymax.length = 0;
      this._elementMap.forEach(function (vp, id) {
        _this2._sortedElements.xmin.push([id, vp.t.x]);
        _this2._sortedElements.xmax.push([id, vp.t.x + vp.t.w]);
        _this2._sortedElements.ymin.push([id, vp.t.y]);
        _this2._sortedElements.ymax.push([id, vp.t.y + vp.t.h]);
      });
      this._sortedElements.xmin.sort(entryComparator);
      this._sortedElements.ymin.sort(entryComparator);
      this._sortedElements.xmax.sort(reverseEntryComparator);
      this._sortedElements.ymax.sort(reverseEntryComparator);
      this._recalculateBounds();
    }
  }, {
    key: "_finaliseUpdate",
    value: function _finaliseUpdate(id, e, doNotRecalculateBounds) {
      e.t = rotate(e.x, e.y, e.w, e.h, e.r);
      this._transformedElementMap.set(id, e.t);
      if (doNotRecalculateBounds !== true) {
        this._updateBounds(id, e, doNotRecalculateBounds);
      }
    }
  }, {
    key: "shouldFireEvent",
    value: function shouldFireEvent(event, value, originalEvent) {
      return true;
    }
  }, {
    key: "startTransaction",
    value: function startTransaction() {
      if (this._currentTransaction != null) {
        throw new Error("Viewport: cannot start transaction; a transaction is currently active.");
      }
      this._currentTransaction = new Transaction();
    }
  }, {
    key: "endTransaction",
    value: function endTransaction() {
      var _this3 = this;
      if (this._currentTransaction != null) {
        this._currentTransaction.affectedElements.forEach(function (id) {
          var entry = _this3.getPosition(id);
          _this3._finaliseUpdate(id, entry, true);
        });
        this.recomputeBounds();
        this._currentTransaction = null;
      }
    }
  }, {
    key: "updateElements",
    value: function updateElements(entries) {
      var _this4 = this;
      forEach(entries, function (e) {
        return _this4.updateElement(e.id, e.x, e.y, e.width, e.height, e.rotation);
      });
    }
  }, {
    key: "updateElement",
    value: function updateElement(id, x, y, width, height, rotation, doNotRecalculateBounds) {
      var e = getsert(this._elementMap, id, EMPTY_POSITION);
      e.dirty = x == null && e.x == null || y == null && e.y == null || width == null && e.w == null || height == null && e.h == null;
      if (x != null) {
        e.x = x;
      }
      if (y != null) {
        e.y = y;
      }
      if (width != null) {
        e.w = width;
      }
      if (height != null) {
        e.h = height;
      }
      if (rotation != null) {
        e.r = rotation || 0;
      }
      e.c.x = e.x + e.w / 2;
      e.c.y = e.y + e.h / 2;
      e.x2 = e.x + e.w;
      e.y2 = e.y + e.h;
      if (this._currentTransaction == null) {
        this._finaliseUpdate(id, e, doNotRecalculateBounds);
      } else {
        this._currentTransaction.affectedElements.add(id);
      }
      return e;
    }
  }, {
    key: "refreshElement",
    value: function refreshElement(elId, doNotRecalculateBounds) {
      var me = this.instance.getManagedElements();
      var s = me[elId] ? me[elId].el : null;
      if (s != null) {
        var size = this.getSize(s);
        var offset = this.getOffset(s);
        return this.updateElement(elId, offset.x, offset.y, size.w, size.h, null, doNotRecalculateBounds);
      } else {
        return null;
      }
    }
  }, {
    key: "getSize",
    value: function getSize(el) {
      return this.instance.getSize(el);
    }
  }, {
    key: "getOffset",
    value: function getOffset(el) {
      return this.instance.getOffset(el);
    }
  }, {
    key: "registerElement",
    value: function registerElement(id, doNotRecalculateBounds) {
      return this.updateElement(id, 0, 0, 0, 0, 0, doNotRecalculateBounds);
    }
  }, {
    key: "addElement",
    value: function addElement(id, x, y, width, height, rotation) {
      return this.updateElement(id, x, y, width, height, rotation);
    }
  }, {
    key: "rotateElement",
    value: function rotateElement(id, rotation) {
      var e = getsert(this._elementMap, id, EMPTY_POSITION);
      e.r = rotation || 0;
      this._finaliseUpdate(id, e);
      return e;
    }
  }, {
    key: "getBoundsWidth",
    value: function getBoundsWidth() {
      return this._bounds.maxx - this._bounds.minx;
    }
  }, {
    key: "getBoundsHeight",
    value: function getBoundsHeight() {
      return this._bounds.maxy - this._bounds.miny;
    }
  }, {
    key: "getX",
    value: function getX() {
      return this._bounds.minx;
    }
  }, {
    key: "getY",
    value: function getY() {
      return this._bounds.miny;
    }
  }, {
    key: "setSize",
    value: function setSize(id, w, h) {
      if (this._elementMap.has(id)) {
        return this.updateElement(id, null, null, w, h, null);
      }
    }
  }, {
    key: "setPosition",
    value: function setPosition(id, x, y) {
      if (this._elementMap.has(id)) {
        return this.updateElement(id, x, y, null, null, null);
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this._sortedElements.xmin.length = 0;
      this._sortedElements.xmax.length = 0;
      this._sortedElements.ymin.length = 0;
      this._sortedElements.ymax.length = 0;
      this._elementMap.clear();
      this._transformedElementMap.clear();
      this._recalculateBounds();
    }
  }, {
    key: "remove",
    value: function remove(id) {
      _clearElementIndex(id, this._sortedElements.xmin);
      _clearElementIndex(id, this._sortedElements.xmax);
      _clearElementIndex(id, this._sortedElements.ymin);
      _clearElementIndex(id, this._sortedElements.ymax);
      this._elementMap["delete"](id);
      this._transformedElementMap["delete"](id);
      this._recalculateBounds();
    }
  }, {
    key: "getPosition",
    value: function getPosition(id) {
      return this._elementMap.get(id);
    }
  }, {
    key: "getElements",
    value: function getElements() {
      return this._elementMap;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._elementMap.size === 0;
    }
  }]);
  return Viewport;
}(EventGenerator);

var ConnectionDragSelector = function () {
  function ConnectionDragSelector(selector, def) {
    var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    jsplumb_core_es_classCallCheck(this, ConnectionDragSelector);
    this.selector = selector;
    this.def = def;
    this.exclude = exclude;
  }
  jsplumb_core_es_createClass(ConnectionDragSelector, [{
    key: "setEnabled",
    value: function setEnabled(enabled) {
      this.def.enabled = enabled;
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.def.enabled !== false;
    }
  }]);
  return ConnectionDragSelector;
}();
var REDROP_POLICY_STRICT = "strict";
var REDROP_POLICY_ANY = "any";
var SourceSelector = function (_ConnectionDragSelect) {
  jsplumb_core_es_inherits(SourceSelector, _ConnectionDragSelect);
  var _super = jsplumb_core_es_createSuper(SourceSelector);
  function SourceSelector(selector, def, exclude) {
    var _this;
    jsplumb_core_es_classCallCheck(this, SourceSelector);
    _this = _super.call(this, selector, def, exclude);
    _this.def = def;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "redrop", void 0);
    _this.redrop = def.def.redrop || REDROP_POLICY_STRICT;
    return _this;
  }
  return SourceSelector;
}(ConnectionDragSelector);
var TargetSelector = function (_ConnectionDragSelect2) {
  jsplumb_core_es_inherits(TargetSelector, _ConnectionDragSelect2);
  var _super2 = jsplumb_core_es_createSuper(TargetSelector);
  function TargetSelector(selector, def, exclude) {
    var _this2;
    jsplumb_core_es_classCallCheck(this, TargetSelector);
    _this2 = _super2.call(this, selector, def, exclude);
    _this2.def = def;
    return _this2;
  }
  return TargetSelector;
}(ConnectionDragSelector);

var _edgeSortFunctions;
function _placeAnchorsOnLine(element, connections, horizontal, otherMultiplier, reverse) {
  var sizeInAxis = horizontal ? element.w : element.h;
  var sizeInOtherAxis = horizontal ? element.h : element.w;
  var a = [],
      step = sizeInAxis / (connections.length + 1);
  for (var i = 0; i < connections.length; i++) {
    var val = (i + 1) * step,
        other = otherMultiplier * sizeInOtherAxis;
    if (reverse) {
      val = sizeInAxis - val;
    }
    var dx = horizontal ? val : other,
        x = element.x + dx,
        xp = dx / element.w;
    var dy = horizontal ? other : val,
        y = element.y + dy,
        yp = dy / element.h;
    if (element.r !== 0 && element.r != null) {
      var rotated = rotatePoint({
        x: x,
        y: y
      }, element.c, element.r);
      x = rotated.x;
      y = rotated.y;
    }
    a.push({
      x: x,
      y: y,
      xLoc: xp,
      yLoc: yp,
      c: connections[i].c
    });
  }
  return a;
}
function _rightAndBottomSort(a, b) {
  return b.theta - a.theta;
}
function _leftAndTopSort(a, b) {
  var p1 = a.theta < 0 ? -Math.PI - a.theta : Math.PI - a.theta,
      p2 = b.theta < 0 ? -Math.PI - b.theta : Math.PI - b.theta;
  return p1 - p2;
}
var edgeSortFunctions = (_edgeSortFunctions = {}, jsplumb_core_es_defineProperty(_edgeSortFunctions, TOP, _leftAndTopSort), jsplumb_core_es_defineProperty(_edgeSortFunctions, RIGHT, _rightAndBottomSort), jsplumb_core_es_defineProperty(_edgeSortFunctions, BOTTOM, _rightAndBottomSort), jsplumb_core_es_defineProperty(_edgeSortFunctions, LEFT, _leftAndTopSort), _edgeSortFunctions);
function isContinuous(a) {
  return a.isContinuous === true;
}
function _isFloating(a) {
  return a.isContinuous === true;
}
function isDynamic(a) {
  return a.locations.length > 1;
}
function getCurrentLocation(anchor) {
  return [anchor.currentLocation, anchor.locations[anchor.currentLocation]];
}
var jsplumb_core_es_LightweightRouter = function () {
  function LightweightRouter(instance) {
    var _this = this;
    jsplumb_core_es_classCallCheck(this, LightweightRouter);
    this.instance = instance;
    jsplumb_core_es_defineProperty(this, "anchorLists", new Map());
    jsplumb_core_es_defineProperty(this, "anchorLocations", new Map());
    instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
      _this._removeEndpointFromAnchorLists(p.sourceEndpoint);
      _this._removeEndpointFromAnchorLists(p.targetEndpoint);
    });
    instance.bind(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, function (ep) {
      _this._removeEndpointFromAnchorLists(ep);
    });
  }
  jsplumb_core_es_createClass(LightweightRouter, [{
    key: "getAnchorOrientation",
    value: function getAnchorOrientation(anchor) {
      var loc = this.anchorLocations.get(anchor.id);
      return loc ? [loc.ox, loc.oy] : [0, 0];
    }
  }, {
    key: "_distance",
    value: function _distance(anchor, cx, cy, xy, wh, rotation, targetRotation) {
      var ax = xy.x + anchor.x * wh.w,
          ay = xy.y + anchor.y * wh.h,
          acx = xy.x + wh.w / 2,
          acy = xy.y + wh.h / 2;
      if (rotation != null && rotation.length > 0) {
        var rotated = this.instance._applyRotations([ax, ay, 0, 0], rotation);
        ax = rotated.x;
        ay = rotated.y;
      }
      return Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) + Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2));
    }
  }, {
    key: "_anchorSelector",
    value: function _anchorSelector(xy, wh, txy, twh, rotation, targetRotation, locations) {
      var cx = txy.x + twh.w / 2,
          cy = txy.y + twh.h / 2;
      var minIdx = -1,
          minDist = Infinity;
      for (var i = 0; i < locations.length; i++) {
        var d = this._distance(locations[i], cx, cy, xy, wh, rotation, targetRotation);
        if (d < minDist) {
          minIdx = i + 0;
          minDist = d;
        }
      }
      return [minIdx, locations[minIdx]];
    }
  }, {
    key: "_floatingAnchorCompute",
    value: function _floatingAnchorCompute(anchor, params) {
      var xy = params.xy;
      var pos = {
        curX: xy.x + anchor.size.w / 2,
        curY: xy.y + anchor.size.h / 2,
        x: 0,
        y: 0,
        ox: 0,
        oy: 0
      };
      return this._setComputedPosition(anchor, pos);
    }
  }, {
    key: "_setComputedPosition",
    value: function _setComputedPosition(anchor, pos, timestamp) {
      this.anchorLocations.set(anchor.id, pos);
      anchor.computedPosition = pos;
      if (timestamp) {
        anchor.timestamp = timestamp;
      }
      return pos;
    }
  }, {
    key: "_computeSingleLocation",
    value: function _computeSingleLocation(loc, xy, wh, params) {
      var candidate = {
        curX: xy.x + loc.x * wh.w + loc.offx,
        curY: xy.y + loc.y * wh.h + loc.offy,
        x: loc.x,
        y: loc.y,
        ox: 0,
        oy: 0
      };
      var pos;
      var rotation = params.rotation;
      if (rotation != null && rotation.length > 0) {
        var o = [loc.iox, loc.ioy],
            current = {
          x: candidate.curX,
          y: candidate.curY,
          cr: 0,
          sr: 0
        };
        forEach(rotation, function (r) {
          current = rotatePoint(current, r.c, r.r);
          var _o = [Math.round(o[0] * current.cr - o[1] * current.sr), Math.round(o[1] * current.cr + o[0] * current.sr)];
          o = _o.slice();
        });
        loc.ox = o[0];
        loc.oy = o[1];
        pos = {
          curX: current.x,
          curY: current.y,
          x: loc.x,
          y: loc.y,
          ox: o[0],
          oy: o[1]
        };
      } else {
        loc.ox = loc.iox;
        loc.oy = loc.ioy;
        pos = extend({
          ox: loc.iox,
          oy: loc.ioy
        }, candidate);
      }
      return pos;
    }
  }, {
    key: "_singleAnchorCompute",
    value: function _singleAnchorCompute(anchor, params) {
      var xy = params.xy,
          wh = params.wh,
          timestamp = params.timestamp,
          pos = this.anchorLocations.get(anchor.id);
      if (pos != null && timestamp && timestamp === anchor.timestamp) {
        return pos;
      }
      var _getCurrentLocation = getCurrentLocation(anchor),
          _getCurrentLocation2 = jsplumb_core_es_slicedToArray(_getCurrentLocation, 2);
          _getCurrentLocation2[0];
          var currentLoc = _getCurrentLocation2[1];
      pos = this._computeSingleLocation(currentLoc, xy, wh, params);
      return this._setComputedPosition(anchor, pos, timestamp);
    }
  }, {
    key: "_defaultAnchorCompute",
    value: function _defaultAnchorCompute(anchor, params) {
      var pos;
      if (anchor.locations.length === 1) {
        return this._singleAnchorCompute(anchor, params);
      }
      var xy = params.xy,
          wh = params.wh,
          txy = params.txy,
          twh = params.twh;
      var _getCurrentLocation3 = getCurrentLocation(anchor),
          _getCurrentLocation4 = jsplumb_core_es_slicedToArray(_getCurrentLocation3, 2),
          currentIdx = _getCurrentLocation4[0],
          currentLoc = _getCurrentLocation4[1];
      if (anchor.locked || txy == null || twh == null) {
        pos = this._computeSingleLocation(currentLoc, xy, wh, params);
      } else {
        var _this$_anchorSelector = this._anchorSelector(xy, wh, txy, twh, params.rotation, params.tRotation, anchor.locations),
            _this$_anchorSelector2 = jsplumb_core_es_slicedToArray(_this$_anchorSelector, 2),
            newIdx = _this$_anchorSelector2[0],
            newLoc = _this$_anchorSelector2[1];
        anchor.currentLocation = newIdx;
        if (newIdx !== currentIdx) {
          anchor.cssClass = newLoc.cls || anchor.cssClass;
          params.element._anchorLocationChanged(anchor);
        }
        pos = this._computeSingleLocation(newLoc, xy, wh, params);
      }
      return this._setComputedPosition(anchor, pos, params.timestamp);
    }
  }, {
    key: "_placeAnchors",
    value: function _placeAnchors(elementId, _anchorLists) {
      var _this2 = this;
      var cd = this.instance.viewport.getPosition(elementId),
          placeSomeAnchors = function placeSomeAnchors(desc, element, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
        if (unsortedConnections.length > 0) {
          var sc = unsortedConnections.sort(edgeSortFunctions[desc]),
          reverse = desc === RIGHT || desc === TOP,
              anchors = _placeAnchorsOnLine(cd, sc, isHorizontal, otherMultiplier, reverse);
          for (var i = 0; i < anchors.length; i++) {
            var c = anchors[i].c,
                weAreSource = c.endpoints[0].elementId === elementId,
                ep = weAreSource ? c.endpoints[0] : c.endpoints[1];
            _this2._setComputedPosition(ep._anchor, {
              curX: anchors[i].x,
              curY: anchors[i].y,
              x: anchors[i].xLoc,
              y: anchors[i].yLoc,
              ox: orientation[0],
              oy: orientation[1]
            });
          }
        }
      };
      placeSomeAnchors(BOTTOM, cd, _anchorLists.bottom, true, 1, [0, 1]);
      placeSomeAnchors(TOP, cd, _anchorLists.top, true, 0, [0, -1]);
      placeSomeAnchors(LEFT, cd, _anchorLists.left, false, 0, [-1, 0]);
      placeSomeAnchors(RIGHT, cd, _anchorLists.right, false, 1, [1, 0]);
    }
  }, {
    key: "_updateAnchorList",
    value: function _updateAnchorList(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, connsToPaint, endpointsToPaint) {
      var endpoint = conn.endpoints[idx],
          endpointId = endpoint.id,
          oIdx = [1, 0][idx],
          values = {
        theta: theta,
        order: order,
        c: conn,
        b: aBoolean,
        elId: otherElId,
        epId: endpointId
      },
          listToAddTo = lists[edgeId],
          listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
          candidate;
      if (listToRemoveFrom) {
        var rIdx = findWithFunction(listToRemoveFrom, function (e) {
          return e.epId === endpointId;
        });
        if (rIdx !== -1) {
          listToRemoveFrom.splice(rIdx, 1);
          for (var i = 0; i < listToRemoveFrom.length; i++) {
            candidate = listToRemoveFrom[i].c;
            if (candidate.placeholder !== true) {
              connsToPaint.add(candidate);
            }
            endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[idx]);
            endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[oIdx]);
          }
        }
      }
      for (var _i = 0; _i < listToAddTo.length; _i++) {
        candidate = listToAddTo[_i].c;
        if (candidate.placeholder !== true) {
          connsToPaint.add(candidate);
        }
        endpointsToPaint.add(listToAddTo[_i].c.endpoints[idx]);
        endpointsToPaint.add(listToAddTo[_i].c.endpoints[oIdx]);
      }
      {
        var insertIdx = reverse ? 0 : listToAddTo.length;
        listToAddTo.splice(insertIdx, 0, values);
      }
      endpoint._continuousAnchorEdge = edgeId;
    }
  }, {
    key: "_removeEndpointFromAnchorLists",
    value: function _removeEndpointFromAnchorLists(endpoint) {
      var listsForElement = this.anchorLists.get(endpoint.elementId);
      var total = 0;
      (function (list, eId) {
        if (list) {
          var f = function f(e) {
            return e.epId === eId;
          };
          removeWithFunction(list.top, f);
          removeWithFunction(list.left, f);
          removeWithFunction(list.bottom, f);
          removeWithFunction(list.right, f);
          total += list.top.length;
          total += list.left.length;
          total += list.bottom.length;
          total += list.right.length;
        }
      })(listsForElement, endpoint.id);
      if (total === 0) {
        this.anchorLists["delete"](endpoint.elementId);
      }
      this.anchorLocations["delete"](endpoint._anchor.id);
    }
  }, {
    key: "computeAnchorLocation",
    value: function computeAnchorLocation(anchor, params) {
      var pos;
      if (isContinuous(anchor)) {
        pos = this.anchorLocations.get(anchor.id) || {
          curX: 0,
          curY: 0,
          x: 0,
          y: 0,
          ox: 0,
          oy: 0
        };
      } else if (_isFloating(anchor)) {
        pos = this._floatingAnchorCompute(anchor, params);
      } else {
        pos = this._defaultAnchorCompute(anchor, params);
      }
      anchor.timestamp = params.timestamp;
      return pos;
    }
  }, {
    key: "computePath",
    value: function computePath(connection, timestamp) {
      var sourceInfo = this.instance.viewport.getPosition(connection.sourceId),
          targetInfo = this.instance.viewport.getPosition(connection.targetId),
          sE = connection.endpoints[0],
          tE = connection.endpoints[1];
      var sAnchorP = this.getEndpointLocation(sE, {
        xy: sourceInfo,
        wh: sourceInfo,
        element: sE,
        timestamp: timestamp,
        rotation: this.instance._getRotations(connection.sourceId)
      }),
          tAnchorP = this.getEndpointLocation(tE, {
        xy: targetInfo,
        wh: targetInfo,
        element: tE,
        timestamp: timestamp,
        rotation: this.instance._getRotations(connection.targetId)
      });
      connection.connector.resetBounds();
      connection.connector.compute({
        sourcePos: sAnchorP,
        targetPos: tAnchorP,
        sourceEndpoint: connection.endpoints[0],
        targetEndpoint: connection.endpoints[1],
        strokeWidth: connection.paintStyleInUse.strokeWidth,
        sourceInfo: sourceInfo,
        targetInfo: targetInfo
      });
    }
  }, {
    key: "getEndpointLocation",
    value: function getEndpointLocation(endpoint, params) {
      params = params || {};
      var anchor = endpoint._anchor;
      var pos = this.anchorLocations.get(anchor.id);
      if (pos == null || params.timestamp != null && anchor.timestamp !== params.timestamp) {
        pos = this.computeAnchorLocation(anchor, params);
        this._setComputedPosition(anchor, pos, params.timestamp);
      }
      return pos;
    }
  }, {
    key: "getEndpointOrientation",
    value: function getEndpointOrientation(ep) {
      return ep._anchor ? this.getAnchorOrientation(ep._anchor) : [0, 0];
    }
  }, {
    key: "isDynamicAnchor",
    value: function isDynamicAnchor(ep) {
      return ep._anchor ? !isContinuous(ep._anchor) && ep._anchor.locations.length > 1 : false;
    }
  }, {
    key: "isFloating",
    value: function isFloating(ep) {
      return ep._anchor ? _isFloating(ep._anchor) : false;
    }
  }, {
    key: "prepareAnchor",
    value: function prepareAnchor(endpoint, params) {
      return makeLightweightAnchorFromSpec(params);
    }
  }, {
    key: "redraw",
    value: function redraw(elementId, timestamp, offsetToUI) {
      var _this3 = this;
      var connectionsToPaint = new Set(),
          endpointsToPaint = new Set(),
          anchorsToUpdate = new Set();
      if (!this.instance._suspendDrawing) {
        var ep = this.instance.endpointsByElement[elementId] || [];
        timestamp = timestamp || jsplumb_util_es_uuid();
        var orientationCache = {},
            a,
            anEndpoint;
        for (var i = 0; i < ep.length; i++) {
          anEndpoint = ep[i];
          endpointsToPaint.add(anEndpoint);
          a = anEndpoint._anchor;
          if (anEndpoint.connections.length === 0) {
            if (isContinuous(a)) {
              if (!this.anchorLists.has(elementId)) {
                this.anchorLists.set(elementId, {
                  top: [],
                  right: [],
                  bottom: [],
                  left: []
                });
              }
              this._updateAnchorList(this.anchorLists.get(elementId), -Math.PI / 2, 0, {
                endpoints: [anEndpoint, anEndpoint],
                placeholder: true
              }, false, elementId, 0, false, getDefaultFace(a), connectionsToPaint, endpointsToPaint);
              anchorsToUpdate.add(elementId);
            }
          } else {
            for (var _i2 = 0; _i2 < anEndpoint.connections.length; _i2++) {
              var conn = anEndpoint.connections[_i2],
                  sourceId = conn.sourceId,
                  targetId = conn.targetId,
                  sourceContinuous = isContinuous(conn.endpoints[0]._anchor),
                  targetContinuous = isContinuous(conn.endpoints[1]._anchor);
              if (sourceContinuous || targetContinuous) {
                var oKey = sourceId + "_" + targetId,
                    o = orientationCache[oKey],
                    oIdx = conn.sourceId === elementId ? 1 : 0;
                if (sourceContinuous && !this.anchorLists.has(sourceId)) {
                  this.anchorLists.set(sourceId, {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                  });
                }
                if (targetContinuous && !this.anchorLists.has(targetId)) {
                  this.anchorLists.set(targetId, {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                  });
                }
                var td = this.instance.viewport.getPosition(targetId),
                    sd = this.instance.viewport.getPosition(sourceId);
                if (targetId === sourceId && (sourceContinuous || targetContinuous)) {
                  this._updateAnchorList(this.anchorLists.get(sourceId), -Math.PI / 2, 0, conn, false, targetId, 0, false, TOP, connectionsToPaint, endpointsToPaint);
                  this._updateAnchorList(this.anchorLists.get(targetId), -Math.PI / 2, 0, conn, false, sourceId, 1, false, TOP, connectionsToPaint, endpointsToPaint);
                } else {
                  var sourceRotation = this.instance._getRotations(sourceId);
                  var targetRotation = this.instance._getRotations(targetId);
                  if (!o) {
                    o = this._calculateOrientation(sourceId, targetId, sd, td, conn.endpoints[0]._anchor, conn.endpoints[1]._anchor, sourceRotation, targetRotation);
                    orientationCache[oKey] = o;
                  }
                  if (sourceContinuous) {
                    this._updateAnchorList(this.anchorLists.get(sourceId), o.theta, 0, conn, false, targetId, 0, false, o.a[0], connectionsToPaint, endpointsToPaint);
                  }
                  if (targetContinuous) {
                    this._updateAnchorList(this.anchorLists.get(targetId), o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], connectionsToPaint, endpointsToPaint);
                  }
                }
                if (sourceContinuous) {
                  anchorsToUpdate.add(sourceId);
                }
                if (targetContinuous) {
                  anchorsToUpdate.add(targetId);
                }
                connectionsToPaint.add(conn);
                if (sourceContinuous && oIdx === 0 || targetContinuous && oIdx === 1) {
                  endpointsToPaint.add(conn.endpoints[oIdx]);
                }
              } else {
                var otherEndpoint = anEndpoint.connections[_i2].endpoints[conn.sourceId === elementId ? 1 : 0],
                    otherAnchor = otherEndpoint._anchor;
                if (isDynamic(otherAnchor)) {
                  this.instance.paintEndpoint(otherEndpoint, {
                    elementWithPrecedence: elementId,
                    timestamp: timestamp
                  });
                  connectionsToPaint.add(anEndpoint.connections[_i2]);
                  for (var k = 0; k < otherEndpoint.connections.length; k++) {
                    if (otherEndpoint.connections[k] !== anEndpoint.connections[_i2]) {
                      connectionsToPaint.add(otherEndpoint.connections[k]);
                    }
                  }
                } else {
                  connectionsToPaint.add(anEndpoint.connections[_i2]);
                }
              }
            }
          }
        }
        anchorsToUpdate.forEach(function (anchor) {
          _this3._placeAnchors(anchor, _this3.anchorLists.get(anchor));
        });
        endpointsToPaint.forEach(function (ep) {
          var cd = _this3.instance.viewport.getPosition(ep.elementId);
          _this3.instance.paintEndpoint(ep, {
            timestamp: timestamp,
            offset: cd
          });
        });
        connectionsToPaint.forEach(function (c) {
          _this3.instance.paintConnection(c, {
            timestamp: timestamp
          });
        });
      }
      return {
        c: connectionsToPaint,
        e: endpointsToPaint
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this.anchorLocations.clear();
      this.anchorLists.clear();
    }
  }, {
    key: "setAnchor",
    value: function setAnchor(endpoint, anchor) {
      if (anchor != null) {
        endpoint._anchor = anchor;
      }
    }
  }, {
    key: "setConnectionAnchors",
    value: function setConnectionAnchors(conn, anchors) {
      conn.endpoints[0]._anchor = anchors[0];
      conn.endpoints[1]._anchor = anchors[1];
    }
  }, {
    key: "_calculateOrientation",
    value: function _calculateOrientation(sourceId, targetId, sd, td, sourceAnchor, targetAnchor, sourceRotation, targetRotation) {
      var _this4 = this;
      var Orientation = {
        HORIZONTAL: "horizontal",
        VERTICAL: "vertical",
        DIAGONAL: "diagonal",
        IDENTITY: "identity"
      };
      if (sourceId === targetId) {
        return {
          orientation: Orientation.IDENTITY,
          a: [TOP, TOP]
        };
      }
      var theta = Math.atan2(td.c.y - sd.c.y, td.c.x - sd.c.x),
          theta2 = Math.atan2(sd.c.y - td.c.y, sd.c.x - td.c.x);
      var candidates = [],
          midpoints = {};
      (function (types, dim) {
        for (var i = 0; i < types.length; i++) {
          var _midpoints$types$i;
          midpoints[types[i]] = (_midpoints$types$i = {}, jsplumb_core_es_defineProperty(_midpoints$types$i, LEFT, {
            x: dim[i][0].x,
            y: dim[i][0].c.y
          }), jsplumb_core_es_defineProperty(_midpoints$types$i, RIGHT, {
            x: dim[i][0].x + dim[i][0].w,
            y: dim[i][0].c.y
          }), jsplumb_core_es_defineProperty(_midpoints$types$i, TOP, {
            x: dim[i][0].c.x,
            y: dim[i][0].y
          }), jsplumb_core_es_defineProperty(_midpoints$types$i, BOTTOM, {
            x: dim[i][0].c.x,
            y: dim[i][0].y + dim[i][0].h
          }), _midpoints$types$i);
          if (dim[i][1] != null && dim[i][1].length > 0) {
            for (var axis in midpoints[types[i]]) {
              midpoints[types[i]][axis] = _this4.instance._applyRotationsXY(midpoints[types[i]][axis], dim[i][1]);
            }
          }
        }
      })([SOURCE, TARGET], [[sd, sourceRotation], [td, targetRotation]]);
      var FACES = [TOP, LEFT, RIGHT, BOTTOM];
      for (var sf = 0; sf < FACES.length; sf++) {
        for (var tf = 0; tf < FACES.length; tf++) {
          candidates.push({
            source: FACES[sf],
            target: FACES[tf],
            dist: lineLength(midpoints.source[FACES[sf]], midpoints.target[FACES[tf]])
          });
        }
      }
      candidates.sort(function (a, b) {
        if (a.dist < b.dist) {
          return -1;
        } else if (b.dist < a.dist) {
          return 1;
        } else {
          var _axisIndices;
          var axisIndices = (_axisIndices = {}, jsplumb_core_es_defineProperty(_axisIndices, LEFT, 0), jsplumb_core_es_defineProperty(_axisIndices, TOP, 1), jsplumb_core_es_defineProperty(_axisIndices, RIGHT, 2), jsplumb_core_es_defineProperty(_axisIndices, BOTTOM, 3), _axisIndices),
              ais = axisIndices[a.source],
              bis = axisIndices[b.source],
              ait = axisIndices[a.target],
              bit = axisIndices[b.target];
          return ais < bis ? -1 : bis < ais ? 1 : ait < bit ? -1 : bit < ait ? 1 : 0;
        }
      });
      var sourceEdge = candidates[0].source,
          targetEdge = candidates[0].target;
      for (var i = 0; i < candidates.length; i++) {
        if (isContinuous(sourceAnchor) && sourceAnchor.locked) {
          sourceEdge = sourceAnchor.currentFace;
        } else if (!sourceAnchor.isContinuous || isEdgeSupported(sourceAnchor, candidates[i].source)) {
          sourceEdge = candidates[i].source;
        } else {
          sourceEdge = null;
        }
        if (targetAnchor.isContinuous && targetAnchor.locked) {
          targetEdge = targetAnchor.currentFace;
        } else if (!targetAnchor.isContinuous || isEdgeSupported(targetAnchor, candidates[i].target)) {
          targetEdge = candidates[i].target;
        } else {
          targetEdge = null;
        }
        if (sourceEdge != null && targetEdge != null) {
          break;
        }
      }
      if (sourceAnchor.isContinuous) {
        this.setCurrentFace(sourceAnchor, sourceEdge);
      }
      if (targetAnchor.isContinuous) {
        this.setCurrentFace(targetAnchor, targetEdge);
      }
      return {
        a: [sourceEdge, targetEdge],
        theta: theta,
        theta2: theta2
      };
    }
  }, {
    key: "setCurrentFace",
    value: function setCurrentFace(a, face, overrideLock) {
      a.currentFace = face;
      if (overrideLock && a.lockedFace != null) {
        a.lockedFace = a.currentFace;
      }
    }
  }, {
    key: "lock",
    value: function lock(a) {
      a.locked = true;
      if (isContinuous(a)) {
        a.lockedFace = a.currentFace;
      }
    }
  }, {
    key: "unlock",
    value: function unlock(a) {
      a.locked = false;
      if (isContinuous(a)) {
        a.lockedFace = null;
      }
    }
  }, {
    key: "selectAnchorLocation",
    value: function selectAnchorLocation(a, coords) {
      var idx = findWithFunction(a.locations, function (loc) {
        return loc.x === coords.x && loc.y === coords.y;
      });
      if (idx !== -1) {
        a.currentLocation = idx;
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "lockCurrentAxis",
    value: function lockCurrentAxis(a) {
      if (a.currentFace != null) {
        a.lockedAxis = a.currentFace === LEFT || a.currentFace === RIGHT ? X_AXIS_FACES : Y_AXIS_FACES;
      }
    }
  }, {
    key: "unlockCurrentAxis",
    value: function unlockCurrentAxis(a) {
      a.lockedAxis = null;
    }
  }, {
    key: "anchorsEqual",
    value: function anchorsEqual(a1, a2) {
      if (!a1 || !a2) {
        return false;
      }
      var l1 = a1.locations[a1.currentLocation],
          l2 = a2.locations[a2.currentLocation];
      return l1.x === l2.x && l1.y === l2.y && l1.offx === l2.offx && l1.offy === l2.offy && l1.ox === l2.ox && l1.oy === l2.oy;
    }
  }]);
  return LightweightRouter;
}();

function _scopeMatch(e1, e2) {
  var s1 = e1.scope.split(/\s/),
      s2 = e2.scope.split(/\s/);
  for (var i = 0; i < s1.length; i++) {
    for (var j = 0; j < s2.length; j++) {
      if (s2[j] === s1[i]) {
        return true;
      }
    }
  }
  return false;
}
function prepareList(instance, input, doNotGetIds) {
  var r = [];
  var _resolveId = function _resolveId(i) {
    if (isString(i)) {
      return i;
    } else {
      return instance.getId(i);
    }
  };
  if (input) {
    if (typeof input === 'string') {
      if (input === "*") {
        return input;
      }
      r.push(input);
    } else {
      if (doNotGetIds) {
        r = input;
      } else {
        if (input.length != null) {
          var _r;
          (_r = r).push.apply(_r, _toConsumableArray(_toConsumableArray(input).map(_resolveId)));
        } else {
          r.push(_resolveId(input));
        }
      }
    }
  }
  return r;
}
function addManagedEndpoint(managedElement, ep) {
  if (managedElement != null) {
    managedElement.endpoints.push(ep);
  }
}
function removeManagedEndpoint(managedElement, endpoint) {
  if (managedElement != null) {
    removeWithFunction(managedElement.endpoints, function (ep) {
      return ep === endpoint;
    });
  }
}
function addManagedConnection(connection, sourceEl, targetEl) {
  if (sourceEl != null) {
    sourceEl.connections.push(connection);
    if (sourceEl.connections.length === 1) {
      connection.instance.addClass(connection.source, connection.instance.connectedClass);
    }
  }
  if (targetEl != null) {
    if (sourceEl == null || connection.sourceId !== connection.targetId) {
      targetEl.connections.push(connection);
      if (targetEl.connections.length === 1) {
        connection.instance.addClass(connection.target, connection.instance.connectedClass);
      }
    }
  }
}
function removeManagedConnection(connection, sourceEl, targetEl) {
  if (sourceEl != null) {
    var sourceCount = sourceEl.connections.length;
    removeWithFunction(sourceEl.connections, function (_c) {
      return connection.id === _c.id;
    });
    if (sourceCount > 0 && sourceEl.connections.length === 0) {
      connection.instance.removeClass(connection.source, connection.instance.connectedClass);
    }
  }
  if (targetEl != null) {
    var targetCount = targetEl.connections.length;
    if (sourceEl == null || connection.sourceId !== connection.targetId) {
      removeWithFunction(targetEl.connections, function (_c) {
        return connection.id === _c.id;
      });
    }
    if (targetCount > 0 && targetEl.connections.length === 0) {
      connection.instance.removeClass(connection.target, connection.instance.connectedClass);
    }
  }
}
var jsplumb_core_es_JsPlumbInstance = function (_EventGenerator) {
  jsplumb_core_es_inherits(JsPlumbInstance, _EventGenerator);
  var _super = jsplumb_core_es_createSuper(JsPlumbInstance);
  function JsPlumbInstance(_instanceIndex, defaults) {
    var _this;
    jsplumb_core_es_classCallCheck(this, JsPlumbInstance);
    _this = _super.call(this);
    _this._instanceIndex = _instanceIndex;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "defaults", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_initialDefaults", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "isConnectionBeingDragged", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "currentlyDragging", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "hoverSuspended", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_suspendDrawing", false);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_suspendedAt", null);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorClass", CLASS_CONNECTOR);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectorOutlineClass", CLASS_CONNECTOR_OUTLINE);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connectedClass", CLASS_CONNECTED);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointClass", CLASS_ENDPOINT);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointConnectedClass", CLASS_ENDPOINT_CONNECTED);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointFullClass", CLASS_ENDPOINT_FULL);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointDropAllowedClass", CLASS_ENDPOINT_DROP_ALLOWED);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointDropForbiddenClass", CLASS_ENDPOINT_DROP_FORBIDDEN);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointAnchorClassPrefix", CLASS_ENDPOINT_ANCHOR_PREFIX);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "overlayClass", CLASS_OVERLAY);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "connections", []);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointsByElement", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endpointsByUUID", new Map());
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "sourceSelectors", []);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "targetSelectors", []);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "allowNestedGroups", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_curIdStamp", 1);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "viewport", new jsplumb_core_es_Viewport(jsplumb_core_es_assertThisInitialized(_this)));
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "router", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "groupManager", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_connectionTypes", new Map());
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_endpointTypes", new Map());
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_container", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_managedElements", {});
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "DEFAULT_SCOPE", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "_zoom", 1);
    _this.defaults = {
      anchor: AnchorLocations.Bottom,
      anchors: [null, null],
      connectionsDetachable: true,
      connectionOverlays: [],
      connector: StraightConnector.type,
      container: null,
      endpoint: DotEndpoint.type,
      endpointOverlays: [],
      endpoints: [null, null],
      endpointStyle: {
        fill: "#456"
      },
      endpointStyles: [null, null],
      endpointHoverStyle: null,
      endpointHoverStyles: [null, null],
      hoverPaintStyle: null,
      listStyle: {},
      maxConnections: 1,
      paintStyle: {
        strokeWidth: 2,
        stroke: "#456"
      },
      reattachConnections: false,
      scope: "jsplumb_defaultscope",
      allowNestedGroups: true
    };
    if (defaults) {
      extend(_this.defaults, defaults);
    }
    extend(_this._initialDefaults, _this.defaults);
    _this.DEFAULT_SCOPE = _this.defaults.scope;
    _this.allowNestedGroups = _this._initialDefaults.allowNestedGroups !== false;
    _this.router = new jsplumb_core_es_LightweightRouter(jsplumb_core_es_assertThisInitialized(_this));
    _this.groupManager = new jsplumb_core_es_GroupManager(jsplumb_core_es_assertThisInitialized(_this));
    _this.setContainer(_this._initialDefaults.container);
    return _this;
  }
  jsplumb_core_es_createClass(JsPlumbInstance, [{
    key: "defaultScope",
    get: function get() {
      return this.DEFAULT_SCOPE;
    }
  }, {
    key: "currentZoom",
    get: function get() {
      return this._zoom;
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this._container;
    }
  }, {
    key: "setZoom",
    value: function setZoom(z, repaintEverything) {
      this._zoom = z;
      this.fire(EVENT_ZOOM, this._zoom);
      if (repaintEverything) {
        this.repaintEverything();
      }
      return true;
    }
  }, {
    key: "_idstamp",
    value: function _idstamp() {
      return "" + this._curIdStamp++;
    }
  }, {
    key: "checkCondition",
    value: function checkCondition(conditionName, args) {
      var l = this.getListener(conditionName),
          r = true;
      if (l && l.length > 0) {
        var values = Array.prototype.slice.call(arguments, 1);
        try {
          for (var i = 0, j = l.length; i < j; i++) {
            r = r && l[i].apply(l[i], values);
          }
        } catch (e) {
          log("cannot check condition [" + conditionName + "]" + e);
        }
      }
      return r;
    }
  }, {
    key: "getId",
    value: function getId(element, uuid) {
      if (element == null) {
        return null;
      }
      var id = this.getAttribute(element, ATTRIBUTE_MANAGED);
      if (!id || id === "undefined") {
        if (arguments.length === 2 && arguments[1] !== undefined) {
          id = uuid;
        } else if (arguments.length === 1 || arguments.length === 3 && !arguments[2]) {
          id = "jsplumb-" + this._instanceIndex + "-" + this._idstamp();
        }
        this.setAttribute(element, ATTRIBUTE_MANAGED, id);
      }
      return id;
    }
  }, {
    key: "getConnections",
    value: function getConnections(options, flat) {
      if (!options) {
        options = {};
      } else if (options.constructor === String) {
        options = {
          "scope": options
        };
      }
      var scope = options.scope || this.defaultScope,
          scopes = prepareList(this, scope, true),
          sources = prepareList(this, options.source),
          targets = prepareList(this, options.target),
          results = !flat && scopes.length > 1 ? {} : [],
          _addOne = function _addOne(scope, obj) {
        if (!flat && scopes.length > 1) {
          var ss = results[scope];
          if (ss == null) {
            ss = results[scope] = [];
          }
          ss.push(obj);
        } else {
          results.push(obj);
        }
      };
      for (var j = 0, jj = this.connections.length; j < jj; j++) {
        var _c2 = this.connections[j],
            sourceId = _c2.proxies && _c2.proxies[0] ? _c2.proxies[0].originalEp.elementId : _c2.sourceId,
            targetId = _c2.proxies && _c2.proxies[1] ? _c2.proxies[1].originalEp.elementId : _c2.targetId;
        if (filterList(scopes, _c2.scope) && filterList(sources, sourceId) && filterList(targets, targetId)) {
          _addOne(_c2.scope, _c2);
        }
      }
      return results;
    }
  }, {
    key: "select",
    value: function select(params) {
      params = params || {};
      params.scope = params.scope || "*";
      return new ConnectionSelection(this, params.connections || this.getConnections(params, true));
    }
  }, {
    key: "selectEndpoints",
    value: function selectEndpoints(params) {
      params = params || {};
      params.scope = params.scope || WILDCARD;
      var noElementFilters = !params.element && !params.source && !params.target,
          elements = noElementFilters ? WILDCARD : prepareList(this, params.element),
          sources = noElementFilters ? WILDCARD : prepareList(this, params.source),
          targets = noElementFilters ? WILDCARD : prepareList(this, params.target),
          scopes = prepareList(this, params.scope, true);
      var ep = [];
      for (var _el2 in this.endpointsByElement) {
        var either = filterList(elements, _el2, true),
            source = filterList(sources, _el2, true),
            sourceMatchExact = sources !== "*",
            target = filterList(targets, _el2, true),
            targetMatchExact = targets !== "*";
        if (either || source || target) {
          inner: for (var i = 0, ii = this.endpointsByElement[_el2].length; i < ii; i++) {
            var _ep = this.endpointsByElement[_el2][i];
            if (filterList(scopes, _ep.scope, true)) {
              var noMatchSource = sourceMatchExact && sources.length > 0 && !_ep.isSource,
                  noMatchTarget = targetMatchExact && targets.length > 0 && !_ep.isTarget;
              if (noMatchSource || noMatchTarget) {
                continue inner;
              }
              ep.push(_ep);
            }
          }
        }
      }
      return new EndpointSelection(this, ep);
    }
  }, {
    key: "setContainer",
    value: function setContainer(c) {
      this._container = c;
      this.fire(EVENT_CONTAINER_CHANGE, this._container);
    }
  }, {
    key: "_set",
    value: function _set(c, el, idx) {
      var stTypes = [{
        el: "source",
        elId: "sourceId"
      }, {
        el: "target",
        elId: "targetId"
      }];
      var ep,
          _st = stTypes[idx],
          cId = c[_st.elId],
          sid,
          oldEndpoint = c.endpoints[idx];
      var evtParams = {
        index: idx,
        originalEndpoint: oldEndpoint,
        originalSourceId: idx === 0 ? cId : c.sourceId,
        newSourceId: c.sourceId,
        originalTargetId: idx === 1 ? cId : c.targetId,
        newTargetId: c.targetId,
        connection: c,
        newEndpoint: oldEndpoint
      };
      if (el instanceof jsplumb_core_es_Endpoint) {
        ep = el;
        ep.addConnection(c);
      } else {
        sid = this.getId(el);
        if (sid === c[_st.elId]) {
          ep = null;
        } else {
          ep = c.makeEndpoint(idx === 0, el, sid);
        }
      }
      if (ep != null) {
        evtParams.newEndpoint = ep;
        oldEndpoint.detachFromConnection(c);
        c.endpoints[idx] = ep;
        c[_st.el] = ep.element;
        c[_st.elId] = ep.elementId;
        evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;
        this.fireMoveEvent(evtParams);
        this.paintConnection(c);
      }
      return evtParams;
    }
  }, {
    key: "setSource",
    value: function setSource(connection, el) {
      removeManagedConnection(connection, this._managedElements[connection.sourceId]);
      var p = this._set(connection, el, 0);
      addManagedConnection(connection, this._managedElements[p.newSourceId]);
    }
  }, {
    key: "setTarget",
    value: function setTarget(connection, el) {
      removeManagedConnection(connection, this._managedElements[connection.targetId]);
      var p = this._set(connection, el, 1);
      addManagedConnection(connection, this._managedElements[p.newTargetId]);
    }
  }, {
    key: "isHoverSuspended",
    value: function isHoverSuspended() {
      return this.hoverSuspended;
    }
  }, {
    key: "setSuspendDrawing",
    value: function setSuspendDrawing(val, repaintAfterwards) {
      var curVal = this._suspendDrawing;
      this._suspendDrawing = val;
      if (val) {
        this._suspendedAt = "" + new Date().getTime();
      } else {
        this._suspendedAt = null;
        this.viewport.recomputeBounds();
      }
      if (repaintAfterwards) {
        this.repaintEverything();
      }
      return curVal;
    }
  }, {
    key: "getSuspendedAt",
    value: function getSuspendedAt() {
      return this._suspendedAt;
    }
  }, {
    key: "batch",
    value: function batch(fn, doNotRepaintAfterwards) {
      var _wasSuspended = this._suspendDrawing === true;
      if (!_wasSuspended) {
        this.setSuspendDrawing(true);
      }
      fn();
      if (!_wasSuspended) {
        this.setSuspendDrawing(false, !doNotRepaintAfterwards);
      }
    }
  }, {
    key: "each",
    value: function each(spec, fn) {
      if (spec == null) {
        return;
      }
      if (spec.length != null) {
        for (var i = 0; i < spec.length; i++) {
          fn(spec[i]);
        }
      } else {
        fn(spec);
      }
      return this;
    }
  }, {
    key: "updateOffset",
    value: function updateOffset(params) {
      var elId = params.elId;
      if (params.recalc) {
        return this.viewport.refreshElement(elId);
      } else {
        return this.viewport.getPosition(elId);
      }
    }
  }, {
    key: "deleteConnection",
    value: function deleteConnection(connection, params) {
      if (connection != null && connection.deleted !== true) {
        params = params || {};
        if (params.force || functionChain(true, false, [[connection.endpoints[0], IS_DETACH_ALLOWED, [connection]], [connection.endpoints[1], IS_DETACH_ALLOWED, [connection]], [connection, IS_DETACH_ALLOWED, [connection]], [this, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, connection]]])) {
          removeManagedConnection(connection, this._managedElements[connection.sourceId], this._managedElements[connection.targetId]);
          this.fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);
          var sourceEndpoint = connection.endpoints[0];
          var targetEndpoint = connection.endpoints[1];
          if (sourceEndpoint !== params.endpointToIgnore) {
            sourceEndpoint.detachFromConnection(connection, null, true);
          }
          if (targetEndpoint !== params.endpointToIgnore) {
            targetEndpoint.detachFromConnection(connection, null, true);
          }
          removeWithFunction(this.connections, function (_c) {
            return connection.id === _c.id;
          });
          connection.destroy();
          if (sourceEndpoint !== params.endpointToIgnore && sourceEndpoint.deleteOnEmpty && sourceEndpoint.connections.length === 0) {
            this.deleteEndpoint(sourceEndpoint);
          }
          if (targetEndpoint !== params.endpointToIgnore && targetEndpoint.deleteOnEmpty && targetEndpoint.connections.length === 0) {
            this.deleteEndpoint(targetEndpoint);
          }
          return true;
        }
      }
      return false;
    }
  }, {
    key: "deleteEveryConnection",
    value: function deleteEveryConnection(params) {
      var _this2 = this;
      params = params || {};
      var count = this.connections.length,
          deletedCount = 0;
      this.batch(function () {
        for (var i = 0; i < count; i++) {
          deletedCount += _this2.deleteConnection(_this2.connections[0], params) ? 1 : 0;
        }
      });
      return deletedCount;
    }
  }, {
    key: "deleteConnectionsForElement",
    value: function deleteConnectionsForElement(el, params) {
      var id = this.getId(el),
          m = this._managedElements[id];
      if (m) {
        var l = m.connections.length;
        for (var i = 0; i < l; i++) {
          this.deleteConnection(m.connections[0], params);
        }
      }
      return this;
    }
  }, {
    key: "fireDetachEvent",
    value: function fireDetachEvent(jpc, doFireEvent, originalEvent) {
      var argIsConnection = jpc.id != null,
          params = argIsConnection ? {
        connection: jpc,
        source: jpc.source,
        target: jpc.target,
        sourceId: jpc.sourceId,
        targetId: jpc.targetId,
        sourceEndpoint: jpc.endpoints[0],
        targetEndpoint: jpc.endpoints[1]
      } : jpc;
      if (doFireEvent) {
        this.fire(EVENT_CONNECTION_DETACHED, params, originalEvent);
      }
      this.fire(EVENT_INTERNAL_CONNECTION_DETACHED, params, originalEvent);
    }
  }, {
    key: "fireMoveEvent",
    value: function fireMoveEvent(params, evt) {
      this.fire(EVENT_CONNECTION_MOVED, params, evt);
    }
  }, {
    key: "manageAll",
    value: function manageAll(elements, recalc) {
      var nl = isString(elements) ? this.getSelector(this.getContainer(), elements) : elements;
      for (var i = 0; i < nl.length; i++) {
        this.manage(nl[i], null, recalc);
      }
    }
  }, {
    key: "manage",
    value: function manage(element, internalId, _recalc) {
      if (this.getAttribute(element, ATTRIBUTE_MANAGED) == null) {
        internalId = internalId || this.getAttribute(element, "id") || jsplumb_util_es_uuid();
        this.setAttribute(element, ATTRIBUTE_MANAGED, internalId);
      }
      var elId = this.getId(element);
      if (!this._managedElements[elId]) {
        var obj = {
          el: element,
          endpoints: [],
          connections: [],
          rotation: 0
        };
        this._managedElements[elId] = obj;
        if (this._suspendDrawing) {
          obj.viewportElement = this.viewport.registerElement(elId, true);
        } else {
          obj.viewportElement = this.updateOffset({
            elId: elId,
            recalc: true
          });
        }
        this.fire(EVENT_MANAGE_ELEMENT, {
          el: element
        });
      } else {
        if (_recalc) {
          this._managedElements[elId].viewportElement = this.updateOffset({
            elId: elId,
            timestamp: null,
            recalc: true
          });
        }
      }
      return this._managedElements[elId];
    }
  }, {
    key: "getManagedElement",
    value: function getManagedElement(id) {
      return this._managedElements[id] ? this._managedElements[id].el : null;
    }
  }, {
    key: "unmanage",
    value: function unmanage(el, removeElement) {
      var _this3 = this;
      this.removeAllEndpoints(el, true);
      var _one = function _one(_el) {
        var id = _this3.getId(_el);
        _this3.removeAttribute(_el, ATTRIBUTE_MANAGED);
        delete _this3._managedElements[id];
        _this3.viewport.remove(id);
        _this3.fire(EVENT_UNMANAGE_ELEMENT, {
          el: _el
        });
        if (_el && removeElement) {
          _this3._removeElement(_el);
        }
      };
      this._getAssociatedElements(el).map(_one);
      _one(el);
    }
  }, {
    key: "rotate",
    value: function rotate(element, rotation, _doNotRepaint) {
      var elementId = this.getId(element);
      if (this._managedElements[elementId]) {
        this._managedElements[elementId].rotation = rotation;
        this.viewport.rotateElement(elementId, rotation);
        if (_doNotRepaint !== true) {
          return this.revalidate(element);
        }
      }
      return {
        c: new Set(),
        e: new Set()
      };
    }
  }, {
    key: "_getRotation",
    value: function _getRotation(elementId) {
      var entry = this._managedElements[elementId];
      if (entry != null) {
        return entry.rotation || 0;
      } else {
        return 0;
      }
    }
  }, {
    key: "_getRotations",
    value: function _getRotations(elementId) {
      var _this4 = this;
      var rotations = [];
      var entry = this._managedElements[elementId];
      var _oneLevel = function _oneLevel(e) {
        if (e.group != null) {
          var gEntry = _this4._managedElements[e.group];
          if (gEntry != null) {
            rotations.push({
              r: gEntry.viewportElement.r,
              c: gEntry.viewportElement.c
            });
            _oneLevel(gEntry);
          }
        }
      };
      if (entry != null) {
        rotations.push({
          r: entry.viewportElement.r || 0,
          c: entry.viewportElement.c
        });
        _oneLevel(entry);
      }
      return rotations;
    }
  }, {
    key: "_applyRotations",
    value: function _applyRotations(point, rotations) {
      var sl = point.slice();
      var current = {
        x: sl[0],
        y: sl[1],
        cr: 0,
        sr: 0
      };
      forEach(rotations, function (rotation) {
        current = rotatePoint(current, rotation.c, rotation.r);
      });
      return current;
    }
  }, {
    key: "_applyRotationsXY",
    value: function _applyRotationsXY(point, rotations) {
      forEach(rotations, function (rotation) {
        point = rotatePoint(point, rotation.c, rotation.r);
      });
      return point;
    }
  }, {
    key: "_internal_newEndpoint",
    value: function _internal_newEndpoint(params) {
      var _p = extend({}, params);
      var managedElement = this.manage(_p.element);
      _p.elementId = this.getId(_p.element);
      _p.id = "ep_" + this._idstamp();
      var ep = new jsplumb_core_es_Endpoint(this, _p);
      addManagedEndpoint(managedElement, ep);
      if (params.uuid) {
        this.endpointsByUUID.set(params.uuid, ep);
      }
      addToDictionary(this.endpointsByElement, ep.elementId, ep);
      if (!this._suspendDrawing) {
        this.paintEndpoint(ep, {
          timestamp: this._suspendedAt
        });
      }
      return ep;
    }
  }, {
    key: "_deriveEndpointAndAnchorSpec",
    value: function _deriveEndpointAndAnchorSpec(type, dontPrependDefault) {
      var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/),
          eps = null,
          ep = null,
          a = null,
          as = null;
      for (var i = 0; i < bits.length; i++) {
        var _t = this.getConnectionType(bits[i]);
        if (_t) {
          if (_t.endpoints) {
            eps = _t.endpoints;
          }
          if (_t.endpoint) {
            ep = _t.endpoint;
          }
          if (_t.anchors) {
            as = _t.anchors;
          }
          if (_t.anchor) {
            a = _t.anchor;
          }
        }
      }
      return {
        endpoints: eps ? eps : [ep, ep],
        anchors: as ? as : [a, a]
      };
    }
  }, {
    key: "revalidate",
    value: function revalidate(el, timestamp) {
      var elId = this.getId(el);
      this.updateOffset({
        elId: elId,
        recalc: true,
        timestamp: timestamp
      });
      return this.repaint(el);
    }
  }, {
    key: "repaintEverything",
    value: function repaintEverything() {
      var timestamp = jsplumb_util_es_uuid(),
          elId;
      for (elId in this._managedElements) {
        this.viewport.refreshElement(elId, true);
      }
      this.viewport.recomputeBounds();
      for (elId in this._managedElements) {
        this.repaint(this._managedElements[elId].el, timestamp, true);
      }
      return this;
    }
  }, {
    key: "setElementPosition",
    value: function setElementPosition(el, x, y) {
      var id = this.getId(el);
      this.viewport.setPosition(id, x, y);
      return this.repaint(el);
    }
  }, {
    key: "repaint",
    value: function repaint(el, timestamp, offsetsWereJustCalculated) {
      var r = {
        c: new Set(),
        e: new Set()
      };
      var _mergeRedraw = function _mergeRedraw(r2) {
        r2.c.forEach(function (c) {
          return r.c.add(c);
        });
        r2.e.forEach(function (e) {
          return r.e.add(e);
        });
      };
      if (!this._suspendDrawing) {
        var id = this.getId(el);
        if (el != null) {
          var repaintEls = this._getAssociatedElements(el);
          if (timestamp == null) {
            timestamp = jsplumb_util_es_uuid();
          }
          if (!offsetsWereJustCalculated) {
            for (var i = 0; i < repaintEls.length; i++) {
              this.updateOffset({
                elId: this.getId(repaintEls[i]),
                recalc: true,
                timestamp: timestamp
              });
            }
          }
          _mergeRedraw(this.router.redraw(id, timestamp, null));
          if (repaintEls.length > 0) {
            for (var j = 0; j < repaintEls.length; j++) {
              _mergeRedraw(this.router.redraw(this.getId(repaintEls[j]), timestamp, null));
            }
          }
        }
      }
      return r;
    }
  }, {
    key: "unregisterEndpoint",
    value: function unregisterEndpoint(endpoint) {
      var uuid = endpoint.getUuid();
      if (uuid) {
        this.endpointsByUUID["delete"](uuid);
      }
      removeManagedEndpoint(this._managedElements[endpoint.elementId], endpoint);
      for (var _e in this.endpointsByElement) {
        var endpoints = this.endpointsByElement[_e];
        if (endpoints) {
          var newEndpoints = [];
          for (var i = 0, j = endpoints.length; i < j; i++) {
            if (endpoints[i] !== endpoint) {
              newEndpoints.push(endpoints[i]);
            }
          }
          this.endpointsByElement[_e] = newEndpoints;
        }
        if (this.endpointsByElement[_e].length < 1) {
          delete this.endpointsByElement[_e];
        }
      }
      this.fire(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, endpoint);
    }
  }, {
    key: "_maybePruneEndpoint",
    value: function _maybePruneEndpoint(endpoint) {
      if (endpoint.deleteOnEmpty && endpoint.connections.length === 0) {
        this.deleteEndpoint(endpoint);
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "deleteEndpoint",
    value: function deleteEndpoint(object) {
      var _this5 = this;
      var endpoint = typeof object === "string" ? this.endpointsByUUID.get(object) : object;
      if (endpoint) {
        var proxy = endpoint.proxiedBy;
        var connectionsToDelete = endpoint.connections.slice();
        forEach(connectionsToDelete, function (connection) {
          endpoint.detachFromConnection(connection, null, true);
        });
        this.unregisterEndpoint(endpoint);
        endpoint.destroy();
        forEach(connectionsToDelete, function (connection) {
          _this5.deleteConnection(connection, {
            force: true,
            endpointToIgnore: endpoint
          });
        });
        if (proxy != null) {
          this.deleteEndpoint(proxy);
        }
      }
      return this;
    }
  }, {
    key: "addEndpoint",
    value: function addEndpoint(el, params, referenceParams) {
      referenceParams = referenceParams || {};
      var p = extend({}, referenceParams);
      extend(p, params || {});
      var _p = extend({
        element: el
      }, p);
      return this._internal_newEndpoint(_p);
    }
  }, {
    key: "addEndpoints",
    value: function addEndpoints(el, endpoints, referenceParams) {
      var results = [];
      for (var i = 0, j = endpoints.length; i < j; i++) {
        results.push(this.addEndpoint(el, endpoints[i], referenceParams));
      }
      return results;
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this6 = this;
      this.silently(function () {
        _this6.endpointsByElement = {};
        _this6._managedElements = {};
        _this6.endpointsByUUID.clear();
        _this6.viewport.reset();
        _this6.router.reset();
        _this6.groupManager.reset();
        _this6.connections.length = 0;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.reset();
      this.unbind();
      this.sourceSelectors.length = 0;
      this.targetSelectors.length = 0;
      this._connectionTypes.clear();
      this._endpointTypes.clear();
    }
  }, {
    key: "getEndpoints",
    value: function getEndpoints(el) {
      return this.endpointsByElement[this.getId(el)] || [];
    }
  }, {
    key: "getEndpoint",
    value: function getEndpoint(uuid) {
      return this.endpointsByUUID.get(uuid);
    }
  }, {
    key: "setEndpointUuid",
    value: function setEndpointUuid(endpoint, uuid) {
      if (endpoint.uuid) {
        this.endpointsByUUID["delete"](endpoint.uuid);
      }
      endpoint.uuid = uuid;
      this.endpointsByUUID.set(uuid, endpoint);
    }
  }, {
    key: "connect",
    value: function connect(params, referenceParams) {
      try {
        var _p = this._prepareConnectionParams(params, referenceParams),
            jpc = this._newConnection(_p);
        this._finaliseConnection(jpc, _p);
        return jpc;
      } catch (errorMessage) {
        log(errorMessage);
        return;
      }
    }
  }, {
    key: "_prepareConnectionParams",
    value: function _prepareConnectionParams(params, referenceParams) {
      var temp = extend({}, params);
      if (referenceParams) {
        extend(temp, referenceParams);
      }
      var _p = temp;
      if (_p.source) {
        if (_p.source.endpoint) {
          _p.sourceEndpoint = _p.source;
        }
      }
      if (_p.target) {
        if (_p.target.endpoint) {
          _p.targetEndpoint = _p.target;
        }
      }
      if (params.uuids) {
        _p.sourceEndpoint = this.getEndpoint(params.uuids[0]);
        _p.targetEndpoint = this.getEndpoint(params.uuids[1]);
      }
      if (_p.sourceEndpoint != null) {
        if (_p.sourceEndpoint.isFull()) {
          throw ERROR_SOURCE_ENDPOINT_FULL;
        }
        if (!_p.type) {
          _p.type = _p.sourceEndpoint.edgeType;
        }
        if (_p.sourceEndpoint.connectorOverlays) {
          _p.overlays = _p.overlays || [];
          for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
            _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
          }
        }
        if (_p.sourceEndpoint.scope) {
          _p.scope = _p.sourceEndpoint.scope;
        }
      } else {
        if (_p.source == null) {
          throw ERROR_SOURCE_DOES_NOT_EXIST;
        }
      }
      if (_p.targetEndpoint != null) {
        if (_p.targetEndpoint.isFull()) {
          throw ERROR_TARGET_ENDPOINT_FULL;
        }
      } else {
        if (_p.target == null) {
          throw ERROR_TARGET_DOES_NOT_EXIST;
        }
      }
      if (_p.sourceEndpoint && _p.targetEndpoint) {
        if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) {
          throw "Cannot establish connection: scopes do not match";
        }
      }
      return _p;
    }
  }, {
    key: "_newConnection",
    value: function _newConnection(params) {
      params.id = "con_" + this._idstamp();
      var c = new jsplumb_core_es_Connection(this, params);
      addManagedConnection(c, this._managedElements[c.sourceId], this._managedElements[c.targetId]);
      this.paintConnection(c);
      return c;
    }
  }, {
    key: "_finaliseConnection",
    value: function _finaliseConnection(jpc, params, originalEvent) {
      params = params || {};
      if (!jpc.suspendedEndpoint) {
        this.connections.push(jpc);
      }
      jpc.pending = null;
      jpc.endpoints[0].isTemporarySource = false;
      this.repaint(jpc.source);
      var payload = {
        connection: jpc,
        source: jpc.source,
        target: jpc.target,
        sourceId: jpc.sourceId,
        targetId: jpc.targetId,
        sourceEndpoint: jpc.endpoints[0],
        targetEndpoint: jpc.endpoints[1]
      };
      this.fire(EVENT_INTERNAL_CONNECTION, payload, originalEvent);
      if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
        this.fire(EVENT_CONNECTION, payload, originalEvent);
      }
    }
  }, {
    key: "removeAllEndpoints",
    value: function removeAllEndpoints(el, recurse) {
      var _this7 = this;
      var _one = function _one(_el) {
        var id = _this7.getId(_el),
            ebe = _this7.endpointsByElement[id],
            i,
            ii;
        if (ebe) {
          for (i = 0, ii = ebe.length; i < ii; i++) {
            _this7.deleteEndpoint(ebe[i]);
          }
        }
        delete _this7.endpointsByElement[id];
      };
      if (recurse) {
        this._getAssociatedElements(el).map(_one);
      }
      _one(el);
      return this;
    }
  }, {
    key: "_createSourceDefinition",
    value: function _createSourceDefinition(params, referenceParams) {
      var p = extend({}, referenceParams);
      extend(p, params);
      p.edgeType = p.edgeType || DEFAULT;
      var aae = this._deriveEndpointAndAnchorSpec(p.edgeType);
      p.endpoint = p.endpoint || aae.endpoints[0];
      p.anchor = p.anchor || aae.anchors[0];
      var maxConnections = p.maxConnections || -1;
      var _def = {
        def: extend({}, p),
        uniqueEndpoint: p.uniqueEndpoint,
        maxConnections: maxConnections,
        enabled: true,
        endpoint: null
      };
      return _def;
    }
  }, {
    key: "addSourceSelector",
    value: function addSourceSelector(selector, params) {
      var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _def = this._createSourceDefinition(params);
      var sel = new SourceSelector(selector, _def, exclude);
      this.sourceSelectors.push(sel);
      return sel;
    }
  }, {
    key: "removeSourceSelector",
    value: function removeSourceSelector(selector) {
      removeWithFunction(this.sourceSelectors, function (s) {
        return s === selector;
      });
    }
  }, {
    key: "removeTargetSelector",
    value: function removeTargetSelector(selector) {
      removeWithFunction(this.targetSelectors, function (s) {
        return s === selector;
      });
    }
  }, {
    key: "addTargetSelector",
    value: function addTargetSelector(selector, params) {
      var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _def = this._createTargetDefinition(params);
      var sel = new TargetSelector(selector, _def, exclude);
      this.targetSelectors.push(sel);
      return sel;
    }
  }, {
    key: "_createTargetDefinition",
    value: function _createTargetDefinition(params, referenceParams) {
      var p = extend({}, referenceParams);
      extend(p, params);
      p.edgeType = p.edgeType || DEFAULT;
      var maxConnections = p.maxConnections || -1;
      var _def = {
        def: extend({}, p),
        uniqueEndpoint: p.uniqueEndpoint,
        maxConnections: maxConnections,
        enabled: true,
        endpoint: null
      };
      return _def;
    }
  }, {
    key: "show",
    value: function show(el, changeEndpoints) {
      return this._setVisible(el, BLOCK, changeEndpoints);
    }
  }, {
    key: "hide",
    value: function hide(el, changeEndpoints) {
      return this._setVisible(el, NONE, changeEndpoints);
    }
  }, {
    key: "_setVisible",
    value: function _setVisible(el, state, alsoChangeEndpoints) {
      var visible = state === BLOCK;
      var endpointFunc = null;
      if (alsoChangeEndpoints) {
        endpointFunc = function endpointFunc(ep) {
          ep.setVisible(visible, true, true);
        };
      }
      var id = this.getId(el);
      this._operation(el, function (jpc) {
        if (visible && alsoChangeEndpoints) {
          var oidx = jpc.sourceId === id ? 1 : 0;
          if (jpc.endpoints[oidx].isVisible()) {
            jpc.setVisible(true);
          }
        } else {
          jpc.setVisible(visible);
        }
      }, endpointFunc);
      return this;
    }
  }, {
    key: "toggleVisible",
    value: function toggleVisible(el, changeEndpoints) {
      var endpointFunc = null;
      if (changeEndpoints) {
        endpointFunc = function endpointFunc(ep) {
          var state = ep.isVisible();
          ep.setVisible(!state);
        };
      }
      this._operation(el, function (jpc) {
        var state = jpc.isVisible();
        jpc.setVisible(!state);
      }, endpointFunc);
    }
  }, {
    key: "_operation",
    value: function _operation(el, func, endpointFunc) {
      var elId = this.getId(el);
      var endpoints = this.endpointsByElement[elId];
      if (endpoints && endpoints.length) {
        for (var i = 0, ii = endpoints.length; i < ii; i++) {
          for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
            var retVal = func(endpoints[i].connections[j]);
            if (retVal) {
              return;
            }
          }
          if (endpointFunc) {
            endpointFunc(endpoints[i]);
          }
        }
      }
    }
  }, {
    key: "registerConnectionType",
    value: function registerConnectionType(id, type) {
      this._connectionTypes.set(id, extend({}, type));
      if (type.overlays) {
        var to = {};
        for (var i = 0; i < type.overlays.length; i++) {
          var fo = convertToFullOverlaySpec(type.overlays[i]);
          to[fo.options.id] = fo;
        }
        this._connectionTypes.get(id).overlays = to;
      }
    }
  }, {
    key: "registerConnectionTypes",
    value: function registerConnectionTypes(types) {
      for (var i in types) {
        this.registerConnectionType(i, types[i]);
      }
    }
  }, {
    key: "registerEndpointType",
    value: function registerEndpointType(id, type) {
      this._endpointTypes.set(id, extend({}, type));
      if (type.overlays) {
        var to = {};
        for (var i = 0; i < type.overlays.length; i++) {
          var fo = convertToFullOverlaySpec(type.overlays[i]);
          to[fo.options.id] = fo;
        }
        this._endpointTypes.get(id).overlays = to;
      }
    }
  }, {
    key: "registerEndpointTypes",
    value: function registerEndpointTypes(types) {
      for (var i in types) {
        this.registerEndpointType(i, types[i]);
      }
    }
  }, {
    key: "getType",
    value: function getType(id, typeDescriptor) {
      return typeDescriptor === "connection" ? this.getConnectionType(id) : this.getEndpointType(id);
    }
  }, {
    key: "getConnectionType",
    value: function getConnectionType(id) {
      return this._connectionTypes.get(id);
    }
  }, {
    key: "getEndpointType",
    value: function getEndpointType(id) {
      return this._endpointTypes.get(id);
    }
  }, {
    key: "importDefaults",
    value: function importDefaults(d) {
      for (var i in d) {
        this.defaults[i] = d[i];
      }
      if (d.container) {
        this.setContainer(d.container);
      }
      return this;
    }
  }, {
    key: "restoreDefaults",
    value: function restoreDefaults() {
      this.defaults = extend({}, this._initialDefaults);
      return this;
    }
  }, {
    key: "getManagedElements",
    value: function getManagedElements() {
      return this._managedElements;
    }
  }, {
    key: "proxyConnection",
    value: function proxyConnection(connection, index, proxyEl, endpointGenerator, anchorGenerator) {
      var alreadyProxied = connection.proxies[index] != null,
          proxyEp,
          originalElementId = alreadyProxied ? connection.proxies[index].originalEp.elementId : connection.endpoints[index].elementId,
          originalEndpoint = alreadyProxied ? connection.proxies[index].originalEp : connection.endpoints[index],
          proxyElId = this.getId(proxyEl);
      if (connection.proxies[index]) {
        if (connection.proxies[index].ep.elementId === proxyElId) {
          proxyEp = connection.proxies[index].ep;
        } else {
          connection.proxies[index].ep.detachFromConnection(connection, index);
          proxyEp = this._internal_newEndpoint({
            element: proxyEl,
            endpoint: endpointGenerator(connection, index),
            anchor: anchorGenerator(connection, index),
            parameters: {
              isProxyEndpoint: true
            }
          });
        }
      } else {
        proxyEp = this._internal_newEndpoint({
          element: proxyEl,
          endpoint: endpointGenerator(connection, index),
          anchor: anchorGenerator(connection, index),
          parameters: {
            isProxyEndpoint: true
          }
        });
      }
      proxyEp.deleteOnEmpty = true;
      connection.proxies[index] = {
        ep: proxyEp,
        originalEp: originalEndpoint
      };
      this.sourceOrTargetChanged(originalElementId, proxyElId, connection, proxyEl, index);
      originalEndpoint.detachFromConnection(connection, null, true);
      proxyEp.connections = [connection];
      connection.endpoints[index] = proxyEp;
      originalEndpoint.proxiedBy = proxyEp;
      originalEndpoint.setVisible(false);
      connection.setVisible(true);
      this.revalidate(proxyEl);
    }
  }, {
    key: "unproxyConnection",
    value: function unproxyConnection(connection, index) {
      if (connection.proxies == null || connection.proxies[index] == null) {
        return;
      }
      var originalElement = connection.proxies[index].originalEp.element,
          originalElementId = connection.proxies[index].originalEp.elementId,
          proxyElId = connection.proxies[index].ep.elementId;
      connection.endpoints[index] = connection.proxies[index].originalEp;
      delete connection.proxies[index].originalEp.proxiedBy;
      this.sourceOrTargetChanged(proxyElId, originalElementId, connection, originalElement, index);
      connection.proxies[index].ep.detachFromConnection(connection, null);
      connection.proxies[index].originalEp.addConnection(connection);
      if (connection.isVisible()) {
        connection.proxies[index].originalEp.setVisible(true);
      }
      connection.proxies[index] = null;
      if (findWithFunction(connection.proxies, function (p) {
        return p != null;
      }) === -1) {
        connection.proxies.length = 0;
      }
    }
  }, {
    key: "sourceOrTargetChanged",
    value: function sourceOrTargetChanged(originalId, newId, connection, newElement, index) {
      if (originalId !== newId) {
        if (index === 0) {
          connection.sourceId = newId;
          connection.source = newElement;
        } else if (index === 1) {
          connection.targetId = newId;
          connection.target = newElement;
        }
        removeManagedConnection(connection, this._managedElements[originalId]);
        addManagedConnection(connection, this._managedElements[newId]);
      }
    }
  }, {
    key: "getGroup",
    value: function getGroup(groupId) {
      return this.groupManager.getGroup(groupId);
    }
  }, {
    key: "getGroupFor",
    value: function getGroupFor(el) {
      return this.groupManager.getGroupFor(el);
    }
  }, {
    key: "addGroup",
    value: function addGroup(params) {
      return this.groupManager.addGroup(params);
    }
  }, {
    key: "addToGroup",
    value: function addToGroup(group) {
      var _this$groupManager;
      for (var _len = arguments.length, el = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        el[_key - 1] = arguments[_key];
      }
      return (_this$groupManager = this.groupManager).addToGroup.apply(_this$groupManager, [group, false].concat(el));
    }
  }, {
    key: "collapseGroup",
    value: function collapseGroup(group) {
      this.groupManager.collapseGroup(group);
    }
  }, {
    key: "expandGroup",
    value: function expandGroup(group) {
      this.groupManager.expandGroup(group);
    }
  }, {
    key: "toggleGroup",
    value: function toggleGroup(group) {
      this.groupManager.toggleGroup(group);
    }
  }, {
    key: "removeGroup",
    value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
      return this.groupManager.removeGroup(group, deleteMembers, manipulateView, doNotFireEvent);
    }
  }, {
    key: "removeAllGroups",
    value: function removeAllGroups(deleteMembers, manipulateView) {
      this.groupManager.removeAllGroups(deleteMembers, manipulateView, false);
    }
  }, {
    key: "removeFromGroup",
    value: function removeFromGroup(group, el, doNotFireEvent) {
      this.groupManager.removeFromGroup(group, doNotFireEvent, el);
      this._appendElement(el, this.getContainer());
      this.updateOffset({
        recalc: true,
        elId: this.getId(el)
      });
    }
  }, {
    key: "paintEndpoint",
    value: function paintEndpoint(endpoint, params) {
      function findConnectionToUseForDynamicAnchor(ep) {
        var idx = 0;
        if (params.elementWithPrecedence != null) {
          for (var i = 0; i < ep.connections.length; i++) {
            if (ep.connections[i].sourceId === params.elementWithPrecedence || ep.connections[i].targetId === params.elementWithPrecedence) {
              idx = i;
              break;
            }
          }
        }
        return ep.connections[idx];
      }
      params = params || {};
      var timestamp = params.timestamp,
          recalc = !(params.recalc === false);
      if (!timestamp || endpoint.timestamp !== timestamp) {
        var info = this.viewport.getPosition(endpoint.elementId);
        var xy = params.offset ? {
          x: params.offset.x,
          y: params.offset.y
        } : {
          x: info.x,
          y: info.y
        };
        if (xy != null) {
          var ap = params.anchorLoc;
          if (ap == null) {
            var anchorParams = {
              xy: xy,
              wh: info,
              element: endpoint,
              timestamp: timestamp
            };
            if (recalc && this.router.isDynamicAnchor(endpoint) && endpoint.connections.length > 0) {
              var _c3 = findConnectionToUseForDynamicAnchor(endpoint),
                  oIdx = _c3.endpoints[0] === endpoint ? 1 : 0,
                  oId = oIdx === 0 ? _c3.sourceId : _c3.targetId,
                  oInfo = this.viewport.getPosition(oId);
              anchorParams.index = oIdx === 0 ? 1 : 0;
              anchorParams.connection = _c3;
              anchorParams.txy = oInfo;
              anchorParams.twh = oInfo;
              anchorParams.tElement = _c3.endpoints[oIdx];
              anchorParams.tRotation = this._getRotations(oId);
            } else if (endpoint.connections.length > 0) {
              anchorParams.connection = endpoint.connections[0];
            }
            anchorParams.rotation = this._getRotations(endpoint.elementId);
            ap = this.router.computeAnchorLocation(endpoint._anchor, anchorParams);
          }
          endpoint.endpoint.compute(ap, this.router.getEndpointOrientation(endpoint), endpoint.paintStyleInUse);
          this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
          endpoint.timestamp = timestamp;
          for (var i in endpoint.overlays) {
            if (endpoint.overlays.hasOwnProperty(i)) {
              var _o = endpoint.overlays[i];
              if (_o.isVisible()) {
                endpoint.overlayPlacements[i] = this.drawOverlay(_o, endpoint.endpoint, endpoint.paintStyleInUse, endpoint.getAbsoluteOverlayPosition(_o));
                this.paintOverlay(_o, endpoint.overlayPlacements[i], {
                  xmin: 0,
                  ymin: 0
                });
              }
            }
          }
        }
      }
    }
  }, {
    key: "paintConnection",
    value: function paintConnection(connection, params) {
      if (!this._suspendDrawing && connection.visible !== false) {
        params = params || {};
        var timestamp = params.timestamp;
        if (timestamp != null && timestamp === connection.lastPaintedAt) {
          return;
        }
        if (timestamp == null || timestamp !== connection.lastPaintedAt) {
          this.router.computePath(connection, timestamp);
          var overlayExtents = {
            xmin: Infinity,
            ymin: Infinity,
            xmax: -Infinity,
            ymax: -Infinity
          };
          for (var i in connection.overlays) {
            if (connection.overlays.hasOwnProperty(i)) {
              var _o2 = connection.overlays[i];
              if (_o2.isVisible()) {
                connection.overlayPlacements[i] = this.drawOverlay(_o2, connection.connector, connection.paintStyleInUse, connection.getAbsoluteOverlayPosition(_o2));
                overlayExtents.xmin = Math.min(overlayExtents.xmin, connection.overlayPlacements[i].xmin);
                overlayExtents.xmax = Math.max(overlayExtents.xmax, connection.overlayPlacements[i].xmax);
                overlayExtents.ymin = Math.min(overlayExtents.ymin, connection.overlayPlacements[i].ymin);
                overlayExtents.ymax = Math.max(overlayExtents.ymax, connection.overlayPlacements[i].ymax);
              }
            }
          }
          var lineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "1") / 2,
              outlineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "0"),
              _extents = {
            xmin: Math.min(connection.connector.bounds.xmin - (lineWidth + outlineWidth), overlayExtents.xmin),
            ymin: Math.min(connection.connector.bounds.ymin - (lineWidth + outlineWidth), overlayExtents.ymin),
            xmax: Math.max(connection.connector.bounds.xmax + (lineWidth + outlineWidth), overlayExtents.xmax),
            ymax: Math.max(connection.connector.bounds.ymax + (lineWidth + outlineWidth), overlayExtents.ymax)
          };
          this.paintConnector(connection.connector, connection.paintStyleInUse, _extents);
          for (var j in connection.overlays) {
            if (connection.overlays.hasOwnProperty(j)) {
              var _p2 = connection.overlays[j];
              if (_p2.isVisible()) {
                this.paintOverlay(_p2, connection.overlayPlacements[j], _extents);
              }
            }
          }
        }
        connection.lastPaintedAt = timestamp;
      }
    }
  }, {
    key: "refreshEndpoint",
    value: function refreshEndpoint(endpoint) {
      if (endpoint.connections.length > 0) {
        this.addEndpointClass(endpoint, this.endpointConnectedClass);
      } else {
        this.removeEndpointClass(endpoint, this.endpointConnectedClass);
      }
      if (endpoint.isFull()) {
        this.addEndpointClass(endpoint, this.endpointFullClass);
      } else {
        this.removeEndpointClass(endpoint, this.endpointFullClass);
      }
    }
  }, {
    key: "makeConnector",
    value: function makeConnector(connection, name, args) {
      return Connectors.get(connection, name, args);
    }
  }, {
    key: "getPathData",
    value: function getPathData(connector) {
      var p = "";
      for (var i = 0; i < connector.segments.length; i++) {
        p += connector.segments[i].getPath(i === 0);
        p += " ";
      }
      return p;
    }
  }]);
  return JsPlumbInstance;
}(EventGenerator);

var VERY_SMALL_VALUE = 0.0000000001;
function gentleRound(n) {
  var f = Math.floor(n),
      r = Math.ceil(n);
  if (n - f < VERY_SMALL_VALUE) {
    return f;
  } else if (r - n < VERY_SMALL_VALUE) {
    return r;
  }
  return n;
}
var jsplumb_core_es_ArcSegment = function (_AbstractSegment) {
  jsplumb_core_es_inherits(ArcSegment, _AbstractSegment);
  var _super = jsplumb_core_es_createSuper(ArcSegment);
  function ArcSegment(params) {
    var _this;
    jsplumb_core_es_classCallCheck(this, ArcSegment);
    _this = _super.call(this, params);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", ArcSegment.segmentType);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cx", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cy", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "radius", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "anticlockwise", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "startAngle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "endAngle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "sweep", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "length", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "circumference", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "frac", void 0);
    _this.cx = params.cx;
    _this.cy = params.cy;
    _this.radius = params.r;
    _this.anticlockwise = params.ac;
    if (params.startAngle && params.endAngle) {
      _this.startAngle = params.startAngle;
      _this.endAngle = params.endAngle;
      _this.x1 = _this.cx + _this.radius * Math.cos(_this.startAngle);
      _this.y1 = _this.cy + _this.radius * Math.sin(_this.startAngle);
      _this.x2 = _this.cx + _this.radius * Math.cos(_this.endAngle);
      _this.y2 = _this.cy + _this.radius * Math.sin(_this.endAngle);
    } else {
      _this.startAngle = _this._calcAngle(_this.x1, _this.y1);
      _this.endAngle = _this._calcAngle(_this.x2, _this.y2);
    }
    if (_this.endAngle < 0) {
      _this.endAngle += TWO_PI;
    }
    if (_this.startAngle < 0) {
      _this.startAngle += TWO_PI;
    }
    var ea = _this.endAngle < _this.startAngle ? _this.endAngle + TWO_PI : _this.endAngle;
    _this.sweep = Math.abs(ea - _this.startAngle);
    if (_this.anticlockwise) {
      _this.sweep = TWO_PI - _this.sweep;
    }
    _this.circumference = 2 * Math.PI * _this.radius;
    _this.frac = _this.sweep / TWO_PI;
    _this.length = _this.circumference * _this.frac;
    _this.extents = {
      xmin: _this.cx - _this.radius,
      xmax: _this.cx + _this.radius,
      ymin: _this.cy - _this.radius,
      ymax: _this.cy + _this.radius
    };
    return _this;
  }
  jsplumb_core_es_createClass(ArcSegment, [{
    key: "_calcAngle",
    value: function _calcAngle(_x, _y) {
      return jsplumb_util_es_theta({
        x: this.cx,
        y: this.cy
      }, {
        x: _x,
        y: _y
      });
    }
  }, {
    key: "_calcAngleForLocation",
    value: function _calcAngleForLocation(segment, location) {
      if (segment.anticlockwise) {
        var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
            s = Math.abs(sa - segment.endAngle);
        return sa - s * location;
      } else {
        var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
            ss = Math.abs(ea - segment.startAngle);
        return segment.startAngle + ss * location;
      }
    }
  }, {
    key: "getPath",
    value: function getPath(isFirstSegment) {
      var laf = this.sweep > Math.PI ? 1 : 0,
          sf = this.anticlockwise ? 0 : 1;
      return (isFirstSegment ? "M" + this.x1 + " " + this.y1 + " " : "") + "A " + this.radius + " " + this.radius + " 0 " + laf + "," + sf + " " + this.x2 + " " + this.y2;
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.length;
    }
  }, {
    key: "pointOnPath",
    value: function pointOnPath(location, absolute) {
      if (location === 0) {
        return {
          x: this.x1,
          y: this.y1,
          theta: this.startAngle
        };
      } else if (location === 1) {
        return {
          x: this.x2,
          y: this.y2,
          theta: this.endAngle
        };
      }
      if (absolute) {
        location = location / length;
      }
      var angle = this._calcAngleForLocation(this, location),
          _x = this.cx + this.radius * Math.cos(angle),
          _y = this.cy + this.radius * Math.sin(angle);
      return {
        x: gentleRound(_x),
        y: gentleRound(_y),
        theta: angle
      };
    }
  }, {
    key: "gradientAtPoint",
    value: function gradientAtPoint(location, absolute) {
      var p = this.pointOnPath(location, absolute);
      var m = normal({
        x: this.cx,
        y: this.cy
      }, p);
      if (!this.anticlockwise && (m === Infinity || m === -Infinity)) {
        m *= -1;
      }
      return m;
    }
  }, {
    key: "pointAlongPathFrom",
    value: function pointAlongPathFrom(location, distance, absolute) {
      var p = this.pointOnPath(location, absolute),
          arcSpan = distance / this.circumference * 2 * Math.PI,
          dir = this.anticlockwise ? -1 : 1,
          startAngle = p.theta + dir * arcSpan,
          startX = this.cx + this.radius * Math.cos(startAngle),
          startY = this.cy + this.radius * Math.sin(startAngle);
      return {
        x: startX,
        y: startY
      };
    }
  }]);
  return ArcSegment;
}(AbstractSegment);
jsplumb_core_es_defineProperty(jsplumb_core_es_ArcSegment, "segmentType", "Arc");

var DEFAULT_WIDTH = 20;
var DEFAULT_LENGTH = 20;
var jsplumb_core_es_ArrowOverlay = function (_Overlay) {
  jsplumb_core_es_inherits(ArrowOverlay, _Overlay);
  var _super = jsplumb_core_es_createSuper(ArrowOverlay);
  function ArrowOverlay(instance, component, p) {
    var _this;
    jsplumb_core_es_classCallCheck(this, ArrowOverlay);
    _this = _super.call(this, instance, component, p);
    _this.instance = instance;
    _this.component = component;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "width", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "length", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "foldback", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "direction", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "location", 0.5);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "paintStyle", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", ArrowOverlay.type);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "cachedDimensions", void 0);
    p = p || {};
    _this.width = p.width || DEFAULT_WIDTH;
    _this.length = p.length || DEFAULT_LENGTH;
    _this.direction = (p.direction || 1) < 0 ? -1 : 1;
    _this.foldback = p.foldback || 0.623;
    _this.paintStyle = p.paintStyle || {
      "strokeWidth": 1
    };
    _this.location = p.location == null ? _this.location : Array.isArray(p.location) ? p.location[0] : p.location;
    return _this;
  }
  jsplumb_core_es_createClass(ArrowOverlay, [{
    key: "draw",
    value: function draw(component, currentConnectionPaintStyle, absolutePosition) {
      if (component instanceof jsplumb_core_es_AbstractConnector) {
        var connector = component;
        var hxy, mid, txy, tail, cxy;
        if (this.location > 1 || this.location < 0) {
          var fromLoc = this.location < 0 ? 1 : 0;
          hxy = connector.pointAlongPathFrom(fromLoc, this.location, false);
          mid = connector.pointAlongPathFrom(fromLoc, this.location - this.direction * this.length / 2, false);
          txy = pointOnLine(hxy, mid, this.length);
        } else if (this.location === 1) {
          hxy = connector.pointOnPath(this.location);
          mid = connector.pointAlongPathFrom(this.location, -this.length);
          txy = pointOnLine(hxy, mid, this.length);
          if (this.direction === -1) {
            var _ = txy;
            txy = hxy;
            hxy = _;
          }
        } else if (this.location === 0) {
          txy = connector.pointOnPath(this.location);
          mid = connector.pointAlongPathFrom(this.location, this.length);
          hxy = pointOnLine(txy, mid, this.length);
          if (this.direction === -1) {
            var __ = txy;
            txy = hxy;
            hxy = __;
          }
        } else {
          hxy = connector.pointAlongPathFrom(this.location, this.direction * this.length / 2);
          mid = connector.pointOnPath(this.location);
          txy = pointOnLine(hxy, mid, this.length);
        }
        tail = perpendicularLineTo(hxy, txy, this.width);
        cxy = pointOnLine(hxy, txy, this.foldback * this.length);
        var d = {
          hxy: hxy,
          tail: tail,
          cxy: cxy
        },
            stroke = this.paintStyle.stroke || currentConnectionPaintStyle.stroke,
            fill = this.paintStyle.fill || currentConnectionPaintStyle.stroke,
            lineWidth = this.paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;
        return {
          component: component,
          d: d,
          "stroke-width": lineWidth,
          stroke: stroke,
          fill: fill,
          xmin: Math.min(hxy.x, tail[0].x, tail[1].x),
          xmax: Math.max(hxy.x, tail[0].x, tail[1].x),
          ymin: Math.min(hxy.y, tail[0].y, tail[1].y),
          ymax: Math.max(hxy.y, tail[0].y, tail[1].y)
        };
      }
    }
  }, {
    key: "updateFrom",
    value: function updateFrom(d) {}
  }]);
  return ArrowOverlay;
}(jsplumb_core_es_Overlay);
jsplumb_core_es_defineProperty(jsplumb_core_es_ArrowOverlay, "type", "Arrow");
function isArrowOverlay(o) {
  return o.type === jsplumb_core_es_ArrowOverlay.type;
}
OverlayFactory.register(jsplumb_core_es_ArrowOverlay.type, jsplumb_core_es_ArrowOverlay);

var PlainArrowOverlay = function (_ArrowOverlay) {
  jsplumb_core_es_inherits(PlainArrowOverlay, _ArrowOverlay);
  var _super = jsplumb_core_es_createSuper(PlainArrowOverlay);
  function PlainArrowOverlay(instance, component, p) {
    var _this;
    jsplumb_core_es_classCallCheck(this, PlainArrowOverlay);
    _this = _super.call(this, instance, component, p);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", PlainArrowOverlay.type);
    _this.foldback = 1;
    return _this;
  }
  return PlainArrowOverlay;
}(jsplumb_core_es_ArrowOverlay);
jsplumb_core_es_defineProperty(PlainArrowOverlay, "type", "PlainArrow");
function isPlainArrowOverlay(o) {
  return o.type === PlainArrowOverlay.type;
}
OverlayFactory.register("PlainArrow", PlainArrowOverlay);

var DiamondOverlay = function (_ArrowOverlay) {
  jsplumb_core_es_inherits(DiamondOverlay, _ArrowOverlay);
  var _super = jsplumb_core_es_createSuper(DiamondOverlay);
  function DiamondOverlay(instance, component, p) {
    var _this;
    jsplumb_core_es_classCallCheck(this, DiamondOverlay);
    _this = _super.call(this, instance, component, p);
    _this.instance = instance;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", DiamondOverlay.type);
    _this.length = _this.length / 2;
    _this.foldback = 2;
    return _this;
  }
  return DiamondOverlay;
}(jsplumb_core_es_ArrowOverlay);
jsplumb_core_es_defineProperty(DiamondOverlay, "type", "Diamond");
function isDiamondOverlay(o) {
  return o.type === DiamondOverlay.type;
}
OverlayFactory.register(DiamondOverlay.type, DiamondOverlay);

var CustomOverlay = function (_Overlay) {
  jsplumb_core_es_inherits(CustomOverlay, _Overlay);
  var _super = jsplumb_core_es_createSuper(CustomOverlay);
  function CustomOverlay(instance, component, p) {
    var _this;
    jsplumb_core_es_classCallCheck(this, CustomOverlay);
    _this = _super.call(this, instance, component, p);
    _this.instance = instance;
    _this.component = component;
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "create", void 0);
    jsplumb_core_es_defineProperty(jsplumb_core_es_assertThisInitialized(_this), "type", CustomOverlay.type);
    _this.create = p.create;
    return _this;
  }
  jsplumb_core_es_createClass(CustomOverlay, [{
    key: "updateFrom",
    value: function updateFrom(d) {}
  }]);
  return CustomOverlay;
}(jsplumb_core_es_Overlay);
jsplumb_core_es_defineProperty(CustomOverlay, "type", "Custom");
function isCustomOverlay(o) {
  return o.type === CustomOverlay.type;
}
OverlayFactory.register("Custom", CustomOverlay);

EndpointFactory.registerHandler(DotEndpointHandler);
EndpointFactory.registerHandler(RectangleEndpointHandler);
EndpointFactory.registerHandler(BlankEndpointHandler);
Connectors.register(StraightConnector.type, StraightConnector);



// CONCATENATED MODULE: ./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js




function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function jsplumb_browser_ui_es_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function jsplumb_browser_ui_es_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function jsplumb_browser_ui_es_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) jsplumb_browser_ui_es_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) jsplumb_browser_ui_es_defineProperties(Constructor, staticProps);
  return Constructor;
}

function jsplumb_browser_ui_es_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function jsplumb_browser_ui_es_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) jsplumb_browser_ui_es_setPrototypeOf(subClass, superClass);
}

function jsplumb_browser_ui_es_getPrototypeOf(o) {
  jsplumb_browser_ui_es_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return jsplumb_browser_ui_es_getPrototypeOf(o);
}

function jsplumb_browser_ui_es_setPrototypeOf(o, p) {
  jsplumb_browser_ui_es_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return jsplumb_browser_ui_es_setPrototypeOf(o, p);
}

function jsplumb_browser_ui_es_isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function jsplumb_browser_ui_es_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function jsplumb_browser_ui_es_possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return jsplumb_browser_ui_es_assertThisInitialized(self);
}

function jsplumb_browser_ui_es_createSuper(Derived) {
  var hasNativeReflectConstruct = jsplumb_browser_ui_es_isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = jsplumb_browser_ui_es_getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = jsplumb_browser_ui_es_getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return jsplumb_browser_ui_es_possibleConstructorReturn(this, result);
  };
}

function jsplumb_browser_ui_es_superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = jsplumb_browser_ui_es_getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function jsplumb_browser_ui_es_get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    jsplumb_browser_ui_es_get = Reflect.get;
  } else {
    jsplumb_browser_ui_es_get = function _get(target, property, receiver) {
      var base = jsplumb_browser_ui_es_superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return jsplumb_browser_ui_es_get(target, property, receiver || target);
}

function jsplumb_browser_ui_es_slicedToArray(arr, i) {
  return jsplumb_browser_ui_es_arrayWithHoles(arr) || jsplumb_browser_ui_es_iterableToArrayLimit(arr, i) || jsplumb_browser_ui_es_unsupportedIterableToArray(arr, i) || jsplumb_browser_ui_es_nonIterableRest();
}

function jsplumb_browser_ui_es_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function jsplumb_browser_ui_es_iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function jsplumb_browser_ui_es_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return jsplumb_browser_ui_es_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jsplumb_browser_ui_es_arrayLikeToArray(o, minLen);
}

function jsplumb_browser_ui_es_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function jsplumb_browser_ui_es_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function matchesSelector$1(el, selector, ctx) {
  ctx = ctx || el.parentNode;
  var possibles = ctx.querySelectorAll(selector);
  for (var i = 0; i < possibles.length; i++) {
    if (possibles[i] === el) {
      return true;
    }
  }
  return false;
}
function consume(e, doNotPreventDefault) {
  if (e.stopPropagation) {
    e.stopPropagation();
  } else {
    e.returnValue = false;
  }
  if (!doNotPreventDefault && e.preventDefault) {
    e.preventDefault();
  }
}
function findParent(el, selector, container, matchOnElementAlso) {
  if (matchOnElementAlso && matchesSelector$1(el, selector, container)) {
    return el;
  } else {
    el = el.parentNode;
  }
  while (el != null && el !== container) {
    if (matchesSelector$1(el, selector)) {
      return el;
    } else {
      el = el.parentNode;
    }
  }
}
function getEventSource(e) {
  return e.srcElement || e.target;
}
function _setClassName(el, cn, classList) {
  cn = fastTrim(cn);
  if (typeof el.className.baseVal !== "undefined") {
    el.className.baseVal = cn;
  } else {
    el.className = cn;
  }
  try {
    var cl = el.classList;
    if (cl != null) {
      while (cl.length > 0) {
        cl.remove(cl.item(0));
      }
      for (var i = 0; i < classList.length; i++) {
        if (classList[i]) {
          cl.add(classList[i]);
        }
      }
    }
  } catch (e) {
    log("JSPLUMB: cannot set class list", e);
  }
}
function _getClassName(el) {
  return el.className != null ? typeof el.className.baseVal === "undefined" ? el.className : el.className.baseVal : "";
}
function _classManip(el, classesToAdd, classesToRemove) {
  var cta = classesToAdd == null ? [] : Array.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
  var ctr = classesToRemove == null ? [] : Array.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);
  var className = _getClassName(el),
      curClasses = className.split(/\s+/);
  var _oneSet = function _oneSet(add, classes) {
    for (var i = 0; i < classes.length; i++) {
      if (add) {
        if (curClasses.indexOf(classes[i]) === -1) {
          curClasses.push(classes[i]);
        }
      } else {
        var idx = curClasses.indexOf(classes[i]);
        if (idx !== -1) {
          curClasses.splice(idx, 1);
        }
      }
    }
  };
  _oneSet(true, cta);
  _oneSet(false, ctr);
  _setClassName(el, curClasses.join(" "), curClasses);
}
function isNodeList(el) {
  return !isString(el) && !Array.isArray(el) && el.length != null && el.documentElement == null && el.nodeType == null;
}
function isArrayLike(el) {
  return !isString(el) && (Array.isArray(el) || isNodeList(el));
}
function getClass(el) {
  return _getClassName(el);
}
function addClass(el, clazz) {
  var _one = function _one(el, clazz) {
    if (el != null && clazz != null && clazz.length > 0) {
      if (el.classList) {
        var parts = fastTrim(clazz).split(/\s+/);
        forEach(parts, function (part) {
          el.classList.add(part);
        });
      } else {
        _classManip(el, clazz);
      }
    }
  };
  if (isNodeList(el)) {
    forEach(el, function (el) {
      return _one(el, clazz);
    });
  } else {
    _one(el, clazz);
  }
}
function hasClass(el, clazz) {
  if (el.classList) {
    return el.classList.contains(clazz);
  } else {
    return _getClassName(el).indexOf(clazz) !== -1;
  }
}
function removeClass(el, clazz) {
  var _one = function _one(el, clazz) {
    if (el != null && clazz != null && clazz.length > 0) {
      if (el.classList) {
        var parts = fastTrim(clazz).split(/\s+/);
        parts.forEach(function (part) {
          el.classList.remove(part);
        });
      } else {
        _classManip(el, null, clazz);
      }
    }
  };
  if (isNodeList(el)) {
    forEach(el, function (el) {
      return _one(el, clazz);
    });
  } else {
    _one(el, clazz);
  }
}
function toggleClass(el, clazz) {
  var _this = this;
  var _one = function _one(el, clazz) {
    if (el != null && clazz != null && clazz.length > 0) {
      if (el.classList) {
        el.classList.toggle(clazz);
      } else {
        if (_this.hasClass(el, clazz)) {
          _this.removeClass(el, clazz);
        } else {
          _this.addClass(el, clazz);
        }
      }
    }
  };
  if (isNodeList(el)) {
    forEach(el, function (el) {
      return _one(el, clazz);
    });
  } else {
    _one(el, clazz);
  }
}
function createElement(tag, style, clazz, atts) {
  return createElementNS(null, tag, style, clazz, atts);
}
function createElementNS(ns, tag, style, clazz, atts) {
  var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
  var i;
  style = style || {};
  for (i in style) {
    e.style[i] = style[i];
  }
  if (clazz) {
    e.className = clazz;
  }
  atts = atts || {};
  for (i in atts) {
    e.setAttribute(i, "" + atts[i]);
  }
  return e;
}
function offsetRelativeToRoot(el) {
  var box = el.getBoundingClientRect(),
      body = document.body,
      docElem = document.documentElement,
  scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
      scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
  clientTop = docElem.clientTop || body.clientTop || 0,
      clientLeft = docElem.clientLeft || body.clientLeft || 0,
  top = box.top + scrollTop - clientTop,
      left = box.left + scrollLeft - clientLeft;
  return {
    x: Math.round(left),
    y: Math.round(top)
  };
}
function jsplumb_browser_ui_es_size(el) {
  return {
    w: el.offsetWidth,
    h: el.offsetHeight
  };
}

var svgAttributeMap = {
  "stroke-linejoin": "stroke-linejoin",
  "stroke-dashoffset": "stroke-dashoffset",
  "stroke-linecap": "stroke-linecap"
};
var STROKE_DASHARRAY = "stroke-dasharray";
var DASHSTYLE = "dashstyle";
var FILL = "fill";
var STROKE = "stroke";
var STROKE_WIDTH = "stroke-width";
var LINE_WIDTH = "strokeWidth";
var ELEMENT_SVG = "svg";
var ELEMENT_PATH = "path";
var jsplumb_browser_ui_es_ns = {
  svg: "http://www.w3.org/2000/svg"
};
function _attr(node, attributes) {
  for (var i in attributes) {
    node.setAttribute(i, "" + attributes[i]);
  }
}
function _node(name, attributes) {
  attributes = attributes || {};
  attributes.version = "1.1";
  attributes.xmlns = jsplumb_browser_ui_es_ns.svg;
  return createElementNS(jsplumb_browser_ui_es_ns.svg, name, null, null, attributes);
}
function _pos(d) {
  return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
}
function _applyStyles(parent, node, style) {
  node.setAttribute(FILL, style.fill ? style.fill : NONE);
  node.setAttribute(STROKE, style.stroke ? style.stroke : NONE);
  if (style.strokeWidth) {
    node.setAttribute(STROKE_WIDTH, style.strokeWidth);
  }
  if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
    var sep = style[DASHSTYLE].indexOf(",") === -1 ? " " : ",",
        parts = style[DASHSTYLE].split(sep),
        styleToUse = "";
    forEach(parts, function (p) {
      styleToUse += Math.floor(p * style.strokeWidth) + sep;
    });
    node.setAttribute(STROKE_DASHARRAY, styleToUse);
  } else if (style[STROKE_DASHARRAY]) {
    node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
  }
  for (var i in svgAttributeMap) {
    if (style[i]) {
      node.setAttribute(svgAttributeMap[i], style[i]);
    }
  }
}
function _appendAtIndex(svg, path, idx) {
  if (svg.childNodes.length > idx) {
    svg.insertBefore(path, svg.childNodes[idx]);
  } else {
    svg.appendChild(path);
  }
}
function _size(svg, x, y, w, h) {
  svg.style.width = w + "px";
  svg.style.height = h + "px";
  svg.style.left = x + "px";
  svg.style.top = y + "px";
  svg.height = h;
  svg.width = w;
}

function compoundEvent(stem, event, subevent) {
  var a = [stem, event];
  if (subevent) {
    a.push(subevent);
  }
  return a.join(":");
}
var ATTRIBUTE_CONTAINER = "data-jtk-container";
var ATTRIBUTE_GROUP_CONTENT = "data-jtk-group-content";
var ATTRIBUTE_JTK_ENABLED = "data-jtk-enabled";
var ATTRIBUTE_JTK_SCOPE = "data-jtk-scope";
var ENDPOINT = "endpoint";
var ELEMENT = "element";
var CONNECTION = "connection";
var ELEMENT_DIV = "div";
var EVENT_CLICK = "click";
var EVENT_CONTEXTMENU = "contextmenu";
var EVENT_DBL_CLICK = "dblclick";
var EVENT_DBL_TAP = "dbltap";
var EVENT_FOCUS = "focus";
var EVENT_MOUSEDOWN = "mousedown";
var EVENT_MOUSEENTER = "mouseenter";
var EVENT_MOUSEEXIT = "mouseexit";
var EVENT_MOUSEMOVE = "mousemove";
var EVENT_MOUSEUP = "mouseup";
var EVENT_MOUSEOUT = "mouseout";
var EVENT_MOUSEOVER = "mouseover";
var EVENT_TAP = "tap";
var EVENT_DRAG_MOVE = "drag:move";
var EVENT_DRAG_STOP = "drag:stop";
var EVENT_DRAG_START = "drag:start";
var EVENT_REVERT = "revert";
var EVENT_CONNECTION_ABORT = "connection:abort";
var EVENT_CONNECTION_DRAG = "connection:drag";
var EVENT_ELEMENT_CLICK = compoundEvent(ELEMENT, EVENT_CLICK);
var EVENT_ELEMENT_DBL_CLICK = compoundEvent(ELEMENT, EVENT_DBL_CLICK);
var EVENT_ELEMENT_DBL_TAP = compoundEvent(ELEMENT, EVENT_DBL_TAP);
var EVENT_ELEMENT_MOUSE_OUT = compoundEvent(ELEMENT, EVENT_MOUSEOUT);
var EVENT_ELEMENT_MOUSE_OVER = compoundEvent(ELEMENT, EVENT_MOUSEOVER);
var EVENT_ELEMENT_TAP = compoundEvent(ELEMENT, EVENT_TAP);
var EVENT_ENDPOINT_CLICK = compoundEvent(ENDPOINT, EVENT_CLICK);
var EVENT_ENDPOINT_DBL_CLICK = compoundEvent(ENDPOINT, EVENT_DBL_CLICK);
var EVENT_ENDPOINT_DBL_TAP = compoundEvent(ENDPOINT, EVENT_DBL_TAP);
var EVENT_ENDPOINT_MOUSEOUT = compoundEvent(ENDPOINT, EVENT_MOUSEOUT);
var EVENT_ENDPOINT_MOUSEOVER = compoundEvent(ENDPOINT, EVENT_MOUSEOVER);
var EVENT_ENDPOINT_TAP = compoundEvent(ENDPOINT, EVENT_TAP);
var EVENT_CONNECTION_CLICK = compoundEvent(CONNECTION, EVENT_CLICK);
var EVENT_CONNECTION_DBL_CLICK = compoundEvent(CONNECTION, EVENT_DBL_CLICK);
var EVENT_CONNECTION_DBL_TAP = compoundEvent(CONNECTION, EVENT_DBL_TAP);
var EVENT_CONNECTION_MOUSEOUT = compoundEvent(CONNECTION, EVENT_MOUSEOUT);
var EVENT_CONNECTION_MOUSEOVER = compoundEvent(CONNECTION, EVENT_MOUSEOVER);
var EVENT_CONNECTION_TAP = compoundEvent(CONNECTION, EVENT_TAP);
var PROPERTY_POSITION = "position";
var SELECTOR_CONNECTOR = cls(CLASS_CONNECTOR);
var SELECTOR_ENDPOINT = cls(CLASS_ENDPOINT);
var SELECTOR_GROUP = jsplumb_core_es_att(ATTRIBUTE_GROUP);
var SELECTOR_GROUP_CONTAINER = jsplumb_core_es_att(ATTRIBUTE_GROUP_CONTENT);
var SELECTOR_OVERLAY = cls(CLASS_OVERLAY);

function _touch(target, pageX, pageY, screenX, screenY, clientX, clientY) {
  return new Touch({
    target: target,
    identifier: jsplumb_util_es_uuid(),
    pageX: pageX,
    pageY: pageY,
    screenX: screenX,
    screenY: screenY,
    clientX: clientX || screenX,
    clientY: clientY || screenY
  });
}
function _touchList() {
  var list = [];
  list.push.apply(list, arguments);
  list.item = function (index) {
    return this[index];
  };
  return list;
}
function _touchAndList(target, pageX, pageY, screenX, screenY, clientX, clientY) {
  return _touchList(_touch(target, pageX, pageY, screenX, screenY, clientX, clientY));
}
function matchesSelector(el, selector, ctx) {
  ctx = ctx || el.parentNode;
  var possibles = ctx.querySelectorAll(selector);
  for (var i = 0; i < possibles.length; i++) {
    if (possibles[i] === el) {
      return true;
    }
  }
  return false;
}
function jsplumb_browser_ui_es_t(e) {
  return e.srcElement || e.target;
}
function _pi(e, target, obj, doCompute) {
  if (!doCompute) return {
    path: [target],
    end: 1
  };else if (typeof e.path !== "undefined" && e.path.indexOf) {
    return {
      path: e.path,
      end: e.path.indexOf(obj)
    };
  } else {
    var out = {
      path: [],
      end: -1
    },
        _one = function _one(el) {
      out.path.push(el);
      if (el === obj) {
        out.end = out.path.length - 1;
      } else if (el.parentNode != null) {
        _one(el.parentNode);
      }
    };
    _one(target);
    return out;
  }
}
function _d(l, fn) {
  var i = 0,
      j;
  for (i = 0, j = l.length; i < j; i++) {
    if (l[i][0] === fn) {
      break;
    }
  }
  if (i < l.length) {
    l.splice(i, 1);
  }
}
var guid = 1;
var isTouchDevice = "ontouchstart" in document.documentElement || navigator.maxTouchPoints != null && navigator.maxTouchPoints > 0;
var isMouseDevice = ("onmousedown" in document.documentElement);
var touchMap = {
  "mousedown": "touchstart",
  "mouseup": "touchend",
  "mousemove": "touchmove"
};
var PAGE = "page";
var SCREEN = "screen";
var CLIENT = "client";
function _genLoc(e, prefix) {
  if (e == null) return {
    x: 0,
    y: 0
  };
  var ts = touches(e),
      t = getTouch(ts, 0);
  return {
    x: t[prefix + "X"],
    y: t[prefix + "Y"]
  };
}
function pageLocation(e) {
  return _genLoc(e, PAGE);
}
function screenLocation(e) {
  return _genLoc(e, SCREEN);
}
function clientLocation(e) {
  return _genLoc(e, CLIENT);
}
function getTouch(touches, idx) {
  return touches.item ? touches.item(idx) : touches[idx];
}
function touches(e) {
  return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
}
function touchCount(e) {
  return touches(e).length;
}
function _bind(obj, type, fn, originalFn, options) {
  _store(obj, type, fn);
  originalFn.__tauid = fn.__tauid;
  if (obj.addEventListener) {
    obj.addEventListener(type, fn, false, options);
  } else if (obj.attachEvent) {
    var key = type + fn.__tauid;
    obj["e" + key] = fn;
    obj[key] = function () {
      obj["e" + key] && obj["e" + key](window.event);
    };
    obj.attachEvent("on" + type, obj[key]);
  }
}
function _unbind(obj, type, fn) {
  var _this = this;
  if (fn == null) return;
  _each$1(obj, function (_el) {
    _unstore(_el, type, fn);
    if (fn.__tauid != null) {
      if (_el.removeEventListener) {
        _el.removeEventListener(type, fn, false);
        if (isTouchDevice && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
      } else if (_this.detachEvent) {
        var key = type + fn.__tauid;
        _el[key] && _el.detachEvent("on" + type, _el[key]);
        _el[key] = null;
        _el["e" + key] = null;
      }
    }
    if (fn.__taTouchProxy) {
      _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
    }
  });
}
function _each$1(obj, fn) {
  if (obj == null) return;
  var entries = typeof obj === "string" ? document.querySelectorAll(obj) : obj.length != null ? obj : [obj];
  for (var i = 0; i < entries.length; i++) {
    fn(entries[i]);
  }
}
function _store(obj, event, fn) {
  var g = guid++;
  obj.__ta = obj.__ta || {};
  obj.__ta[event] = obj.__ta[event] || {};
  obj.__ta[event][g] = fn;
  fn.__tauid = g;
  return g;
}
function _unstore(obj, event, fn) {
  obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
  if (fn.__taExtra) {
    for (var i = 0; i < fn.__taExtra.length; i++) {
      _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
    }
    fn.__taExtra.length = 0;
  }
  fn.__taUnstore && fn.__taUnstore();
}
function _curryChildFilter(children, obj, fn, evt) {
  if (children == null) return fn;else {
    var c = children.split(","),
        _fn = function _fn(e) {
      _fn.__tauid = fn.__tauid;
      var t = jsplumb_browser_ui_es_t(e);
      var done = false;
      var target = t;
      var pathInfo = _pi(e, t, obj, children != null);
      if (pathInfo.end != -1) {
        for (var p = 0; !done && p < pathInfo.end; p++) {
          target = pathInfo.path[p];
          for (var i = 0; !done && i < c.length; i++) {
            if (matchesSelector(target, c[i], obj)) {
              fn.apply(target, [e, target]);
              done = true;
              break;
            }
          }
        }
      }
    };
    registerExtraFunction(fn, evt, _fn);
    return _fn;
  }
}
function registerExtraFunction(fn, evt, newFn) {
  fn.__taExtra = fn.__taExtra || [];
  fn.__taExtra.push([evt, newFn]);
}
var jsplumb_browser_ui_es_DefaultHandler = function DefaultHandler(obj, evt, fn, children, options) {
  if (isTouchDevice && touchMap[evt]) {
    var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
    _bind(obj, touchMap[evt], tfn, fn, options);
  }
  if (evt === EVENT_FOCUS && obj.getAttribute(ATTRIBUTE_TABINDEX) == null) {
    obj.setAttribute(ATTRIBUTE_TABINDEX, "1");
  }
  _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn, options);
};
var _tapProfiles = {
  "tap": {
    touches: 1,
    taps: 1
  },
  "dbltap": {
    touches: 1,
    taps: 2
  },
  "contextmenu": {
    touches: 2,
    taps: 1
  }
};
function meeHelper(type, evt, obj, target) {
  for (var i in obj.__tamee[type]) {
    if (obj.__tamee[type].hasOwnProperty(i)) {
      obj.__tamee[type][i].apply(target, [evt]);
    }
  }
}
var jsplumb_browser_ui_es_TapHandler = function () {
  function TapHandler() {
    jsplumb_browser_ui_es_classCallCheck(this, TapHandler);
  }
  jsplumb_browser_ui_es_createClass(TapHandler, null, [{
    key: "generate",
    value: function generate(clickThreshold, dblClickThreshold) {
      return function (obj, evt, fn, children) {
        if (evt == EVENT_CONTEXTMENU && isMouseDevice) jsplumb_browser_ui_es_DefaultHandler(obj, evt, fn, children);else {
          if (obj.__taTapHandler == null) {
            var tt = obj.__taTapHandler = {
              tap: [],
              dbltap: [],
              down: false,
              taps: 0,
              downSelectors: []
            };
            var down = function down(e) {
              var target = jsplumb_browser_ui_es_t(e),
                  pathInfo = _pi(e, target, obj, children != null),
                  finished = false;
              for (var p = 0; p < pathInfo.end; p++) {
                if (finished) return;
                target = pathInfo.path[p];
                for (var i = 0; i < tt.downSelectors.length; i++) {
                  if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                    tt.down = true;
                    setTimeout(clearSingle, clickThreshold);
                    setTimeout(clearDouble, dblClickThreshold);
                    finished = true;
                    break;
                  }
                }
              }
            },
                up = function up(e) {
              if (tt.down) {
                var target = jsplumb_browser_ui_es_t(e),
                    currentTarget,
                    pathInfo;
                tt.taps++;
                var tc = touchCount(e);
                for (var eventId in _tapProfiles) {
                  if (_tapProfiles.hasOwnProperty(eventId)) {
                    var p = _tapProfiles[eventId];
                    if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                      for (var i = 0; i < tt[eventId].length; i++) {
                        pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                        for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                          currentTarget = pathInfo.path[pLoop];
                          if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {
                            tt[eventId][i][0].apply(currentTarget, [e, currentTarget]);
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
                clearSingle = function clearSingle() {
              tt.down = false;
            },
                clearDouble = function clearDouble() {
              tt.taps = 0;
            };
            obj.__taTapHandler.downHandler = down;
            obj.__taTapHandler.upHandler = up;
            jsplumb_browser_ui_es_DefaultHandler(obj, EVENT_MOUSEDOWN, down);
            jsplumb_browser_ui_es_DefaultHandler(obj, EVENT_MOUSEUP, up);
          }
          obj.__taTapHandler.downSelectors.push(children);
          obj.__taTapHandler[evt].push([fn, children]);
          fn.__taUnstore = function () {
            if (obj.__taTapHandler != null) {
              removeWithFunction(obj.__taTapHandler.downSelectors, function (ds) {
                return ds === children;
              });
              _d(obj.__taTapHandler[evt], fn);
              if (obj.__taTapHandler.downSelectors.length === 0) {
                _unbind(obj, EVENT_MOUSEDOWN, obj.__taTapHandler.downHandler);
                _unbind(obj, EVENT_MOUSEUP, obj.__taTapHandler.upHandler);
                delete obj.__taTapHandler;
              }
            }
          };
        }
      };
    }
  }]);
  return TapHandler;
}();
var MouseEnterExitHandler = function () {
  function MouseEnterExitHandler() {
    jsplumb_browser_ui_es_classCallCheck(this, MouseEnterExitHandler);
  }
  jsplumb_browser_ui_es_createClass(MouseEnterExitHandler, null, [{
    key: "generate",
    value: function generate() {
      var activeElements = [];
      return function (obj, evt, fn, children) {
        if (!obj.__tamee) {
          obj.__tamee = {
            over: false,
            mouseenter: [],
            mouseexit: []
          };
          var over = function over(e) {
            var t = jsplumb_browser_ui_es_t(e);
            if (children == null && t == obj && !obj.__tamee.over || matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over)) {
              meeHelper(EVENT_MOUSEENTER, e, obj, t);
              t.__tamee = t.__tamee || {};
              t.__tamee.over = true;
              activeElements.push(t);
            }
          },
              out = function out(e) {
            var t = jsplumb_browser_ui_es_t(e);
            for (var i = 0; i < activeElements.length; i++) {
              if (t == activeElements[i] && !matchesSelector(e.relatedTarget || e.toElement, "*", t)) {
                t.__tamee.over = false;
                activeElements.splice(i, 1);
                meeHelper(EVENT_MOUSEEXIT, e, obj, t);
              }
            }
          };
          _bind(obj, EVENT_MOUSEOVER, _curryChildFilter(children, obj, over, EVENT_MOUSEOVER), over);
          _bind(obj, EVENT_MOUSEOUT, _curryChildFilter(children, obj, out, EVENT_MOUSEOUT), out);
        }
        fn.__taUnstore = function () {
          delete obj.__tamee[evt][fn.__tauid];
        };
        _store(obj, evt, fn);
        obj.__tamee[evt][fn.__tauid] = fn;
      };
    }
  }]);
  return MouseEnterExitHandler;
}();
var EventManager = function () {
  function EventManager(params) {
    jsplumb_browser_ui_es_classCallCheck(this, EventManager);
    jsplumb_browser_ui_es_defineProperty(this, "clickThreshold", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "dblClickThreshold", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "tapHandler", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "mouseEnterExitHandler", void 0);
    params = params || {};
    this.clickThreshold = params.clickThreshold || 250;
    this.dblClickThreshold = params.dblClickThreshold || 450;
    this.mouseEnterExitHandler = MouseEnterExitHandler.generate();
    this.tapHandler = jsplumb_browser_ui_es_TapHandler.generate(this.clickThreshold, this.dblClickThreshold);
  }
  jsplumb_browser_ui_es_createClass(EventManager, [{
    key: "_doBind",
    value: function _doBind(el, evt, fn, children, options) {
      if (fn == null) return;
      var jel = el;
      if (evt === EVENT_TAP || evt === EVENT_DBL_TAP || evt === EVENT_CONTEXTMENU) {
        this.tapHandler(jel, evt, fn, children, options);
      } else if (evt === EVENT_MOUSEENTER || evt == EVENT_MOUSEEXIT) this.mouseEnterExitHandler(jel, evt, fn, children, options);else {
        jsplumb_browser_ui_es_DefaultHandler(jel, evt, fn, children, options);
      }
    }
  }, {
    key: "on",
    value: function on(el, event, children, fn, options) {
      var _c = fn == null ? null : children,
          _f = fn == null ? children : fn;
      this._doBind(el, event, _f, _c, options);
      return this;
    }
  }, {
    key: "off",
    value: function off(el, event, fn) {
      _unbind(el, event, fn);
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger(el, event, originalEvent, payload, detail) {
      var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);
      var eventToBind = isTouchDevice && !isMouseDevice && touchMap[event] ? touchMap[event] : event,
          bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);
      var pl = pageLocation(originalEvent),
          sl = screenLocation(originalEvent),
          cl = clientLocation(originalEvent);
      _each$1(el, function (_el) {
        var evt;
        originalEvent = originalEvent || {
          screenX: sl.x,
          screenY: sl.y,
          clientX: cl.x,
          clientY: cl.y
        };
        var _decorate = function _decorate(_evt) {
          if (payload) {
            _evt.payload = payload;
          }
        };
        var eventGenerators = {
          "TouchEvent": function TouchEvent(evt) {
            var touchList = _touchAndList(_el, pl.x, pl.y, sl.x, sl.y, cl.x, cl.y),
                init = evt.initTouchEvent || evt.initEvent;
            init(eventToBind, true, true, window, null, sl.x, sl.y, cl.x, cl.y, false, false, false, false, touchList, touchList, touchList, 1, 0);
          },
          "MouseEvents": function MouseEvents(evt) {
            evt.initMouseEvent(eventToBind, true, true, window, detail == null ? 1 : detail, sl.x, sl.y, cl.x, cl.y, false, false, false, false, 1, _el);
          }
        };
        var ite = !bindingAMouseEvent && !originalIsMouse && isTouchDevice && touchMap[event],
            evtName = ite ? "TouchEvent" : "MouseEvents";
        evt = document.createEvent(evtName);
        eventGenerators[evtName](evt);
        _decorate(evt);
        _el.dispatchEvent(evt);
      });
      return this;
    }
  }]);
  return EventManager;
}();

function findDelegateElement(parentElement, childElement, selector) {
  if (matchesSelector$1(childElement, selector, parentElement)) {
    return childElement;
  } else {
    var currentParent = childElement.parentNode;
    while (currentParent != null && currentParent !== parentElement) {
      if (matchesSelector$1(currentParent, selector, parentElement)) {
        return currentParent;
      } else {
        currentParent = currentParent.parentNode;
      }
    }
  }
}
function _getPosition(el) {
  return {
    x: el.offsetLeft,
    y: el.offsetTop
  };
}
function _getSize(el) {
  return {
    w: el.offsetWidth,
    h: el.offsetHeight
  };
}
function _setPosition(el, pos) {
  el.style.left = pos.x + "px";
  el.style.top = pos.y + "px";
}
function _assignId(obj) {
  if (typeof obj === "function") {
    obj._katavorioId = jsplumb_util_es_uuid();
    return obj._katavorioId;
  } else {
    return obj;
  }
}
function isInsideParent(instance, _el, pos) {
  var p = _el.parentNode,
      s = instance.getSize(p),
      ss = instance.getSize(_el),
      leftEdge = pos.x,
      rightEdge = leftEdge + ss.w,
      topEdge = pos.y,
      bottomEdge = topEdge + ss.h;
  return rightEdge > 0 && leftEdge < s.w && bottomEdge > 0 && topEdge < s.h;
}
function findMatchingSelector(availableSelectors, parentElement, childElement) {
  var el = null;
  var draggableId = parentElement.getAttribute("katavorio-draggable"),
      prefix = draggableId != null ? "[katavorio-draggable='" + draggableId + "'] " : "";
  for (var i = 0; i < availableSelectors.length; i++) {
    el = findDelegateElement(parentElement, childElement, prefix + availableSelectors[i].selector);
    if (el != null) {
      if (availableSelectors[i].filter) {
        var matches = matchesSelector$1(childElement, availableSelectors[i].filter, el),
            exclude = availableSelectors[i].filterExclude === true;
        if (exclude && !matches || matches) {
          return null;
        }
      }
      return [availableSelectors[i], el];
    }
  }
  return null;
}
var EVENT_START = "start";
var EVENT_BEFORE_START = "beforeStart";
var EVENT_DRAG = "drag";
var EVENT_DROP = "drop";
var EVENT_OVER = "over";
var EVENT_OUT = "out";
var EVENT_STOP = "stop";
var ATTRIBUTE_DRAGGABLE = "katavorio-draggable";
var CLASS_DRAGGABLE$1 = ATTRIBUTE_DRAGGABLE;
var DEFAULT_GRID_X = 10;
var DEFAULT_GRID_Y = 10;
var jsplumb_browser_ui_es_TRUE = function TRUE() {
  return true;
};
var jsplumb_browser_ui_es_FALSE = function FALSE() {
  return false;
};
var _classes = {
  delegatedDraggable: "katavorio-delegated-draggable",
  draggable: CLASS_DRAGGABLE$1,
  drag: "katavorio-drag",
  selected: "katavorio-drag-selected",
  noSelect: "katavorio-drag-no-select",
  ghostProxy: "katavorio-ghost-proxy",
  clonedDrag: "katavorio-clone-drag"
};
var _events = [EVENT_STOP, EVENT_START, EVENT_DRAG, EVENT_DROP, EVENT_OVER, EVENT_OUT, EVENT_BEFORE_START];
var _devNull = function _devNull() {};
var jsplumb_browser_ui_es_each = function _each(obj, fn) {
  if (obj == null) return;
  obj = !isString(obj) && obj.tagName == null && obj.length != null ? obj : [obj];
  for (var i = 0; i < obj.length; i++) {
    fn.apply(obj[i], [obj[i]]);
  }
};
var _inputFilter = function _inputFilter(e, el, collicat) {
  var t = e.srcElement || e.target;
  return !matchesSelector$1(t, collicat.getInputFilterSelector(), el);
};
var jsplumb_browser_ui_es_Base = function () {
  function Base(el, k) {
    jsplumb_browser_ui_es_classCallCheck(this, Base);
    this.el = el;
    this.k = k;
    jsplumb_browser_ui_es_defineProperty(this, "_class", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "uuid", jsplumb_util_es_uuid());
    jsplumb_browser_ui_es_defineProperty(this, "enabled", true);
    jsplumb_browser_ui_es_defineProperty(this, "scopes", []);
  }
  jsplumb_browser_ui_es_createClass(Base, [{
    key: "setEnabled",
    value: function setEnabled(e) {
      this.enabled = e;
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.enabled;
    }
  }, {
    key: "toggleEnabled",
    value: function toggleEnabled() {
      this.enabled = !this.enabled;
    }
  }, {
    key: "addScope",
    value: function addScope(scopes) {
      var m = {};
      jsplumb_browser_ui_es_each(this.scopes, function (s) {
        m[s] = true;
      });
      jsplumb_browser_ui_es_each(scopes ? scopes.split(/\s+/) : [], function (s) {
        m[s] = true;
      });
      this.scopes.length = 0;
      for (var i in m) {
        this.scopes.push(i);
      }
    }
  }, {
    key: "removeScope",
    value: function removeScope(scopes) {
      var m = {};
      jsplumb_browser_ui_es_each(this.scopes, function (s) {
        m[s] = true;
      });
      jsplumb_browser_ui_es_each(scopes ? scopes.split(/\s+/) : [], function (s) {
        delete m[s];
      });
      this.scopes.length = 0;
      for (var i in m) {
        this.scopes.push(i);
      }
    }
  }, {
    key: "toggleScope",
    value: function toggleScope(scopes) {
      var m = {};
      jsplumb_browser_ui_es_each(this.scopes, function (s) {
        m[s] = true;
      });
      jsplumb_browser_ui_es_each(scopes ? scopes.split(/\s+/) : [], function (s) {
        if (m[s]) delete m[s];else m[s] = true;
      });
      this.scopes.length = 0;
      for (var i in m) {
        this.scopes.push(i);
      }
    }
  }]);
  return Base;
}();
function getConstrainingRectangle(el) {
  return {
    w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
    h: el.parentNode.offsetHeight + el.parentNode.scrollTop
  };
}
var ContainmentType;
(function (ContainmentType) {
  ContainmentType["notNegative"] = "notNegative";
  ContainmentType["parent"] = "parent";
  ContainmentType["parentEnclosed"] = "parentEnclosed";
})(ContainmentType || (ContainmentType = {}));
var jsplumb_browser_ui_es_Drag = function (_Base) {
  jsplumb_browser_ui_es_inherits(Drag, _Base);
  var _super = jsplumb_browser_ui_es_createSuper(Drag);
  function Drag(el, params, k) {
    var _this;
    jsplumb_browser_ui_es_classCallCheck(this, Drag);
    _this = _super.call(this, el, k);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_class", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "rightButtonCanDrag", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "consumeStartEvent", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "clone", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "scroll", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "trackScroll", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_downAt", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_posAtDown", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_pagePosAtDown", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_pageDelta", {
      x: 0,
      y: 0
    });
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_moving", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_lastPosition", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_lastScrollValues", {
      x: 0,
      y: 0
    });
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_initialScroll", {
      x: 0,
      y: 0
    });
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_size", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_currentParentPosition", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ghostParentPosition", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_dragEl", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_multipleDrop", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ghostProxyOffsets", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ghostDx", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ghostDy", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_isConstrained", false);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ghostProxyParent", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_useGhostProxy", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ghostProxyFunction", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_activeSelectorParams", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_availableSelectors", []);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_canDrag", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_consumeFilteredEvents", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_parent", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_ignoreZoom", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_filters", {});
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_constrainRect", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_elementToDrag", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "downListener", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "moveListener", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "upListener", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "listeners", {
      "start": [],
      "drag": [],
      "stop": [],
      "over": [],
      "out": [],
      "beforeStart": [],
      "revert": []
    });
    _this._class = _this.k.css.draggable;
    addClass(_this.el, _this._class);
    _this.downListener = _this._downListener.bind(jsplumb_browser_ui_es_assertThisInitialized(_this));
    _this.upListener = _this._upListener.bind(jsplumb_browser_ui_es_assertThisInitialized(_this));
    _this.moveListener = _this._moveListener.bind(jsplumb_browser_ui_es_assertThisInitialized(_this));
    _this.rightButtonCanDrag = params.rightButtonCanDrag === true;
    _this.consumeStartEvent = params.consumeStartEvent !== false;
    _this._dragEl = _this.el;
    _this.clone = params.clone === true;
    _this.scroll = params.scroll === true;
    _this.trackScroll = params.trackScroll !== false;
    _this._multipleDrop = params.multipleDrop !== false;
    _this._canDrag = params.canDrag || jsplumb_browser_ui_es_TRUE;
    _this._consumeFilteredEvents = params.consumeFilteredEvents;
    _this._parent = params.parent;
    _this._ignoreZoom = params.ignoreZoom === true;
    _this._ghostProxyParent = params.ghostProxyParent;
    if (_this.trackScroll) {
      document.addEventListener("scroll", function (e) {
        if (_this._moving) {
          var currentScrollValues = {
            x: document.documentElement.scrollLeft,
            y: document.documentElement.scrollTop
          },
              dsx = currentScrollValues.x - _this._lastScrollValues.x,
              dsy = currentScrollValues.y - _this._lastScrollValues.y,
              _pos = {
            x: dsx + _this._lastPosition.x,
            y: dsy + _this._lastPosition.y
          },
          dx = _pos.x - _this._downAt.x,
              dy = _pos.y - _this._downAt.y,
              _z = _this._ignoreZoom ? 1 : _this.k.getZoom();
          if (_this._dragEl && _this._dragEl.parentNode) {
            dx += _this._dragEl.parentNode.scrollLeft - _this._initialScroll.x;
            dy += _this._dragEl.parentNode.scrollTop - _this._initialScroll.y;
          }
          dx /= _z;
          dy /= _z;
          _this.moveBy(dx, dy, e);
          _this._lastPosition = _pos;
          _this._lastScrollValues = currentScrollValues;
        }
      });
    }
    if (params.ghostProxy === true) {
      _this._useGhostProxy = jsplumb_browser_ui_es_TRUE;
    } else {
      if (params.ghostProxy && typeof params.ghostProxy === "function") {
        _this._useGhostProxy = params.ghostProxy;
      } else {
        _this._useGhostProxy = function (container, dragEl) {
          if (_this._activeSelectorParams && _this._activeSelectorParams.useGhostProxy) {
            return _this._activeSelectorParams.useGhostProxy(container, dragEl);
          } else {
            return false;
          }
        };
      }
    }
    if (params.makeGhostProxy) {
      _this._ghostProxyFunction = params.makeGhostProxy;
    } else {
      _this._ghostProxyFunction = function (el) {
        if (_this._activeSelectorParams && _this._activeSelectorParams.makeGhostProxy) {
          return _this._activeSelectorParams.makeGhostProxy(el);
        } else {
          return el.cloneNode(true);
        }
      };
    }
    if (params.selector) {
      var draggableId = _this.el.getAttribute(ATTRIBUTE_DRAGGABLE);
      if (draggableId == null) {
        draggableId = "" + new Date().getTime();
        _this.el.setAttribute("katavorio-draggable", draggableId);
      }
      _this._availableSelectors.push(params);
    }
    _this.k.eventManager.on(_this.el, EVENT_MOUSEDOWN, _this.downListener);
    return _this;
  }
  jsplumb_browser_ui_es_createClass(Drag, [{
    key: "on",
    value: function on(evt, fn) {
      if (this.listeners[evt]) {
        this.listeners[evt].push(fn);
      }
    }
  }, {
    key: "off",
    value: function off(evt, fn) {
      if (this.listeners[evt]) {
        var l = [];
        for (var i = 0; i < this.listeners[evt].length; i++) {
          if (this.listeners[evt][i] !== fn) {
            l.push(this.listeners[evt][i]);
          }
        }
        this.listeners[evt] = l;
      }
    }
  }, {
    key: "_upListener",
    value: function _upListener(e) {
      if (this._downAt) {
        this._downAt = null;
        this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
        this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
        removeClass(document.body, _classes.noSelect);
        this.unmark(e);
        this.stop(e);
        this._moving = false;
        if (this.clone) {
          this._dragEl && this._dragEl.parentNode && this._dragEl.parentNode.removeChild(this._dragEl);
          this._dragEl = null;
        } else {
          if (this._activeSelectorParams && this._activeSelectorParams.revertFunction) {
            if (this._activeSelectorParams.revertFunction(this._dragEl, _getPosition(this._dragEl)) === true) {
              _setPosition(this._dragEl, this._posAtDown);
              this._dispatch(EVENT_REVERT, this._dragEl);
            }
          }
        }
      }
    }
  }, {
    key: "_downListener",
    value: function _downListener(e) {
      if (e.defaultPrevented) {
        return;
      }
      var isNotRightClick = this.rightButtonCanDrag || e.which !== 3 && e.button !== 2;
      if (isNotRightClick && this.isEnabled() && this._canDrag()) {
        var _f = this._testFilter(e) && _inputFilter(e, this.el, this.k);
        if (_f) {
          this._activeSelectorParams = null;
          this._elementToDrag = null;
          if (this._availableSelectors.length === 0) {
            console.log("JSPLUMB: no available drag selectors");
          }
          var eventTarget = e.target || e.srcElement;
          var match = findMatchingSelector(this._availableSelectors, this.el, eventTarget);
          if (match != null) {
            this._activeSelectorParams = match[0];
            this._elementToDrag = match[1];
          }
          if (this._activeSelectorParams == null || this._elementToDrag == null) {
            return;
          }
          var initial = this._activeSelectorParams.dragInit ? this._activeSelectorParams.dragInit(this._elementToDrag) : null;
          if (initial != null) {
            this._elementToDrag = initial;
          }
          if (this.clone) {
            this._dragEl = this._elementToDrag.cloneNode(true);
            addClass(this._dragEl, _classes.clonedDrag);
            this._dragEl.setAttribute("id", null);
            this._dragEl.style.position = "absolute";
            if (this._parent != null) {
              var _p2 = _getPosition(this.el);
              this._dragEl.style.left = _p2.x + "px";
              this._dragEl.style.top = _p2.y + "px";
              this._parent.appendChild(this._dragEl);
            } else {
              var b = offsetRelativeToRoot(this._elementToDrag);
              this._dragEl.style.left = b.x + "px";
              this._dragEl.style.top = b.y + "px";
              document.body.appendChild(this._dragEl);
            }
          } else {
            this._dragEl = this._elementToDrag;
          }
          if (this.consumeStartEvent) {
            consume(e);
          }
          this._downAt = pageLocation(e);
          if (this._dragEl && this._dragEl.parentNode) {
            this._initialScroll = {
              x: this._dragEl.parentNode.scrollLeft,
              y: this._dragEl.parentNode.scrollTop
            };
          }
          this._posAtDown = _getPosition(this._dragEl);
          this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
          this._pageDelta = {
            x: this._pagePosAtDown.x - this._posAtDown.x,
            y: this._pagePosAtDown.y - this._posAtDown.y
          };
          this._size = _getSize(this._dragEl);
          this.k.eventManager.on(document, EVENT_MOUSEMOVE, this.moveListener);
          this.k.eventManager.on(document, EVENT_MOUSEUP, this.upListener);
          addClass(document.body, _classes.noSelect);
          this._dispatch(EVENT_BEFORE_START, {
            el: this.el,
            pos: this._posAtDown,
            e: e,
            drag: this,
            size: this._size
          });
        } else if (this._consumeFilteredEvents) {
          consume(e);
        }
      }
    }
  }, {
    key: "_moveListener",
    value: function _moveListener(e) {
      if (this._downAt) {
        if (!this._moving) {
          var dispatchResult = this._dispatch(EVENT_START, {
            el: this.el,
            pos: this._posAtDown,
            e: e,
            drag: this,
            size: this._size
          });
          if (dispatchResult !== false) {
            if (!this._downAt) {
              return;
            }
            this.mark(dispatchResult);
            this._moving = true;
          } else {
            this.abort();
          }
        }
        if (this._downAt) {
          var _pos2 = pageLocation(e),
              dx = _pos2.x - this._downAt.x,
              dy = _pos2.y - this._downAt.y,
              _z2 = this._ignoreZoom ? 1 : this.k.getZoom();
          this._lastPosition = {
            x: _pos2.x,
            y: _pos2.y
          };
          this._lastScrollValues = {
            x: document.documentElement.scrollLeft,
            y: document.documentElement.scrollTop
          };
          if (this._dragEl && this._dragEl.parentNode) {
            dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;
            dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;
          }
          dx /= _z2;
          dy /= _z2;
          this.moveBy(dx, dy, e);
        }
      }
    }
  }, {
    key: "mark",
    value: function mark(payload) {
      this._posAtDown = _getPosition(this._dragEl);
      this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
      this._pageDelta = {
        x: this._pagePosAtDown.x - this._posAtDown.x,
        y: this._pagePosAtDown.y - this._posAtDown.y
      };
      this._size = _getSize(this._dragEl);
      addClass(this._dragEl, this.k.css.drag);
      this._constrainRect = getConstrainingRectangle(this._dragEl);
      this._ghostDx = 0;
      this._ghostDy = 0;
    }
  }, {
    key: "unmark",
    value: function unmark(e) {
      if (this._isConstrained && this._useGhostProxy(this._elementToDrag, this._dragEl)) {
        this._ghostProxyOffsets = {
          x: this._dragEl.offsetLeft - this._ghostDx,
          y: this._dragEl.offsetTop - this._ghostDy
        };
        this._dragEl.parentNode.removeChild(this._dragEl);
        this._dragEl = this._elementToDrag;
      } else {
        this._ghostProxyOffsets = null;
      }
      removeClass(this._dragEl, this.k.css.drag);
      this._isConstrained = false;
    }
  }, {
    key: "moveBy",
    value: function moveBy(dx, dy, e) {
      var desiredLoc = this.toGrid({
        x: this._posAtDown.x + dx,
        y: this._posAtDown.y + dy
      }),
          cPos = this._doConstrain(desiredLoc, this._dragEl, this._constrainRect, this._size);
      if (this._useGhostProxy(this.el, this._dragEl)) {
        if (desiredLoc.x !== cPos.x || desiredLoc.y !== cPos.y) {
          if (!this._isConstrained) {
            var gp = this._ghostProxyFunction(this._elementToDrag);
            addClass(gp, _classes.ghostProxy);
            if (this._ghostProxyParent) {
              this._ghostProxyParent.appendChild(gp);
              this._currentParentPosition = offsetRelativeToRoot(this._elementToDrag.parentNode);
              this._ghostParentPosition = offsetRelativeToRoot(this._ghostProxyParent);
              this._ghostDx = this._currentParentPosition.x - this._ghostParentPosition.x;
              this._ghostDy = this._currentParentPosition.y - this._ghostParentPosition.y;
            } else {
              this._elementToDrag.parentNode.appendChild(gp);
            }
            this._dragEl = gp;
            this._isConstrained = true;
          }
          cPos = desiredLoc;
        } else {
          if (this._isConstrained) {
            this._dragEl.parentNode.removeChild(this._dragEl);
            this._dragEl = this._elementToDrag;
            this._isConstrained = false;
            this._currentParentPosition = null;
            this._ghostParentPosition = null;
            this._ghostDx = 0;
            this._ghostDy = 0;
          }
        }
      }
      _setPosition(this._dragEl, {
        x: cPos.x + this._ghostDx,
        y: cPos.y + this._ghostDy
      });
      this._dispatch(EVENT_DRAG, {
        el: this.el,
        pos: cPos,
        e: e,
        drag: this,
        size: this._size,
        originalPos: this._posAtDown
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      if (this._downAt != null) {
        this._upListener();
      }
    }
  }, {
    key: "getDragElement",
    value: function getDragElement(retrieveOriginalElement) {
      return retrieveOriginalElement ? this._elementToDrag || this.el : this._dragEl || this.el;
    }
  }, {
    key: "stop",
    value: function stop(e, force) {
      if (force || this._moving) {
        var positions = [],
            dPos = _getPosition(this._dragEl);
        positions.push([this._dragEl, dPos, this, this._size]);
        this._dispatch(EVENT_STOP, {
          el: this._dragEl,
          pos: this._ghostProxyOffsets || dPos,
          finalPos: dPos,
          e: e,
          drag: this,
          selection: positions,
          size: this._size,
          originalPos: {
            x: this._posAtDown.x,
            y: this._posAtDown.y
          }
        });
      } else if (!this._moving) {
        this._activeSelectorParams.dragAbort ? this._activeSelectorParams.dragAbort(this._elementToDrag) : null;
      }
    }
  }, {
    key: "_dispatch",
    value: function _dispatch(evt, value) {
      var result = null;
      if (this._activeSelectorParams && this._activeSelectorParams[evt]) {
        result = this._activeSelectorParams[evt](value);
      } else if (this.listeners[evt]) {
        for (var i = 0; i < this.listeners[evt].length; i++) {
          try {
            var v = this.listeners[evt][i](value);
            if (v != null) {
              result = v;
            }
          } catch (e) {}
        }
      }
      return result;
    }
  }, {
    key: "resolveGrid",
    value: function resolveGrid() {
      var out = {
        grid: null,
        thresholdX: DEFAULT_GRID_X / 2,
        thresholdY: DEFAULT_GRID_Y / 2
      };
      if (this._activeSelectorParams != null && this._activeSelectorParams.grid != null) {
        out.grid = this._activeSelectorParams.grid;
        if (this._activeSelectorParams.snapThreshold != null) {
          out.thresholdX = this._activeSelectorParams.snapThreshold;
          out.thresholdY = this._activeSelectorParams.snapThreshold;
        }
      }
      return out;
    }
  }, {
    key: "toGrid",
    value: function toGrid(pos) {
      var _this$resolveGrid = this.resolveGrid(),
          grid = _this$resolveGrid.grid,
          thresholdX = _this$resolveGrid.thresholdX,
          thresholdY = _this$resolveGrid.thresholdY;
      if (grid == null) {
        return pos;
      } else {
        var tx = grid ? grid.w / 2 : thresholdX,
            ty = grid ? grid.h / 2 : thresholdY;
        return snapToGrid(pos, grid, tx, ty);
      }
    }
  }, {
    key: "setUseGhostProxy",
    value: function setUseGhostProxy(val) {
      this._useGhostProxy = val ? jsplumb_browser_ui_es_TRUE : jsplumb_browser_ui_es_FALSE;
    }
  }, {
    key: "_doConstrain",
    value: function _doConstrain(pos, dragEl, _constrainRect, _size) {
      if (this._activeSelectorParams != null && this._activeSelectorParams.constrainFunction && typeof this._activeSelectorParams.constrainFunction === "function") {
        return this._activeSelectorParams.constrainFunction(pos, dragEl, _constrainRect, _size);
      } else {
        return pos;
      }
    }
  }, {
    key: "_testFilter",
    value: function _testFilter(e) {
      for (var key in this._filters) {
        var f = this._filters[key];
        var rv = f[0](e);
        if (f[1]) {
          rv = !rv;
        }
        if (!rv) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "addFilter",
    value: function addFilter(f, _exclude) {
      var _this2 = this;
      if (f) {
        var key = _assignId(f);
        this._filters[key] = [function (e) {
          var t = e.srcElement || e.target;
          var m;
          if (isString(f)) {
            m = matchesSelector$1(t, f, _this2.el);
          } else if (typeof f === "function") {
            m = f(e, _this2.el);
          }
          return m;
        }, _exclude !== false];
      }
    }
  }, {
    key: "removeFilter",
    value: function removeFilter(f) {
      var key = typeof f === "function" ? f._katavorioId : f;
      delete this._filters[key];
    }
  }, {
    key: "clearAllFilters",
    value: function clearAllFilters() {
      this._filters = {};
    }
  }, {
    key: "addSelector",
    value: function addSelector(params, atStart) {
      if (params.selector) {
        if (atStart) {
          this._availableSelectors.unshift(params);
        } else {
          this._availableSelectors.push(params);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.k.eventManager.off(this.el, EVENT_MOUSEDOWN, this.downListener);
      this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
      this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
      this.downListener = null;
      this.upListener = null;
      this.moveListener = null;
    }
  }]);
  return Drag;
}(jsplumb_browser_ui_es_Base);
var DEFAULT_INPUTS = ["input", "textarea", "select", "button", "option"];
var DEFAULT_INPUT_FILTER_SELECTOR = DEFAULT_INPUTS.join(",");
var jsplumb_browser_ui_es_Collicat = function () {
  function Collicat(options) {
    jsplumb_browser_ui_es_classCallCheck(this, Collicat);
    jsplumb_browser_ui_es_defineProperty(this, "eventManager", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "zoom", 1);
    jsplumb_browser_ui_es_defineProperty(this, "css", {});
    jsplumb_browser_ui_es_defineProperty(this, "inputFilterSelector", void 0);
    options = options || {};
    this.inputFilterSelector = options.inputFilterSelector || DEFAULT_INPUT_FILTER_SELECTOR;
    this.eventManager = new EventManager();
    this.zoom = options.zoom || 1;
    var _c = options.css || {};
    extend(this.css, _c);
  }
  jsplumb_browser_ui_es_createClass(Collicat, [{
    key: "getZoom",
    value: function getZoom() {
      return this.zoom;
    }
  }, {
    key: "setZoom",
    value: function setZoom(z) {
      this.zoom = z;
    }
  }, {
    key: "_prepareParams",
    value: function _prepareParams(p) {
      p = p || {};
      var _p = {
        events: {}
      },
          i;
      for (i in p) {
        _p[i] = p[i];
      }
      for (i = 0; i < _events.length; i++) {
        _p.events[_events[i]] = p[_events[i]] || _devNull;
      }
      return _p;
    }
  }, {
    key: "getInputFilterSelector",
    value: function getInputFilterSelector() {
      return this.inputFilterSelector;
    }
  }, {
    key: "setInputFilterSelector",
    value: function setInputFilterSelector(selector) {
      this.inputFilterSelector = selector;
      return this;
    }
  }, {
    key: "draggable",
    value: function draggable(el, params) {
      if (el._katavorioDrag == null) {
        var _p3 = this._prepareParams(params);
        var d = new jsplumb_browser_ui_es_Drag(el, _p3, this);
        addClass(el, _classes.delegatedDraggable);
        el._katavorioDrag = d;
        return d;
      } else {
        return el._katavorioDrag;
      }
    }
  }, {
    key: "destroyDraggable",
    value: function destroyDraggable(el) {
      if (el._katavorioDrag) {
        el._katavorioDrag.destroy();
        delete el._katavorioDrag;
      }
    }
  }]);
  return Collicat;
}();

var CLASS_DRAG_SELECTED = "jtk-drag-selected";
var jsplumb_browser_ui_es_DragSelection = function () {
  function DragSelection(instance) {
    jsplumb_browser_ui_es_classCallCheck(this, DragSelection);
    this.instance = instance;
    jsplumb_browser_ui_es_defineProperty(this, "_dragSelection", []);
    jsplumb_browser_ui_es_defineProperty(this, "_dragSizes", new Map());
    jsplumb_browser_ui_es_defineProperty(this, "_dragElements", new Map());
    jsplumb_browser_ui_es_defineProperty(this, "_dragElementStartPositions", new Map());
    jsplumb_browser_ui_es_defineProperty(this, "_dragElementPositions", new Map());
    jsplumb_browser_ui_es_defineProperty(this, "__activeSet", void 0);
  }
  jsplumb_browser_ui_es_createClass(DragSelection, [{
    key: "_activeSet",
    get: function get() {
      if (this.__activeSet == null) {
        return this._dragSelection;
      } else {
        return this.__activeSet;
      }
    }
  }, {
    key: "length",
    get: function get() {
      return this._dragSelection.length;
    }
  }, {
    key: "filterActiveSet",
    value: function filterActiveSet(fn) {
      var _this = this;
      this.__activeSet = [];
      forEach(this._dragSelection, function (p) {
        if (fn(p)) {
          _this.__activeSet.push(p);
        }
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this2 = this;
      this.reset();
      forEach(this._dragSelection, function (p) {
        return _this2.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
      });
      this._dragSelection.length = 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._dragElementStartPositions.clear();
      this._dragElementPositions.clear();
      this._dragSizes.clear();
      this._dragElements.clear();
      this.__activeSet = null;
    }
  }, {
    key: "initialisePositions",
    value: function initialisePositions() {
      var _this3 = this;
      forEach(this._activeSet, function (p) {
        var off = {
          x: parseInt("" + p.jel.offsetLeft, 10),
          y: parseInt("" + p.jel.offsetTop, 10)
        };
        _this3._dragElementStartPositions.set(p.id, off);
        _this3._dragElementPositions.set(p.id, off);
        _this3._dragSizes.set(p.id, _this3.instance.getSize(p.jel));
      });
    }
  }, {
    key: "updatePositions",
    value: function updatePositions(currentPosition, originalPosition, callback) {
      var _this4 = this;
      var dx = currentPosition.x - originalPosition.x,
          dy = currentPosition.y - originalPosition.y;
      forEach(this._activeSet, function (p) {
        var op = _this4._dragElementStartPositions.get(p.id);
        if (op) {
          var x = op.x + dx,
              y = op.y + dy;
          var _s = _this4._dragSizes.get(p.id);
          var _b = {
            x: x,
            y: y,
            w: _s.w,
            h: _s.h
          };
          if (p.jel._jsPlumbParentGroup && p.jel._jsPlumbParentGroup.constrain) {
            var constrainRect = {
              w: p.jel.parentNode.offsetWidth + p.jel.parentNode.scrollLeft,
              h: p.jel.parentNode.offsetHeight + p.jel.parentNode.scrollTop
            };
            _b.x = Math.max(_b.x, 0);
            _b.y = Math.max(_b.y, 0);
            _b.x = Math.min(_b.x, constrainRect.w - _s.w);
            _b.y = Math.min(_b.y, constrainRect.h - _s.h);
          }
          _this4._dragElementPositions.set(p.id, {
            x: x,
            y: y
          });
          p.jel.style.left = _b.x + "px";
          p.jel.style.top = _b.y + "px";
          callback(p.jel, p.id, _s, _b);
        }
      });
    }
  }, {
    key: "each",
    value: function each(f) {
      var _this5 = this;
      forEach(this._activeSet, function (p) {
        var s = _this5._dragSizes.get(p.id);
        var o = _this5._dragElementPositions.get(p.id);
        var orig = _this5._dragElementStartPositions.get(p.id);
        f(p.jel, p.id, o, s, orig);
      });
    }
  }, {
    key: "add",
    value: function add(el, id) {
      var jel = el;
      id = id || this.instance.getId(jel);
      var idx = findWithFunction(this._dragSelection, function (p) {
        return p.id === id;
      });
      if (idx === -1) {
        this.instance.addClass(el, CLASS_DRAG_SELECTED);
        this._dragSelection.push({
          id: id,
          jel: jel
        });
      }
    }
  }, {
    key: "remove",
    value: function remove(el) {
      var _this6 = this;
      var jel = el;
      this._dragSelection = this._dragSelection.filter(function (p) {
        var out = p.jel !== jel;
        if (!out) {
          _this6.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
        }
        return out;
      });
    }
  }, {
    key: "toggle",
    value: function toggle(el) {
      var jel = el;
      var idx = findWithFunction(this._dragSelection, function (p) {
        return p.jel === jel;
      });
      if (idx !== -1) {
        this.remove(jel);
      } else {
        this.add(el);
      }
    }
  }]);
  return DragSelection;
}();

var CLASS_DELEGATED_DRAGGABLE = "jtk-delegated-draggable";
var CLASS_DRAGGABLE = "jtk-draggable";
var CLASS_DRAG_CONTAINER = "jtk-drag";
var CLASS_GHOST_PROXY = "jtk-ghost-proxy";
var CLASS_DRAG_ACTIVE = "jtk-drag-active";
var CLASS_DRAGGED = "jtk-dragged";
var CLASS_DRAG_HOVER = "jtk-drag-hover";
var jsplumb_browser_ui_es_DragManager = function () {
  function DragManager(instance, dragSelection, options) {
    var _this = this;
    jsplumb_browser_ui_es_classCallCheck(this, DragManager);
    this.instance = instance;
    this.dragSelection = dragSelection;
    jsplumb_browser_ui_es_defineProperty(this, "collicat", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "drag", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "_draggables", {});
    jsplumb_browser_ui_es_defineProperty(this, "_dlist", []);
    jsplumb_browser_ui_es_defineProperty(this, "_elementsWithEndpoints", {});
    jsplumb_browser_ui_es_defineProperty(this, "_draggablesForElements", {});
    jsplumb_browser_ui_es_defineProperty(this, "handlers", []);
    jsplumb_browser_ui_es_defineProperty(this, "_trackScroll", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "_filtersToAdd", []);
    this.collicat = new jsplumb_browser_ui_es_Collicat({
      zoom: this.instance.currentZoom,
      css: {
        noSelect: this.instance.dragSelectClass,
        delegatedDraggable: CLASS_DELEGATED_DRAGGABLE,
        draggable: CLASS_DRAGGABLE,
        drag: CLASS_DRAG_CONTAINER,
        selected: CLASS_DRAG_SELECTED,
        active: CLASS_DRAG_ACTIVE,
        hover: CLASS_DRAG_HOVER,
        ghostProxy: CLASS_GHOST_PROXY
      }
    });
    this.instance.bind(EVENT_ZOOM, function (z) {
      _this.collicat.setZoom(z);
    });
    options = options || {};
    this._trackScroll = options.trackScroll !== false;
  }
  jsplumb_browser_ui_es_createClass(DragManager, [{
    key: "addHandler",
    value: function addHandler(handler, dragOptions) {
      var _this2 = this;
      var o = extend({
        selector: handler.selector
      }, dragOptions || {});
      o.start = jsplumb_util_es_wrap(o.start, function (p) {
        return handler.onStart(p);
      });
      o.drag = jsplumb_util_es_wrap(o.drag, function (p) {
        return handler.onDrag(p);
      });
      o.stop = jsplumb_util_es_wrap(o.stop, function (p) {
        return handler.onStop(p);
      });
      o.beforeStart = (handler.onBeforeStart || function (p) {}).bind(handler);
      o.dragInit = function (el) {
        return handler.onDragInit(el);
      };
      o.dragAbort = function (el) {
        return handler.onDragAbort(el);
      };
      if (handler.useGhostProxy) {
        o.useGhostProxy = handler.useGhostProxy;
        o.makeGhostProxy = handler.makeGhostProxy;
      }
      if (o.constrainFunction == null && o.containment != null) {
        switch (o.containment) {
          case ContainmentType.notNegative:
            {
              o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                return {
                  x: Math.max(0, Math.min(pos.x)),
                  y: Math.max(0, Math.min(pos.y))
                };
              };
              break;
            }
          case ContainmentType.parent:
            {
              var padding = o.containmentPadding || 5;
              o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                var x = pos.x < 0 ? 0 : pos.x > _constrainRect.w - padding ? _constrainRect.w - padding : pos.x;
                var y = pos.y < 0 ? 0 : pos.y > _constrainRect.h - padding ? _constrainRect.h - padding : pos.y;
                return {
                  x: x,
                  y: y
                };
              };
              break;
            }
          case ContainmentType.parentEnclosed:
            {
              o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                var x = pos.x < 0 ? 0 : pos.x + _size.w > _constrainRect.w ? _constrainRect.w - _size.w : pos.x;
                var y = pos.y < 0 ? 0 : pos.y + _size.h > _constrainRect.h ? _constrainRect.h - _size.h : pos.y;
                return {
                  x: x,
                  y: y
                };
              };
              break;
            }
        }
      }
      if (this.drag == null) {
        o.trackScroll = this._trackScroll;
        this.drag = this.collicat.draggable(this.instance.getContainer(), o);
        forEach(this._filtersToAdd, function (filterToAdd) {
          return _this2.drag.addFilter(filterToAdd[0], filterToAdd[1]);
        });
        this.drag.on(EVENT_REVERT, function (el) {
          _this2.instance.revalidate(el);
        });
      } else {
        this.drag.addSelector(o);
      }
      this.handlers.push({
        handler: handler,
        options: o
      });
      handler.init(this.drag);
    }
  }, {
    key: "addFilter",
    value: function addFilter(filter, exclude) {
      if (this.drag == null) {
        this._filtersToAdd.push([filter, exclude === true]);
      } else {
        this.drag.addFilter(filter, exclude);
      }
    }
  }, {
    key: "removeFilter",
    value: function removeFilter(filter) {
      if (this.drag != null) {
        this.drag.removeFilter(filter);
      }
    }
  }, {
    key: "setFilters",
    value: function setFilters(filters) {
      var _this3 = this;
      forEach(filters, function (f) {
        _this3.drag.addFilter(f[0], f[1]);
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var out = [];
      forEach(this.handlers, function (p) {
        p.handler.reset();
      });
      if (this.drag != null) {
        var currentFilters = this.drag._filters;
        for (var f in currentFilters) {
          out.push([f, currentFilters[f][1]]);
        }
        this.collicat.destroyDraggable(this.instance.getContainer());
      }
      delete this.drag;
      return out;
    }
  }, {
    key: "setOption",
    value: function setOption(handler, options) {
      var handlerAndOptions = getWithFunction(this.handlers, function (p) {
        return p.handler === handler;
      });
      if (handlerAndOptions != null) {
        extend(handlerAndOptions.options, options || {});
      }
    }
  }]);
  return DragManager;
}();

function decodeDragGroupSpec(instance, spec) {
  if (isString(spec)) {
    return {
      id: spec,
      active: true
    };
  } else {
    return {
      id: instance.getId(spec),
      active: spec.active
    };
  }
}
function isActiveDragGroupMember(dragGroup, el) {
  var details = getFromSetWithFunction(dragGroup.members, function (m) {
    return m.el === el;
  });
  if (details !== null) {
    return details.active === true;
  } else {
    return false;
  }
}
function getAncestors(el) {
  var ancestors = [];
  var p = el._jsPlumbParentGroup;
  while (p != null) {
    ancestors.push(p.el);
    p = p.group;
  }
  return ancestors;
}
var jsplumb_browser_ui_es_ElementDragHandler = function () {
  function ElementDragHandler(instance, _dragSelection) {
    jsplumb_browser_ui_es_classCallCheck(this, ElementDragHandler);
    this.instance = instance;
    this._dragSelection = _dragSelection;
    jsplumb_browser_ui_es_defineProperty(this, "selector", "> " + SELECTOR_MANAGED_ELEMENT + ":not(" + cls(CLASS_OVERLAY) + ")");
    jsplumb_browser_ui_es_defineProperty(this, "_dragOffset", null);
    jsplumb_browser_ui_es_defineProperty(this, "_groupLocations", []);
    jsplumb_browser_ui_es_defineProperty(this, "_intersectingGroups", []);
    jsplumb_browser_ui_es_defineProperty(this, "_currentDragParentGroup", null);
    jsplumb_browser_ui_es_defineProperty(this, "_dragGroupByElementIdMap", {});
    jsplumb_browser_ui_es_defineProperty(this, "_dragGroupMap", {});
    jsplumb_browser_ui_es_defineProperty(this, "_currentDragGroup", null);
    jsplumb_browser_ui_es_defineProperty(this, "_currentDragGroupOffsets", new Map());
    jsplumb_browser_ui_es_defineProperty(this, "_currentDragGroupSizes", new Map());
    jsplumb_browser_ui_es_defineProperty(this, "_dragPayload", null);
    jsplumb_browser_ui_es_defineProperty(this, "drag", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "originalPosition", void 0);
  }
  jsplumb_browser_ui_es_createClass(ElementDragHandler, [{
    key: "onDragInit",
    value: function onDragInit(el) {
      return null;
    }
  }, {
    key: "onDragAbort",
    value: function onDragAbort(el) {
      return null;
    }
  }, {
    key: "getDropGroup",
    value: function getDropGroup() {
      var dropGroup = null;
      if (this._intersectingGroups.length > 0) {
        var targetGroup = this._intersectingGroups[0].groupLoc.group;
        var intersectingElement = this._intersectingGroups[0].intersectingElement;
        var currentGroup = intersectingElement._jsPlumbParentGroup;
        if (currentGroup !== targetGroup) {
          if (currentGroup == null || !currentGroup.overrideDrop(intersectingElement, targetGroup)) {
            dropGroup = this._intersectingGroups[0];
          }
        }
      }
      return dropGroup;
    }
  }, {
    key: "onStop",
    value: function onStop(params) {
      var _this = this;
      var jel = params.drag.getDragElement();
      var dropGroup = this.getDropGroup();
      var elementsToProcess = [];
      elementsToProcess.push({
        el: jel,
        id: this.instance.getId(jel),
        pos: params.finalPos,
        originalGroup: jel._jsPlumbParentGroup,
        redrawResult: null,
        originalPos: params.originalPos,
        reverted: false,
        dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
      });
      this._dragSelection.each(function (el, id, o, s, orig) {
        if (el !== params.el) {
          var pp = {
            x: o.x,
            y: o.y
          };
          var x = pp.x,
              y = pp.y;
          if (el._jsPlumbParentGroup && el._jsPlumbParentGroup.constrain) {
            var constrainRect = {
              w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
              h: el.parentNode.offsetHeight + el.parentNode.scrollTop
            };
            x = Math.max(x, 0);
            y = Math.max(y, 0);
            x = Math.min(x, constrainRect.w - s.w);
            y = Math.min(y, constrainRect.h - s.h);
            pp.x = x;
            pp.y = y;
          }
          elementsToProcess.push({
            el: el,
            id: id,
            pos: pp,
            originalPos: orig,
            originalGroup: el._jsPlumbParentGroup,
            redrawResult: null,
            reverted: false,
            dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
          });
        }
      });
      forEach(elementsToProcess, function (p) {
        var wasInGroup = p.originalGroup != null,
            isInOriginalGroup = wasInGroup && isInsideParent(_this.instance, p.el, p.pos),
            parentOffset = {
          x: 0,
          y: 0
        };
        if (wasInGroup && !isInOriginalGroup) {
          if (dropGroup == null) {
            var orphanedPosition = _this._pruneOrOrphan(p, true, true);
            if (orphanedPosition.pos != null) {
              p.pos = orphanedPosition.pos.pos;
            } else {
              if (!orphanedPosition.pruned && p.originalGroup.revert) {
                p.pos = p.originalPos;
                p.reverted = true;
              }
            }
          }
        } else if (wasInGroup && isInOriginalGroup) {
          parentOffset = _this.instance.viewport.getPosition(p.originalGroup.elId);
        }
        if (dropGroup != null && !isInOriginalGroup) {
          _this.instance.groupManager.addToGroup(dropGroup.groupLoc.group, false, p.el);
        } else {
          p.dropGroup = null;
        }
        if (p.reverted) {
          _this.instance.setPosition(p.el, p.pos);
        }
        p.redrawResult = _this.instance.setElementPosition(p.el, p.pos.x + parentOffset.x, p.pos.y + parentOffset.y);
        _this.instance.removeClass(p.el, CLASS_DRAGGED);
        _this.instance.select({
          source: p.el
        }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.sourceElementDraggingClass, true);
        _this.instance.select({
          target: p.el
        }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.targetElementDraggingClass, true);
      });
      if (elementsToProcess[0].originalGroup != null) {
        var currentGroup = jel._jsPlumbParentGroup;
        if (currentGroup !== elementsToProcess[0].originalGroup) {
          var originalElement = params.drag.getDragElement(true);
          if (elementsToProcess[0].originalGroup.ghost) {
            var o1 = this.instance.getOffset(this.instance.getGroupContentArea(currentGroup));
            var o2 = this.instance.getOffset(this.instance.getGroupContentArea(elementsToProcess[0].originalGroup));
            var o = {
              x: o2.x + params.pos.x - o1.x,
              y: o2.y + params.pos.y - o1.y
            };
            originalElement.style.left = o.x + "px";
            originalElement.style.top = o.y + "px";
            this.instance.revalidate(originalElement);
          }
        }
      }
      this.instance.fire(EVENT_DRAG_STOP, {
        elements: elementsToProcess,
        e: params.e,
        el: jel,
        payload: this._dragPayload
      });
      this._cleanup();
    }
  }, {
    key: "_cleanup",
    value: function _cleanup() {
      var _this2 = this;
      forEach(this._groupLocations, function (groupLoc) {
        _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_ACTIVE);
        _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
      });
      this._currentDragParentGroup = null;
      this._groupLocations.length = 0;
      this.instance.hoverSuspended = false;
      this._dragOffset = null;
      this._dragSelection.reset();
      this._dragPayload = null;
      this._currentDragGroupOffsets.clear();
      this._currentDragGroupSizes.clear();
      this._currentDragGroup = null;
    }
  }, {
    key: "reset",
    value: function reset() {}
  }, {
    key: "init",
    value: function init(drag) {
      this.drag = drag;
    }
  }, {
    key: "onDrag",
    value: function onDrag(params) {
      var _this3 = this;
      var el = params.drag.getDragElement();
      var finalPos = params.pos;
      var elSize = this.instance.getSize(el);
      var ui = {
        x: finalPos.x,
        y: finalPos.y
      };
      this._intersectingGroups.length = 0;
      if (this._dragOffset != null) {
        ui.x += this._dragOffset.x;
        ui.y += this._dragOffset.y;
      }
      var _one = function _one(el, bounds, findIntersectingGroups) {
        if (findIntersectingGroups) {
          var ancestorsOfIntersectingGroups = new Set();
          forEach(_this3._groupLocations, function (groupLoc) {
            if (!ancestorsOfIntersectingGroups.has(groupLoc.group.id) && intersects(bounds, groupLoc.r)) {
              if (groupLoc.group !== _this3._currentDragParentGroup) {
                _this3.instance.addClass(groupLoc.el, CLASS_DRAG_HOVER);
              }
              _this3._intersectingGroups.push({
                groupLoc: groupLoc,
                intersectingElement: params.drag.getDragElement(true),
                d: 0
              });
              forEach(_this3.instance.groupManager.getAncestors(groupLoc.group), function (g) {
                return ancestorsOfIntersectingGroups.add(g.id);
              });
            } else {
              _this3.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
            }
          });
        }
        _this3.instance.setElementPosition(el, bounds.x, bounds.y);
        _this3.instance.fire(EVENT_DRAG_MOVE, {
          el: el,
          e: params.e,
          pos: {
            x: bounds.x,
            y: bounds.y
          },
          originalPosition: _this3.originalPosition,
          payload: _this3._dragPayload
        });
      };
      var elBounds = {
        x: ui.x,
        y: ui.y,
        w: elSize.w,
        h: elSize.h
      };
      _one(el, elBounds, true);
      this._dragSelection.updatePositions(finalPos, this.originalPosition, function (el, id, s, b) {
        _one(el, b, false);
      });
      this._currentDragGroupOffsets.forEach(function (v, k) {
        var s = _this3._currentDragGroupSizes.get(k);
        var _b = {
          x: elBounds.x + v[0].x,
          y: elBounds.y + v[0].y,
          w: s.w,
          h: s.h
        };
        v[1].style.left = _b.x + "px";
        v[1].style.top = _b.y + "px";
        _one(v[1], _b, false);
      });
    }
  }, {
    key: "onStart",
    value: function onStart(params) {
      var _this4 = this;
      var el = params.drag.getDragElement();
      var elOffset = this.instance.getOffset(el);
      this.originalPosition = {
        x: params.pos.x,
        y: params.pos.y
      };
      if (el._jsPlumbParentGroup) {
        this._dragOffset = this.instance.getOffset(el.offsetParent);
        this._currentDragParentGroup = el._jsPlumbParentGroup;
      }
      var cont = true;
      var nd = el.getAttribute(ATTRIBUTE_NOT_DRAGGABLE);
      if (this.instance.elementsDraggable === false || nd != null && nd !== FALSE) {
        cont = false;
      }
      if (cont) {
        this._groupLocations.length = 0;
        this._intersectingGroups.length = 0;
        this.instance.hoverSuspended = true;
        var originalElement = params.drag.getDragElement(true),
            descendants = originalElement.querySelectorAll(SELECTOR_MANAGED_ELEMENT),
            ancestors = getAncestors(originalElement),
            a = [];
        Array.prototype.push.apply(a, descendants);
        Array.prototype.push.apply(a, ancestors);
        this._dragSelection.filterActiveSet(function (p) {
          return a.indexOf(p.jel) === -1;
        });
        this._dragSelection.initialisePositions();
        var _one = function _one(_el) {
          if (!_el._isJsPlumbGroup || _this4.instance.allowNestedGroups) {
            var isNotInAGroup = !_el._jsPlumbParentGroup;
            var membersAreDroppable = isNotInAGroup || _el._jsPlumbParentGroup.dropOverride !== true;
            var isGhostOrNotConstrained = !isNotInAGroup && (_el._jsPlumbParentGroup.ghost || _el._jsPlumbParentGroup.constrain !== true);
            if (isNotInAGroup || membersAreDroppable && isGhostOrNotConstrained) {
              forEach(_this4.instance.groupManager.getGroups(), function (group) {
                var elementGroup = _el._jsPlumbGroup;
                if (group.droppable !== false && group.enabled !== false && _el._jsPlumbGroup !== group && !_this4.instance.groupManager.isDescendant(group, elementGroup)) {
                  var groupEl = group.el,
                      s = _this4.instance.getSize(groupEl),
                      o = _this4.instance.getOffset(groupEl),
                      boundingRect = {
                    x: o.x,
                    y: o.y,
                    w: s.w,
                    h: s.h
                  };
                  var groupLocation = {
                    el: groupEl,
                    r: boundingRect,
                    group: group
                  };
                  _this4._groupLocations.push(groupLocation);
                  if (group !== _this4._currentDragParentGroup) {
                    _this4.instance.addClass(groupEl, CLASS_DRAG_ACTIVE);
                  }
                }
              });
              _this4._groupLocations.sort(function (a, b) {
                if (_this4.instance.groupManager.isDescendant(a.group, b.group)) {
                  return -1;
                } else if (_this4.instance.groupManager.isAncestor(b.group, a.group)) {
                  return 1;
                } else {
                  return 0;
                }
              });
            }
          }
          _this4.instance.select({
            source: _el
          }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.sourceElementDraggingClass, true);
          _this4.instance.select({
            target: _el
          }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.targetElementDraggingClass, true);
          return _this4.instance.fire(EVENT_DRAG_START, {
            el: _el,
            e: params.e,
            originalPosition: _this4.originalPosition,
            pos: _this4.originalPosition
          });
        };
        var elId = this.instance.getId(el);
        this._currentDragGroup = this._dragGroupByElementIdMap[elId];
        if (this._currentDragGroup && !isActiveDragGroupMember(this._currentDragGroup, el)) {
          this._currentDragGroup = null;
        }
        var dragStartReturn = _one(el);
        if (dragStartReturn === false) {
          this._cleanup();
          return false;
        } else {
          this._dragPayload = dragStartReturn;
        }
        if (this._currentDragGroup != null) {
          this._currentDragGroupOffsets.clear();
          this._currentDragGroupSizes.clear();
          this._currentDragGroup.members.forEach(function (jel) {
            var off = _this4.instance.getOffset(jel.el);
            _this4._currentDragGroupOffsets.set(jel.elId, [{
              x: off.x - elOffset.x,
              y: off.y - elOffset.y
            }, jel.el]);
            _this4._currentDragGroupSizes.set(jel.elId, _this4.instance.getSize(jel.el));
            _one(jel.el);
          });
        }
      }
      return cont;
    }
  }, {
    key: "addToDragGroup",
    value: function addToDragGroup(spec) {
      var _this5 = this;
      var details = decodeDragGroupSpec(this.instance, spec);
      var dragGroup = this._dragGroupMap[details.id];
      if (dragGroup == null) {
        dragGroup = {
          id: details.id,
          members: new Set()
        };
        this._dragGroupMap[details.id] = dragGroup;
      }
      for (var _len = arguments.length, els = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        els[_key - 1] = arguments[_key];
      }
      this.removeFromDragGroup.apply(this, els);
      forEach(els, function (el) {
        var elId = _this5.instance.getId(el);
        dragGroup.members.add({
          elId: elId,
          el: el,
          active: details.active
        });
        _this5._dragGroupByElementIdMap[elId] = dragGroup;
      });
    }
  }, {
    key: "removeFromDragGroup",
    value: function removeFromDragGroup() {
      var _this6 = this;
      for (var _len2 = arguments.length, els = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        els[_key2] = arguments[_key2];
      }
      forEach(els, function (el) {
        var id = _this6.instance.getId(el);
        var dragGroup = _this6._dragGroupByElementIdMap[id];
        if (dragGroup != null) {
          var s = new Set();
          dragGroup.members.forEach(function (member) {
            if (member.el !== el) {
              s.add(member);
            }
          });
          dragGroup.members = s;
          delete _this6._dragGroupByElementIdMap[id];
        }
      });
    }
  }, {
    key: "setDragGroupState",
    value: function setDragGroupState(state) {
      var _this7 = this;
      for (var _len3 = arguments.length, els = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        els[_key3 - 1] = arguments[_key3];
      }
      var elementIds = els.map(function (el) {
        return _this7.instance.getId(el);
      });
      forEach(elementIds, function (id) {
        var dragGroup = _this7._dragGroupByElementIdMap[id];
        if (dragGroup != null) {
          var member = getFromSetWithFunction(dragGroup.members, function (m) {
            return m.elId === id;
          });
          if (member != null) {
            member.active = state;
          }
        }
      });
    }
  }, {
    key: "_pruneOrOrphan",
    value: function _pruneOrOrphan(params, doNotTransferToAncestor, isDefinitelyNotInsideParent) {
      var jel = params.el;
      var orphanedPosition = {
        pruned: false,
        pos: null
      };
      if (isDefinitelyNotInsideParent || !isInsideParent(this.instance, jel, params.pos)) {
        var group = jel._jsPlumbParentGroup;
        if (group.prune) {
          if (jel._isJsPlumbGroup) {
            this.instance.removeGroup(jel._jsPlumbGroup);
          } else {
            group.remove(params.el, true);
          }
          orphanedPosition.pruned = true;
        } else if (group.orphan) {
          orphanedPosition.pos = this.instance.groupManager.orphan(params.el, doNotTransferToAncestor);
          if (jel._isJsPlumbGroup) {
            group.removeGroup(jel._jsPlumbGroup);
          } else {
            group.remove(params.el);
          }
        }
      }
      return orphanedPosition;
    }
  }]);
  return ElementDragHandler;
}();

function _makeFloatingEndpoint(paintStyle, endpoint, referenceCanvas, sourceElement, instance, scope) {
  var floatingAnchor = createFloatingAnchor(instance, sourceElement);
  var p = {
    paintStyle: paintStyle,
    preparedAnchor: floatingAnchor,
    element: sourceElement,
    scope: scope
  };
  if (endpoint != null) {
    if (isAssignableFrom(endpoint, jsplumb_core_es_EndpointRepresentation)) {
      p.existingEndpoint = endpoint;
    } else {
      p.endpoint = endpoint;
    }
  }
  var ep = instance._internal_newEndpoint(p);
  instance.paintEndpoint(ep, {});
  return ep;
}
function selectorFilter(evt, _el, selector, _instance, negate) {
  var t = evt.target || evt.srcElement,
      ok = false,
      sel = _instance.getSelector(_el, selector);
  for (var j = 0; j < sel.length; j++) {
    if (sel[j] === t) {
      ok = true;
      break;
    }
  }
  return negate ? !ok : ok;
}
var SELECTOR_DRAG_ACTIVE_OR_HOVER = cls(CLASS_DRAG_ACTIVE, CLASS_DRAG_HOVER);
var jsplumb_browser_ui_es_EndpointDragHandler = function () {
  function EndpointDragHandler(instance) {
    jsplumb_browser_ui_es_classCallCheck(this, EndpointDragHandler);
    this.instance = instance;
    jsplumb_browser_ui_es_defineProperty(this, "jpc", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "existingJpc", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "_originalAnchor", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "ep", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "endpointRepresentation", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "canvasElement", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "_activeDefinition", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "placeholderInfo", {
      id: null,
      element: null
    });
    jsplumb_browser_ui_es_defineProperty(this, "floatingIndex", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "floatingId", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "floatingElement", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "floatingEndpoint", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "floatingAnchor", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "_stopped", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "inPlaceCopy", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "endpointDropTargets", []);
    jsplumb_browser_ui_es_defineProperty(this, "currentDropTarget", null);
    jsplumb_browser_ui_es_defineProperty(this, "payload", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "floatingConnections", {});
    jsplumb_browser_ui_es_defineProperty(this, "_forceReattach", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "_forceDetach", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "mousedownHandler", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "mouseupHandler", void 0);
    jsplumb_browser_ui_es_defineProperty(this, "selector", cls(CLASS_ENDPOINT));
    var container = instance.getContainer();
    this.mousedownHandler = this._mousedownHandler.bind(this);
    this.mouseupHandler = this._mouseupHandler.bind(this);
    instance.on(container, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this.mousedownHandler);
    instance.on(container, EVENT_MOUSEUP, SELECTOR_MANAGED_ELEMENT, this.mouseupHandler);
  }
  jsplumb_browser_ui_es_createClass(EndpointDragHandler, [{
    key: "_resolveDragParent",
    value: function _resolveDragParent(def, eventTarget) {
      var container = this.instance.getContainer();
      var parent = findParent(eventTarget, SELECTOR_MANAGED_ELEMENT, container, true);
      if (def.parentSelector != null) {
        var child = findParent(eventTarget, def.parentSelector, container, true);
        if (child != null) {
          parent = findParent(child.parentNode, SELECTOR_MANAGED_ELEMENT, container, false);
        }
        return child || parent;
      } else {
        return parent;
      }
    }
  }, {
    key: "_mousedownHandler",
    value: function _mousedownHandler(e) {
      var sourceEl;
      var sourceDef;
      if (e.which === 3 || e.button === 2) {
        return;
      }
      var eventTarget = e.target || e.srcElement;
      sourceDef = this._getSourceDefinition(e);
      if (sourceDef != null) {
        sourceEl = this._resolveDragParent(sourceDef.def, eventTarget);
        if (sourceEl == null || sourceEl.getAttribute(ATTRIBUTE_JTK_ENABLED) === FALSE) {
          return;
        }
      }
      if (sourceDef) {
        var sourceElement = e.currentTarget,
            def;
        if (eventTarget.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE) {
          consume(e);
          this._activeDefinition = sourceDef;
          def = sourceDef.def;
          var sourceCount = this.instance.select({
            source: sourceEl
          }).length;
          if (sourceDef.maxConnections >= 0 && sourceCount >= sourceDef.maxConnections) {
            consume(e);
            if (def.onMaxConnections) {
              def.onMaxConnections({
                element: sourceEl,
                maxConnections: sourceDef.maxConnections
              }, e);
            }
            e.stopImmediatePropagation && e.stopImmediatePropagation();
            return false;
          }
          var elxy = getPositionOnElement(e, sourceEl, this.instance.currentZoom);
          var tempEndpointParams = {
            element: sourceEl
          };
          extend(tempEndpointParams, def);
          tempEndpointParams.isTemporarySource = true;
          if (def.scope) {
            tempEndpointParams.scope = def.scope;
          } else {
            var scopeFromElement = eventTarget.getAttribute(ATTRIBUTE_JTK_SCOPE);
            if (scopeFromElement != null) {
              tempEndpointParams.scope = scopeFromElement;
            }
          }
          var extractedParameters = def.parameterExtractor ? def.parameterExtractor(sourceEl, eventTarget) : {};
          tempEndpointParams = merge(tempEndpointParams, extractedParameters);
          this._originalAnchor = tempEndpointParams.anchor || this.instance.defaults.anchor;
          tempEndpointParams.anchor = [elxy.x, elxy.y, 0, 0];
          tempEndpointParams.deleteOnEmpty = true;
          this.ep = this.instance._internal_newEndpoint(tempEndpointParams);
          var payload = {};
          if (def.extract) {
            for (var att in def.extract) {
              var v = eventTarget.getAttribute(att);
              if (v) {
                payload[def.extract[att]] = v;
              }
            }
            this.ep.mergeParameters(payload);
          }
          if (def.uniqueEndpoint) {
            if (!sourceDef.endpoint) {
              sourceDef.endpoint = this.ep;
              this.ep.deleteOnEmpty = false;
            } else {
              this.ep.finalEndpoint = sourceDef.endpoint;
            }
          }
          sourceElement._jsPlumbOrphanedEndpoints = sourceElement._jsPlumbOrphanedEndpoints || [];
          sourceElement._jsPlumbOrphanedEndpoints.push(this.ep);
          this.instance.trigger(this.ep.endpoint.canvas, EVENT_MOUSEDOWN, e, payload);
        }
      }
    }
  }, {
    key: "_mouseupHandler",
    value: function _mouseupHandler(e) {
      var el = e.currentTarget || e.srcElement;
      if (el._jsPlumbOrphanedEndpoints) {
        jsplumb_util_es_each(el._jsPlumbOrphanedEndpoints, this.instance._maybePruneEndpoint.bind(this.instance));
        el._jsPlumbOrphanedEndpoints.length = 0;
      }
      this._activeDefinition = null;
    }
  }, {
    key: "onDragInit",
    value: function onDragInit(el) {
      var ipco = this.instance.getOffset(el),
          ips = this.instance.getSize(el);
      this._makeDraggablePlaceholder(ipco, ips);
      this.placeholderInfo.element.jtk = el.jtk;
      return this.placeholderInfo.element;
    }
  }, {
    key: "onDragAbort",
    value: function onDragAbort(el) {
      this._cleanupDraggablePlaceholder();
    }
  }, {
    key: "_makeDraggablePlaceholder",
    value: function _makeDraggablePlaceholder(ipco, ips) {
      this.placeholderInfo = this.placeholderInfo || {};
      var n = createElement(ELEMENT_DIV, {
        position: "absolute"
      });
      this.instance._appendElement(n, this.instance.getContainer());
      var id = this.instance.getId(n);
      this.instance.setPosition(n, ipco);
      n.style.width = ips.w + "px";
      n.style.height = ips.h + "px";
      this.instance.manage(n);
      this.placeholderInfo.id = id;
      this.placeholderInfo.element = n;
      return n;
    }
  }, {
    key: "_cleanupDraggablePlaceholder",
    value: function _cleanupDraggablePlaceholder() {
      if (this.placeholderInfo.element) {
        this.instance.unmanage(this.placeholderInfo.element, true);
        delete this.placeholderInfo.element;
        delete this.placeholderInfo.id;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      var c = this.instance.getContainer();
      this.instance.off(c, EVENT_MOUSEUP, this.mouseupHandler);
      this.instance.off(c, EVENT_MOUSEDOWN, this.mousedownHandler);
    }
  }, {
    key: "init",
    value: function init(drag) {}
  }, {
    key: "startNewConnectionDrag",
    value: function startNewConnectionDrag(scope, data) {
      this.jpc = this.instance._newConnection({
        sourceEndpoint: this.ep,
        targetEndpoint: this.floatingEndpoint,
        source: this.ep.element,
        target: this.placeholderInfo.element,
        paintStyle: this.ep.connectorStyle,
        hoverPaintStyle: this.ep.connectorHoverStyle,
        connector: this.ep.connector,
        overlays: this.ep.connectorOverlays,
        type: this.ep.edgeType,
        cssClass: this.ep.connectorClass,
        hoverClass: this.ep.connectorHoverClass,
        scope: scope,
        data: data
      });
      this.jpc.pending = true;
      this.jpc.addClass(this.instance.draggingClass);
      this.floatingEndpoint.addClass(this.instance.draggingClass);
      this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
    }
  }, {
    key: "startExistingConnectionDrag",
    value: function startExistingConnectionDrag() {
      this.existingJpc = true;
      this.instance.setHover(this.jpc, false);
      var anchorIdx = this.jpc.endpoints[0].id === this.ep.id ? 0 : 1;
      this.ep.detachFromConnection(this.jpc, null, true);
      this.floatingEndpoint.addConnection(this.jpc);
      this.floatingEndpoint.addClass(this.instance.draggingClass);
      this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
      this.instance.sourceOrTargetChanged(this.jpc.endpoints[anchorIdx].elementId, this.placeholderInfo.id, this.jpc, this.placeholderInfo.element, anchorIdx);
      this.jpc.suspendedEndpoint = this.jpc.endpoints[anchorIdx];
      this.jpc.suspendedElement = this.jpc.endpoints[anchorIdx].element;
      this.jpc.suspendedElementId = this.jpc.endpoints[anchorIdx].elementId;
      this.jpc.suspendedElementType = anchorIdx === 0 ? SOURCE : TARGET;
      this.instance.setHover(this.jpc.suspendedEndpoint, false);
      this.floatingEndpoint.referenceEndpoint = this.jpc.suspendedEndpoint;
      this.floatingEndpoint.mergeParameters(this.jpc.suspendedEndpoint.parameters);
      this.jpc.endpoints[anchorIdx] = this.floatingEndpoint;
      this.jpc.addClass(this.instance.draggingClass);
      this.floatingId = this.placeholderInfo.id;
      this.floatingIndex = anchorIdx;
    }
  }, {
    key: "_shouldStartDrag",
    value: function _shouldStartDrag() {
      var _continue = true;
      if (!this.ep.enabled) {
        _continue = false;
      }
      if (this.jpc == null && !this.ep.isSource && !this.ep.isTemporarySource) {
        _continue = false;
      }
      if (this.ep.isSource && this.ep.isFull() && !(this.jpc != null && this.ep.dragAllowedWhenFull)) {
        _continue = false;
      }
      if (this.jpc != null && !this.jpc.isDetachable(this.ep)) {
        if (this.ep.isFull()) {
          _continue = false;
        } else {
          this.jpc = null;
        }
      }
      var payload = {};
      var beforeDrag = this.instance.checkCondition(this.jpc == null ? INTERCEPT_BEFORE_DRAG : INTERCEPT_BEFORE_START_DETACH, {
        endpoint: this.ep,
        source: this.ep.element,
        sourceId: this.ep.elementId,
        connection: this.jpc
      });
      if (beforeDrag === false) {
        _continue = false;
      }
      else if (_typeof(beforeDrag) === "object") {
        payload = beforeDrag;
        extend(payload, this.payload || {});
      } else {
        payload = this.payload || {};
      }
      return [_continue, payload];
    }
  }, {
    key: "_createFloatingEndpoint",
    value: function _createFloatingEndpoint(canvasElement) {
      var endpointToFloat = this.ep.endpoint;
      if (this.ep.edgeType != null) {
        var aae = this.instance._deriveEndpointAndAnchorSpec(this.ep.edgeType);
        endpointToFloat = aae.endpoints[1];
      }
      this.floatingEndpoint = _makeFloatingEndpoint(this.ep.getPaintStyle(), endpointToFloat, canvasElement, this.placeholderInfo.element, this.instance, this.ep.scope);
      this.floatingAnchor = this.floatingEndpoint._anchor;
      this.floatingEndpoint.deleteOnEmpty = true;
      this.floatingElement = this.floatingEndpoint.endpoint.canvas;
      this.floatingId = this.instance.getId(this.floatingElement);
    }
  }, {
    key: "_populateTargets",
    value: function _populateTargets(canvasElement) {
      var _this = this;
      var isSourceDrag = this.jpc && this.jpc.endpoints[0] === this.ep;
      var boundingRect;
      var matchingEndpoints = this.instance.getContainer().querySelectorAll([".", CLASS_ENDPOINT, "[", ATTRIBUTE_SCOPE_PREFIX, this.ep.scope, "]"].join(""));
      forEach(matchingEndpoints, function (candidate) {
        if ((_this.jpc != null || candidate !== canvasElement) && candidate !== _this.floatingElement) {
          if (isSourceDrag && candidate.jtk.endpoint.isSource || !isSourceDrag && candidate.jtk.endpoint.isTarget) {
            var o = _this.instance.getOffset(candidate),
                s = _this.instance.getSize(candidate);
            boundingRect = {
              x: o.x,
              y: o.y,
              w: s.w,
              h: s.h
            };
            _this.endpointDropTargets.push({
              el: candidate,
              targetEl: candidate,
              r: boundingRect,
              endpoint: candidate.jtk.endpoint,
              def: null
            });
            _this.instance.addClass(candidate, CLASS_DRAG_ACTIVE);
          }
        }
      });
      if (isSourceDrag) {
        var sourceDef = getWithFunction(this.instance.sourceSelectors, function (sSel) {
          return sSel.isEnabled() && (sSel.def.def.scope == null || sSel.def.def.scope === _this.ep.scope);
        });
        if (sourceDef != null) {
          var targetZones = this.instance.getContainer().querySelectorAll(sourceDef.redrop === REDROP_POLICY_ANY ? SELECTOR_MANAGED_ELEMENT : sourceDef.selector);
          forEach(targetZones, function (el) {
            if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE) {
              var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
              if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                return;
              }
              var d = {
                r: null,
                el: el
              };
              d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
              var o = _this.instance.getOffset(d.el),
                  s = _this.instance.getSize(d.el);
              d.r = {
                x: o.x,
                y: o.y,
                w: s.w,
                h: s.h
              };
              if (sourceDef.def.def.rank != null) {
                d.rank = sourceDef.def.def.rank;
              }
              d.def = sourceDef;
              _this.endpointDropTargets.push(d);
              _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
            }
          });
        }
      } else {
        var targetDefs = getAllWithFunction(this.instance.targetSelectors, function (tSel) {
          return tSel.isEnabled();
        });
        targetDefs.forEach(function (targetDef) {
          var targetZones = _this.instance.getContainer().querySelectorAll(targetDef.selector);
          forEach(targetZones, function (el) {
            if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE) {
              var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
              if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                return;
              }
              var d = {
                r: null,
                el: el
              };
              if (targetDef.def.def.parentSelector != null) {
                d.targetEl = findParent(el, targetDef.def.def.parentSelector, _this.instance.getContainer(), true);
              }
              if (d.targetEl == null) {
                d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
              }
              if (targetDef.def.def.allowLoopback === false || _this._activeDefinition && _this._activeDefinition.def.allowLoopback === false) {
                if (d.targetEl === _this.ep.element) {
                  return;
                }
              }
              var o = _this.instance.getOffset(el),
                  s = _this.instance.getSize(el);
              d.r = {
                x: o.x,
                y: o.y,
                w: s.w,
                h: s.h
              };
              d.def = targetDef.def;
              if (targetDef.def.def.rank != null) {
                d.rank = targetDef.def.def.rank;
              }
              _this.endpointDropTargets.push(d);
              _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
            }
          });
        });
      }
      this.endpointDropTargets.sort(function (a, b) {
        if (a.targetEl._isJsPlumbGroup && !b.targetEl._isJsPlumbGroup) {
          return 1;
        } else if (!a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
          return -1;
        } else {
          if (a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
            if (_this.instance.groupManager.isAncestor(a.targetEl._jsPlumbGroup, b.targetEl._jsPlumbGroup)) {
              return -1;
            } else if (_this.instance.groupManager.isAncestor(b.targetEl._jsPlumbGroup, a.targetEl._jsPlumbGroup)) {
              return 1;
            }
          } else {
            if (a.rank != null && b.rank != null) {
              if (a.rank > b.rank) {
                return -1;
              } else if (a.rank < b.rank) {
                return 1;
              } else ;
            } else {
              return 0;
            }
          }
        }
      });
    }
  }, {
    key: "onStart",
    value: function onStart(p) {
      this.endpointDropTargets.length = 0;
      this.currentDropTarget = null;
      this._stopped = false;
      var dragEl = p.drag.getDragElement();
      this.ep = dragEl.jtk.endpoint;
      if (!this.ep) {
        return false;
      }
      this.endpointRepresentation = this.ep.endpoint;
      this.canvasElement = this.endpointRepresentation.canvas;
      this.jpc = this.ep.connectorSelector();
      var _this$_shouldStartDra = this._shouldStartDrag(),
          _this$_shouldStartDra2 = jsplumb_browser_ui_es_slicedToArray(_this$_shouldStartDra, 2),
          _continue = _this$_shouldStartDra2[0],
          payload = _this$_shouldStartDra2[1];
      if (_continue === false) {
        this._stopped = true;
        return false;
      }
      this.instance.setHover(this.ep, false);
      this.instance.isConnectionBeingDragged = true;
      if (this.jpc && !this.ep.isFull() && this.ep.isSource) {
        this.jpc = null;
      }
      this._createFloatingEndpoint(this.canvasElement);
      this._populateTargets(this.canvasElement);
      if (this.jpc == null) {
        this.startNewConnectionDrag(this.ep.scope, payload);
      } else {
        this.startExistingConnectionDrag();
      }
      this._registerFloatingConnection(this.placeholderInfo, this.jpc, this.floatingEndpoint);
      this.instance.currentlyDragging = true;
    }
  }, {
    key: "onBeforeStart",
    value: function onBeforeStart(beforeStartParams) {
      this.payload = beforeStartParams.e.payload || {};
    }
  }, {
    key: "onDrag",
    value: function onDrag(params) {
      if (this._stopped) {
        return true;
      }
      if (this.placeholderInfo.element) {
        var floatingElementSize = this.instance.getSize(this.floatingElement);
        this.instance.setElementPosition(this.placeholderInfo.element, params.pos.x, params.pos.y);
        var boundingRect = {
          x: params.pos.x,
          y: params.pos.y,
          w: floatingElementSize.w,
          h: floatingElementSize.h
        },
            newDropTarget,
            idx,
            _cont;
        for (var i = 0; i < this.endpointDropTargets.length; i++) {
          if (intersects(boundingRect, this.endpointDropTargets[i].r)) {
            newDropTarget = this.endpointDropTargets[i];
            break;
          }
        }
        if (newDropTarget !== this.currentDropTarget && this.currentDropTarget != null) {
          idx = this._getFloatingAnchorIndex();
          this.instance.removeClass(this.currentDropTarget.el, CLASS_DRAG_HOVER);
          if (this.currentDropTarget.endpoint) {
            this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
            this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
          }
          this.floatingAnchor.out();
        }
        if (newDropTarget != null) {
          this.instance.addClass(newDropTarget.el, CLASS_DRAG_HOVER);
          idx = this._getFloatingAnchorIndex();
          if (newDropTarget.endpoint != null) {
            _cont = newDropTarget.endpoint.isSource && idx === 0 || newDropTarget.endpoint.isTarget && idx !== 0 || this.jpc.suspendedEndpoint && newDropTarget.endpoint.referenceEndpoint && newDropTarget.endpoint.referenceEndpoint.id === this.jpc.suspendedEndpoint.id;
            if (_cont) {
              var bb = this.instance.checkCondition(CHECK_DROP_ALLOWED, {
                sourceEndpoint: this.jpc.endpoints[idx],
                targetEndpoint: newDropTarget.endpoint.endpoint,
                connection: this.jpc
              });
              if (bb) {
                newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropAllowedClass);
                newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
              } else {
                newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
                newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropForbiddenClass);
              }
              this.floatingAnchor.over(newDropTarget.endpoint);
            } else {
              newDropTarget = null;
            }
          }
        }
        this.currentDropTarget = newDropTarget;
      }
    }
  }, {
    key: "_maybeCleanup",
    value: function _maybeCleanup(ep) {
      if (ep._mtNew && ep.connections.length === 0) {
        this.instance.deleteEndpoint(ep);
      } else {
        delete ep._mtNew;
      }
    }
  }, {
    key: "_reattachOrDiscard",
    value: function _reattachOrDiscard(originalEvent) {
      var existingConnection = this.jpc.suspendedEndpoint != null;
      var idx = this._getFloatingAnchorIndex();
      if (existingConnection && this._shouldReattach(originalEvent)) {
        if (idx === 0) {
          this.jpc.source = this.jpc.suspendedElement;
          this.jpc.sourceId = this.jpc.suspendedElementId;
        } else {
          this.jpc.target = this.jpc.suspendedElement;
          this.jpc.targetId = this.jpc.suspendedElementId;
        }
        this._doForceReattach(idx);
        return true;
      } else {
        this._discard(idx, originalEvent);
        return false;
      }
    }
  }, {
    key: "onStop",
    value: function onStop(p) {
      var _this2 = this;
      var originalEvent = p.e;
      this.instance.isConnectionBeingDragged = false;
      this.instance.currentlyDragging = false;
      var classesToRemove = jsplumb_core_es_classList(CLASS_DRAG_HOVER, CLASS_DRAG_ACTIVE);
      var matchingSelectors = this.instance.getContainer().querySelectorAll(SELECTOR_DRAG_ACTIVE_OR_HOVER);
      forEach(matchingSelectors, function (el) {
        _this2.instance.removeClass(el, classesToRemove);
      });
      if (this.jpc && this.jpc.endpoints != null) {
        var existingConnection = this.jpc.suspendedEndpoint != null;
        var idx = this._getFloatingAnchorIndex();
        var suspendedEndpoint = this.jpc.suspendedEndpoint;
        var dropEndpoint;
        if (this.currentDropTarget != null) {
          dropEndpoint = this._getDropEndpoint(p, this.jpc);
          if (dropEndpoint == null) {
            !this._reattachOrDiscard(p.e);
          } else {
            if (suspendedEndpoint && suspendedEndpoint.id === dropEndpoint.id) {
              this._doForceReattach(idx);
            } else {
              if (!dropEndpoint.enabled) {
                this._reattachOrDiscard(p.e);
              } else if (dropEndpoint.isFull()) {
                dropEndpoint.fire(EVENT_MAX_CONNECTIONS, {
                  endpoint: this,
                  connection: this.jpc,
                  maxConnections: this.instance.defaults.maxConnections
                }, originalEvent);
                this._reattachOrDiscard(p.e);
              } else {
                if (idx === 0) {
                  this.jpc.source = dropEndpoint.element;
                  this.jpc.sourceId = dropEndpoint.elementId;
                } else {
                  this.jpc.target = dropEndpoint.element;
                  this.jpc.targetId = dropEndpoint.elementId;
                }
                var _doContinue = true;
                if (existingConnection && this.jpc.suspendedEndpoint.id !== dropEndpoint.id) {
                  if (!this.jpc.isDetachAllowed(this.jpc) || !this.jpc.endpoints[idx].isDetachAllowed(this.jpc) || !this.jpc.suspendedEndpoint.isDetachAllowed(this.jpc) || !this.instance.checkCondition("beforeDetach", this.jpc)) {
                    _doContinue = false;
                  }
                }
                _doContinue = _doContinue && dropEndpoint.isDropAllowed(this.jpc.sourceId, this.jpc.targetId, this.jpc.scope, this.jpc, dropEndpoint);
                if (_doContinue) {
                  this._drop(dropEndpoint, idx, originalEvent, _doContinue);
                } else {
                  this._reattachOrDiscard(p.e);
                }
              }
            }
          }
        } else {
          this._reattachOrDiscard(p.e);
        }
        this.instance.refreshEndpoint(this.ep);
        this.ep.removeClass(this.instance.draggingClass);
        this._cleanupDraggablePlaceholder();
        this.jpc.removeClass(this.instance.draggingClass);
        delete this.jpc.suspendedEndpoint;
        delete this.jpc.suspendedElement;
        delete this.jpc.suspendedElementType;
        delete this.jpc.suspendedElementId;
        delete this.jpc.suspendedIndex;
        delete this.floatingId;
        delete this.floatingIndex;
        delete this.floatingElement;
        delete this.floatingEndpoint;
        delete this.floatingAnchor;
        delete this.jpc.pending;
        if (dropEndpoint != null) {
          this._maybeCleanup(dropEndpoint);
        }
      }
    }
  }, {
    key: "_getSourceDefinition",
    value: function _getSourceDefinition(evt) {
      var selector;
      for (var i = 0; i < this.instance.sourceSelectors.length; i++) {
        selector = this.instance.sourceSelectors[i];
        if (selector.isEnabled()) {
          var r = selectorFilter(evt, this.instance.getContainer(), selector.selector, this.instance, selector.exclude);
          if (r !== false) {
            return selector.def;
          }
        }
      }
    }
  }, {
    key: "_getDropEndpoint",
    value: function _getDropEndpoint(p, jpc) {
      var dropEndpoint;
      if (this.currentDropTarget.endpoint == null) {
        var targetDefinition = this.currentDropTarget.def;
        var eventTarget = p.e.target || p.e.srcElement;
        if (targetDefinition == null) {
          return null;
        }
        var eps = this.instance._deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
        var pp = eps.endpoints ? extend(p, {
          endpoint: targetDefinition.def.endpoint || eps.endpoints[1]
        }) : p;
        if (eps.anchors) {
          pp = extend(pp, {
            anchor: targetDefinition.def.anchor || eps.anchors[1]
          });
        }
        if (targetDefinition.def.portId != null) {
          pp.portId = targetDefinition.def.portId;
        }
        var extractedParameters = targetDefinition.def.parameterExtractor ? targetDefinition.def.parameterExtractor(this.currentDropTarget.el, eventTarget) : {};
        pp = merge(pp, extractedParameters);
        pp.element = this.currentDropTarget.targetEl;
        dropEndpoint = this.instance._internal_newEndpoint(pp);
        dropEndpoint._mtNew = true;
        dropEndpoint.deleteOnEmpty = true;
        if (targetDefinition.def.parameters) {
          dropEndpoint.mergeParameters(targetDefinition.def.parameters);
        }
        if (targetDefinition.def.extract) {
          var tpayload = {};
          for (var att in targetDefinition.def.extract) {
            var v = this.currentDropTarget.el.getAttribute(att);
            if (v) {
              tpayload[targetDefinition.def.extract[att]] = v;
            }
          }
          dropEndpoint.mergeParameters(tpayload);
        }
      } else {
        dropEndpoint = this.currentDropTarget.endpoint;
      }
      if (dropEndpoint) {
        dropEndpoint.removeClass(this.instance.endpointDropAllowedClass);
        dropEndpoint.removeClass(this.instance.endpointDropForbiddenClass);
      }
      return dropEndpoint;
    }
  }, {
    key: "_doForceReattach",
    value: function _doForceReattach(idx) {
      this.floatingEndpoint.detachFromConnection(this.jpc, null, true);
      this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
      this.instance.setHover(this.jpc, false);
      this.jpc._forceDetach = true;
      this.jpc.suspendedEndpoint.addConnection(this.jpc);
      this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.suspendedEndpoint.elementId, this.jpc, this.jpc.suspendedEndpoint.element, idx);
      this.instance.deleteEndpoint(this.floatingEndpoint);
      this.instance.repaint(this.jpc.source);
      delete this.jpc._forceDetach;
    }
  }, {
    key: "_shouldReattach",
    value: function _shouldReattach(originalEvent) {
      return this.jpc.isReattach() || this.jpc._forceReattach || !functionChain(true, false, [[this.jpc.endpoints[0], IS_DETACH_ALLOWED, [this.jpc]], [this.jpc.endpoints[1], IS_DETACH_ALLOWED, [this.jpc]], [this.jpc, IS_DETACH_ALLOWED, [this.jpc]], [this.instance, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, this.jpc]]]);
    }
  }, {
    key: "_discard",
    value: function _discard(idx, originalEvent) {
      if (this.jpc.pending) {
        this.instance.fire(EVENT_CONNECTION_ABORT, this.jpc, originalEvent);
      } else {
        if (idx === 0) {
          this.jpc.source = this.jpc.suspendedEndpoint.element;
          this.jpc.sourceId = this.jpc.suspendedEndpoint.elementId;
        } else {
          this.jpc.target = this.jpc.suspendedEndpoint.element;
          this.jpc.targetId = this.jpc.suspendedEndpoint.elementId;
        }
        this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
      }
      if (this.floatingEndpoint) {
        this.floatingEndpoint.detachFromConnection(this.jpc);
      }
      this.instance.deleteConnection(this.jpc, {
        originalEvent: originalEvent,
        force: true
      });
    }
  }, {
    key: "_drop",
    value: function _drop(dropEndpoint, idx, originalEvent, optionalData) {
      this.jpc.endpoints[idx].detachFromConnection(this.jpc);
      if (this.jpc.suspendedEndpoint) {
        this.jpc.suspendedEndpoint.detachFromConnection(this.jpc);
      }
      this.jpc.endpoints[idx] = dropEndpoint;
      dropEndpoint.addConnection(this.jpc);
      if (this.jpc.suspendedEndpoint) {
        var suspendedElementId = this.jpc.suspendedEndpoint.elementId;
        this.instance.fireMoveEvent({
          index: idx,
          originalSourceId: idx === 0 ? suspendedElementId : this.jpc.sourceId,
          newSourceId: idx === 0 ? dropEndpoint.elementId : this.jpc.sourceId,
          originalTargetId: idx === 1 ? suspendedElementId : this.jpc.targetId,
          newTargetId: idx === 1 ? dropEndpoint.elementId : this.jpc.targetId,
          originalEndpoint: this.jpc.suspendedEndpoint,
          connection: this.jpc,
          newEndpoint: dropEndpoint
        }, originalEvent);
      }
      if (idx === 1) {
        this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.targetId, this.jpc, this.jpc.target, 1);
      } else {
        this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.sourceId, this.jpc, this.jpc.source, 0);
      }
      if (this.jpc.endpoints[0].finalEndpoint) {
        var _toDelete = this.jpc.endpoints[0];
        _toDelete.detachFromConnection(this.jpc);
        this.jpc.endpoints[0] = this.jpc.endpoints[0].finalEndpoint;
        this.jpc.endpoints[0].addConnection(this.jpc);
      }
      if (isObject(optionalData)) {
        this.jpc.mergeData(optionalData);
      }
      if (this._originalAnchor) {
        this.jpc.endpoints[0].setAnchor(this._originalAnchor);
        this._originalAnchor = null;
      }
      this.instance._finaliseConnection(this.jpc, null, originalEvent);
      this.instance.setHover(this.jpc, false);
      this.instance.revalidate(this.jpc.endpoints[0].element);
    }
  }, {
    key: "_registerFloatingConnection",
    value: function _registerFloatingConnection(info, conn, ep) {
      this.floatingConnections[info.id] = conn;
      addToDictionary(this.instance.endpointsByElement, info.id, ep);
    }
  }, {
    key: "_getFloatingAnchorIndex",
    value: function _getFloatingAnchorIndex() {
      return this.floatingIndex == null ? 1 : this.floatingIndex;
    }
  }]);
  return EndpointDragHandler;
}();

var jsplumb_browser_ui_es_GroupDragHandler = function (_ElementDragHandler) {
  jsplumb_browser_ui_es_inherits(GroupDragHandler, _ElementDragHandler);
  var _super = jsplumb_browser_ui_es_createSuper(GroupDragHandler);
  function GroupDragHandler(instance, dragSelection) {
    var _this;
    jsplumb_browser_ui_es_classCallCheck(this, GroupDragHandler);
    _this = _super.call(this, instance, dragSelection);
    _this.instance = instance;
    _this.dragSelection = dragSelection;
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "selector", [">", SELECTOR_GROUP, SELECTOR_MANAGED_ELEMENT].join(" "));
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "doRevalidate", void 0);
    _this.doRevalidate = _this._revalidate.bind(jsplumb_browser_ui_es_assertThisInitialized(_this));
    return _this;
  }
  jsplumb_browser_ui_es_createClass(GroupDragHandler, [{
    key: "reset",
    value: function reset() {
      this.drag.off(EVENT_REVERT, this.doRevalidate);
    }
  }, {
    key: "_revalidate",
    value: function _revalidate(el) {
      this.instance.revalidate(el);
    }
  }, {
    key: "init",
    value: function init(drag) {
      this.drag = drag;
      drag.on(EVENT_REVERT, this.doRevalidate);
    }
  }, {
    key: "useGhostProxy",
    value: function useGhostProxy(container, dragEl) {
      var group = dragEl._jsPlumbParentGroup;
      return group == null ? false : group.ghost === true;
    }
  }, {
    key: "makeGhostProxy",
    value: function makeGhostProxy(el) {
      var jel = el;
      var newEl = jel.cloneNode(true);
      newEl._jsPlumbParentGroup = jel._jsPlumbParentGroup;
      return newEl;
    }
  }]);
  return GroupDragHandler;
}(jsplumb_browser_ui_es_ElementDragHandler);

var jsplumb_browser_ui_es_HTMLElementOverlay = function () {
  function HTMLElementOverlay(instance, overlay) {
    jsplumb_browser_ui_es_classCallCheck(this, HTMLElementOverlay);
    this.instance = instance;
    this.overlay = overlay;
    jsplumb_browser_ui_es_defineProperty(this, "htmlElementOverlay", void 0);
    this.htmlElementOverlay = overlay;
  }
  jsplumb_browser_ui_es_createClass(HTMLElementOverlay, null, [{
    key: "createElement",
    value: function createElement$1(o) {
      var el = createElement(ELEMENT_DIV, {}, o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : ""));
      o.instance.setAttribute(el, "jtk-overlay-id", o.id);
      return el;
    }
  }, {
    key: "getElement",
    value: function getElement(o, component, elementCreator) {
      if (o.canvas == null) {
        if (elementCreator && component) {
          o.canvas = elementCreator(component);
        } else {
          o.canvas = HTMLElementOverlay.createElement(o);
        }
        o.canvas.style.position = ABSOLUTE;
        o.instance._appendElement(o.canvas, o.instance.getContainer());
        o.instance.getId(o.canvas);
        var ts = "translate(-50%, -50%)";
        o.canvas.style.webkitTransform = ts;
        o.canvas.style.mozTransform = ts;
        o.canvas.style.msTransform = ts;
        o.canvas.style.oTransform = ts;
        o.canvas.style.transform = ts;
        if (!o.isVisible()) {
          o.canvas.style.display = NONE;
        }
        o.canvas.jtk = {
          overlay: o
        };
      }
      return o.canvas;
    }
  }, {
    key: "destroy",
    value: function destroy(o) {
      o.canvas && o.canvas.parentNode && o.canvas.parentNode.removeChild(o.canvas);
      delete o.canvas;
      delete o.cachedDimensions;
    }
  }, {
    key: "_getDimensions",
    value: function _getDimensions(o, forceRefresh) {
      if (o.cachedDimensions == null || forceRefresh) {
        o.cachedDimensions = {
          w: 1,
          h: 1
        };
      }
      return o.cachedDimensions;
    }
  }]);
  return HTMLElementOverlay;
}();

var jsplumb_browser_ui_es_SVGElementOverlay = function (_Overlay) {
  jsplumb_browser_ui_es_inherits(SVGElementOverlay, _Overlay);
  var _super = jsplumb_browser_ui_es_createSuper(SVGElementOverlay);
  function SVGElementOverlay() {
    var _this;
    jsplumb_browser_ui_es_classCallCheck(this, SVGElementOverlay);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "path", void 0);
    return _this;
  }
  jsplumb_browser_ui_es_createClass(SVGElementOverlay, null, [{
    key: "ensurePath",
    value: function ensurePath(o) {
      if (o.path == null) {
        o.path = _node(ELEMENT_PATH, {
          "jtk-overlay-id": o.id
        });
        var parent = null;
        if (o.component instanceof jsplumb_core_es_Connection) {
          var connector = o.component.connector;
          parent = connector != null ? connector.canvas : null;
        } else if (o.component instanceof jsplumb_core_es_Endpoint) {
          var endpoint = o.component.endpoint;
          parent = endpoint != null ? endpoint.svg : endpoint;
        }
        if (parent != null) {
          _appendAtIndex(parent, o.path, 1);
        }
        o.instance.addClass(o.path, o.instance.overlayClass);
        o.path.jtk = {
          overlay: o
        };
      }
      return o.path;
    }
  }, {
    key: "paint",
    value: function paint(o, path, params, extents) {
      this.ensurePath(o);
      var offset = [0, 0];
      if (extents.xmin < 0) {
        offset[0] = -extents.xmin;
      }
      if (extents.ymin < 0) {
        offset[1] = -extents.ymin;
      }
      var a = {
        "d": path,
        stroke: params.stroke ? params.stroke : null,
        fill: params.fill ? params.fill : null,
        transform: "translate(" + offset[0] + "," + offset[1] + ")",
        "pointer-events": "visibleStroke"
      };
      _attr(o.path, a);
    }
  }, {
    key: "destroy",
    value: function destroy(o, force) {
      var _o = o;
      if (_o.path != null && _o.path.parentNode != null) {
        _o.path.parentNode.removeChild(_o.path);
      }
      if (_o.bgPath != null && _o.bgPath.parentNode != null) {
        _o.bgPath.parentNode.removeChild(_o.bgPath);
      }
      delete _o.path;
      delete _o.bgPath;
    }
  }]);
  return SVGElementOverlay;
}(jsplumb_core_es_Overlay);

var SvgComponent = function () {
  function SvgComponent() {
    jsplumb_browser_ui_es_classCallCheck(this, SvgComponent);
  }
  jsplumb_browser_ui_es_createClass(SvgComponent, null, [{
    key: "paint",
    value: function paint(connector, useDivWrapper, paintStyle, extents) {
      if (paintStyle != null) {
        var xy = [connector.x, connector.y],
            wh = [connector.w, connector.h],
            p;
        if (extents != null) {
          if (extents.xmin < 0) {
            xy[0] += extents.xmin;
          }
          if (extents.ymin < 0) {
            xy[1] += extents.ymin;
          }
          wh[0] = extents.xmax + (extents.xmin < 0 ? -extents.xmin : 0);
          wh[1] = extents.ymax + (extents.ymin < 0 ? -extents.ymin : 0);
        }
        if (isFinite(wh[0]) && isFinite(wh[1])) {
          if (useDivWrapper) {
            _size(connector.canvas, xy[0], xy[1], wh[0], wh[1]);
            xy[0] = 0;
            xy[1] = 0;
            p = _pos([0, 0]);
            _attr(connector.svg, {
              "style": p,
              "width": "" + (wh[0] || 0),
              "height": "" + (wh[1] || 0)
            });
          } else {
            p = _pos([xy[0], xy[1]]);
            _attr(connector.canvas, {
              "style": p,
              "width": "" + (wh[0] || 0),
              "height": "" + (wh[1] || 0)
            });
          }
        }
      }
    }
  }]);
  return SvgComponent;
}();

function paintSvgConnector(instance, connector, paintStyle, extents) {
  getConnectorElement(instance, connector);
  SvgComponent.paint(connector, false, paintStyle, extents);
  var p = "",
      offset = [0, 0];
  if (extents.xmin < 0) {
    offset[0] = -extents.xmin;
  }
  if (extents.ymin < 0) {
    offset[1] = -extents.ymin;
  }
  if (connector.segments.length > 0) {
    p = instance.getPathData(connector);
    var a = {
      d: p,
      transform: "translate(" + offset[0] + "," + offset[1] + ")",
      "pointer-events": "visibleStroke"
    },
        outlineStyle = null;
    if (paintStyle.outlineStroke) {
      var outlineWidth = paintStyle.outlineWidth || 1,
          outlineStrokeWidth = paintStyle.strokeWidth + 2 * outlineWidth;
      outlineStyle = extend({}, paintStyle);
      outlineStyle.stroke = paintStyle.outlineStroke;
      outlineStyle.strokeWidth = outlineStrokeWidth;
      if (connector.bgPath == null) {
        connector.bgPath = _node(ELEMENT_PATH, a);
        instance.addClass(connector.bgPath, instance.connectorOutlineClass);
        _appendAtIndex(connector.canvas, connector.bgPath, 0);
      } else {
        _attr(connector.bgPath, a);
      }
      _applyStyles(connector.canvas, connector.bgPath, outlineStyle);
    }
    var cany = connector;
    if (cany.path == null) {
      cany.path = _node(ELEMENT_PATH, a);
      _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
    } else {
      if (cany.path.parentNode !== cany.canvas) {
        _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
      }
      _attr(connector.path, a);
    }
    _applyStyles(connector.canvas, connector.path, paintStyle);
  }
}
function getConnectorElement(instance, c) {
  if (c.canvas != null) {
    return c.canvas;
  } else {
    var svg = _node(ELEMENT_SVG, {
      "style": "",
      "width": "0",
      "height": "0",
      "pointer-events": NONE,
      "position": ABSOLUTE
    });
    c.canvas = svg;
    instance._appendElement(c.canvas, instance.getContainer());
    if (c.cssClass != null) {
      instance.addClass(svg, c.cssClass);
    }
    instance.addClass(svg, instance.connectorClass);
    svg.jtk = svg.jtk || {};
    svg.jtk.connector = c;
    return svg;
  }
}

var jsplumb_browser_ui_es_SvgEndpoint = function () {
  function SvgEndpoint() {
    jsplumb_browser_ui_es_classCallCheck(this, SvgEndpoint);
  }
  jsplumb_browser_ui_es_createClass(SvgEndpoint, null, [{
    key: "getEndpointElement",
    value: function getEndpointElement(ep) {
      if (ep.canvas != null) {
        return ep.canvas;
      } else {
        var svg = _node(ELEMENT_SVG, {
          "style": "",
          "width": "0",
          "height": "0",
          "pointer-events": NONE,
          "position": ABSOLUTE
        });
        ep.svg = svg;
        var canvas = createElement(ELEMENT_DIV, {
          position: ABSOLUTE
        });
        ep.canvas = canvas;
        var classes = ep.classes.join(" ");
        ep.instance.addClass(canvas, classes);
        var scopes = ep.endpoint.scope.split(/\s/);
        for (var i = 0; i < scopes.length; i++) {
          ep.instance.setAttribute(canvas, ATTRIBUTE_SCOPE_PREFIX + scopes[i], TRUE);
        }
        if (!ep.instance._suspendDrawing) {
          _size(canvas, 0, 0, 1, 1);
        }
        ep.instance._appendElement(canvas, ep.instance.getContainer());
        canvas.appendChild(svg);
        if (ep.cssClass != null) {
          ep.instance.addClass(canvas, ep.cssClass);
        }
        ep.instance.addClass(canvas, ep.instance.endpointClass);
        canvas.jtk = canvas.jtk || {};
        canvas.jtk.endpoint = ep.endpoint;
        canvas.style.display = ep.endpoint.visible !== false ? BLOCK : NONE;
        return canvas;
      }
    }
  }, {
    key: "paint",
    value: function paint(ep, handlers, paintStyle) {
      this.getEndpointElement(ep);
      SvgComponent.paint(ep, true, paintStyle);
      var s = extend({}, paintStyle);
      if (s.outlineStroke) {
        s.stroke = s.outlineStroke;
      }
      if (ep.node == null) {
        ep.node = handlers.makeNode(ep, s);
        ep.svg.appendChild(ep.node);
      } else if (handlers.updateNode != null) {
        handlers.updateNode(ep, ep.node);
      }
      _applyStyles(ep.canvas, ep.node, s);
    }
  }]);
  return SvgEndpoint;
}();

var jsplumb_browser_ui_es_endpointMap = {};
function registerEndpointRenderer(name, fns) {
  jsplumb_browser_ui_es_endpointMap[name] = fns;
}
function getPositionOnElement(evt, el, zoom) {
  var jel = el;
  var box = _typeof(el.getBoundingClientRect) !== UNDEFINED ? el.getBoundingClientRect() : {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  },
      body = document.body,
      docElem = document.documentElement,
      scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
      scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
      clientTop = docElem.clientTop || body.clientTop || 0,
      clientLeft = docElem.clientLeft || body.clientLeft || 0,
      pst = 0,
      psl = 0,
      top = box.top + scrollTop - clientTop + pst * zoom,
      left = box.left + scrollLeft - clientLeft + psl * zoom,
      cl = pageLocation(evt),
      w = box.width || jel.offsetWidth * zoom,
      h = box.height || jel.offsetHeight * zoom,
      x = (cl.x - left) / w,
      y = (cl.y - top) / h;
  return {
    x: x,
    y: y
  };
}
function isSVGElementOverlay(o) {
  return isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o);
}
function setVisible(component, v) {
  if (component.canvas) {
    component.canvas.style.display = v ? "block" : "none";
  }
}
function cleanup(component) {
  if (component.canvas) {
    component.canvas.parentNode.removeChild(component.canvas);
  }
  delete component.canvas;
  delete component.svg;
}
function getEndpointCanvas(ep) {
  return ep.canvas;
}
function getLabelElement(o) {
  return jsplumb_browser_ui_es_HTMLElementOverlay.getElement(o);
}
function getCustomElement(o) {
  return jsplumb_browser_ui_es_HTMLElementOverlay.getElement(o, o.component, function (c) {
    var el = o.create(c);
    o.instance.addClass(el, o.instance.overlayClass);
    return el;
  });
}
function groupDragConstrain(desiredLoc, dragEl, constrainRect, size) {
  var x = desiredLoc.x,
      y = desiredLoc.y;
  if (dragEl._jsPlumbParentGroup && dragEl._jsPlumbParentGroup.constrain) {
    x = Math.max(desiredLoc.x, 0);
    y = Math.max(desiredLoc.y, 0);
    x = Math.min(x, constrainRect.w - size.w);
    y = Math.min(y, constrainRect.h - size.h);
  }
  return {
    x: x,
    y: y
  };
}
var jsplumb_browser_ui_es_BrowserJsPlumbInstance = function (_JsPlumbInstance) {
  jsplumb_browser_ui_es_inherits(BrowserJsPlumbInstance, _JsPlumbInstance);
  var _super = jsplumb_browser_ui_es_createSuper(BrowserJsPlumbInstance);
  function BrowserJsPlumbInstance(_instanceIndex, defaults) {
    var _this;
    jsplumb_browser_ui_es_classCallCheck(this, BrowserJsPlumbInstance);
    _this = _super.call(this, _instanceIndex, defaults);
    _this._instanceIndex = _instanceIndex;
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "dragSelection", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "dragManager", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_connectorClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_connectorDblClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_connectorTap", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_connectorDblTap", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_endpointClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_endpointDblClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_overlayClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_overlayDblClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_overlayTap", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_overlayDblTap", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_connectorMouseover", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_connectorMouseout", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_endpointMouseover", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_endpointMouseout", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_overlayMouseover", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_overlayMouseout", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_elementClick", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_elementTap", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_elementDblTap", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_elementMouseenter", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "_elementMouseexit", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "eventManager", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "draggingClass", "jtk-dragging");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "elementDraggingClass", "jtk-element-dragging");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "hoverClass", "jtk-hover");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "sourceElementDraggingClass", "jtk-source-element-dragging");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "targetElementDraggingClass", "jtk-target-element-dragging");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "hoverSourceClass", "jtk-source-hover");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "hoverTargetClass", "jtk-target-hover");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "dragSelectClass", "jtk-drag-select");
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "managedElementsSelector", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "elementsDraggable", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "elementDragHandler", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "groupDragOptions", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "elementDragOptions", void 0);
    jsplumb_browser_ui_es_defineProperty(jsplumb_browser_ui_es_assertThisInitialized(_this), "svg", {
      node: function node(name, attributes) {
        return _node(name, attributes);
      },
      attr: function attr(node, attributes) {
        return _attr(node, attributes);
      },
      pos: function pos(d) {
        return _pos(d);
      }
    });
    _this.elementsDraggable = defaults && defaults.elementsDraggable !== false;
    _this.managedElementsSelector = defaults ? defaults.managedElementsSelector || SELECTOR_MANAGED_ELEMENT : SELECTOR_MANAGED_ELEMENT;
    _this.eventManager = new EventManager();
    _this.dragSelection = new jsplumb_browser_ui_es_DragSelection(jsplumb_browser_ui_es_assertThisInitialized(_this));
    _this.dragManager = new jsplumb_browser_ui_es_DragManager(jsplumb_browser_ui_es_assertThisInitialized(_this), _this.dragSelection, defaults && defaults.dragOptions ? defaults.dragOptions : null);
    _this.dragManager.addHandler(new jsplumb_browser_ui_es_EndpointDragHandler(jsplumb_browser_ui_es_assertThisInitialized(_this)));
    _this.groupDragOptions = {
      constrainFunction: groupDragConstrain
    };
    _this.dragManager.addHandler(new jsplumb_browser_ui_es_GroupDragHandler(jsplumb_browser_ui_es_assertThisInitialized(_this), _this.dragSelection), _this.groupDragOptions);
    _this.elementDragHandler = new jsplumb_browser_ui_es_ElementDragHandler(jsplumb_browser_ui_es_assertThisInitialized(_this), _this.dragSelection);
    _this.elementDragOptions = defaults && defaults.dragOptions || {};
    _this.dragManager.addHandler(_this.elementDragHandler, _this.elementDragOptions);
    var _connClick = function _connClick(event, e) {
      if (!e.defaultPrevented) {
        var connectorElement = findParent(getEventSource(e), SELECTOR_CONNECTOR, this.getContainer(), true);
        this.fire(event, connectorElement.jtk.connector.connection, e);
      }
    };
    _this._connectorClick = _connClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_CONNECTION_CLICK);
    _this._connectorDblClick = _connClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_CONNECTION_DBL_CLICK);
    _this._connectorTap = _connClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_CONNECTION_TAP);
    _this._connectorDblTap = _connClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_CONNECTION_DBL_TAP);
    var _connectorHover = function _connectorHover(state, e) {
      var el = getEventSource(e).parentNode;
      if (el.jtk && el.jtk.connector) {
        this.setConnectorHover(el.jtk.connector, state);
        this.fire(state ? EVENT_CONNECTION_MOUSEOVER : EVENT_CONNECTION_MOUSEOUT, el.jtk.connector.connection, e);
      }
    };
    _this._connectorMouseover = _connectorHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), true);
    _this._connectorMouseout = _connectorHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), false);
    var _epClick = function _epClick(event, e, endpointElement) {
      if (!e.defaultPrevented) {
        this.fire(event, endpointElement.jtk.endpoint, e);
      }
    };
    _this._endpointClick = _epClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_ENDPOINT_CLICK);
    _this._endpointDblClick = _epClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_ENDPOINT_DBL_CLICK);
    var _endpointHover = function _endpointHover(state, e) {
      var el = getEventSource(e);
      if (el.jtk && el.jtk.endpoint) {
        this.setEndpointHover(el.jtk.endpoint, state);
        this.fire(state ? EVENT_ENDPOINT_MOUSEOVER : EVENT_ENDPOINT_MOUSEOUT, el.jtk.endpoint, e);
      }
    };
    _this._endpointMouseover = _endpointHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), true);
    _this._endpointMouseout = _endpointHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), false);
    var _oClick = function (method, e) {
      consume(e);
      var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
      var overlay = overlayElement.jtk.overlay;
      if (overlay) {
        this.fireOverlayMethod(overlay, method, e);
      }
    }.bind(jsplumb_browser_ui_es_assertThisInitialized(_this));
    _this._overlayClick = _oClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_CLICK);
    _this._overlayDblClick = _oClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_DBL_CLICK);
    _this._overlayTap = _oClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_TAP);
    _this._overlayDblTap = _oClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_DBL_TAP);
    var _overlayHover = function _overlayHover(state, e) {
      var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
      var overlay = overlayElement.jtk.overlay;
      if (overlay) {
        this.setOverlayHover(overlay, state);
      }
    };
    _this._overlayMouseover = _overlayHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), true);
    _this._overlayMouseout = _overlayHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), false);
    var _elementClick = function _elementClick(event, e, target) {
      if (!e.defaultPrevented) {
        this.fire(e.detail === 1 ? EVENT_ELEMENT_CLICK : EVENT_ELEMENT_DBL_CLICK, target, e);
      }
    };
    _this._elementClick = _elementClick.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_ELEMENT_CLICK);
    var _elementTap = function _elementTap(event, e, target) {
      if (!e.defaultPrevented) {
        this.fire(EVENT_ELEMENT_TAP, target, e);
      }
    };
    _this._elementTap = _elementTap.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_ELEMENT_TAP);
    var _elementDblTap = function _elementDblTap(event, e, target) {
      if (!e.defaultPrevented) {
        this.fire(EVENT_ELEMENT_DBL_TAP, target, e);
      }
    };
    _this._elementDblTap = _elementDblTap.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), EVENT_ELEMENT_DBL_TAP);
    var _elementHover = function _elementHover(state, e) {
      this.fire(state ? EVENT_ELEMENT_MOUSE_OVER : EVENT_ELEMENT_MOUSE_OUT, getEventSource(e), e);
    };
    _this._elementMouseenter = _elementHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), true);
    _this._elementMouseexit = _elementHover.bind(jsplumb_browser_ui_es_assertThisInitialized(_this), false);
    _this._attachEventDelegates();
    return _this;
  }
  jsplumb_browser_ui_es_createClass(BrowserJsPlumbInstance, [{
    key: "fireOverlayMethod",
    value: function fireOverlayMethod(overlay, event, e) {
      var stem = overlay.component instanceof jsplumb_core_es_Connection ? CONNECTION : ENDPOINT;
      var mappedEvent = compoundEvent(stem, event);
      overlay.fire(event, {
        e: e,
        overlay: overlay
      });
      this.fire(mappedEvent, overlay.component, e);
    }
  }, {
    key: "addDragFilter",
    value: function addDragFilter(filter, exclude) {
      this.dragManager.addFilter(filter, exclude);
    }
  }, {
    key: "removeDragFilter",
    value: function removeDragFilter(filter) {
      this.dragManager.removeFilter(filter);
    }
  }, {
    key: "setDragGrid",
    value: function setDragGrid(grid) {
      this.dragManager.setOption(this.elementDragHandler, {
        grid: grid
      });
    }
  }, {
    key: "_removeElement",
    value: function _removeElement(element) {
      element.parentNode && element.parentNode.removeChild(element);
    }
  }, {
    key: "_appendElement",
    value: function _appendElement(el, parent) {
      if (parent) {
        parent.appendChild(el);
      }
    }
  }, {
    key: "_getAssociatedElements",
    value: function _getAssociatedElements(el) {
      var a = [];
      if (el.nodeType !== 3 && el.nodeType !== 8) {
        var els = el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
        Array.prototype.push.apply(a, els);
      }
      return a.filter(function (_a) {
        return _a.nodeType !== 3 && _a.nodeType !== 8;
      });
    }
  }, {
    key: "shouldFireEvent",
    value: function shouldFireEvent(event, value, originalEvent) {
      return true;
    }
  }, {
    key: "getClass",
    value: function getClass$1(el) {
      return getClass(el);
    }
  }, {
    key: "addClass",
    value: function addClass$1(el, clazz) {
      addClass(el, clazz);
    }
  }, {
    key: "hasClass",
    value: function hasClass$1(el, clazz) {
      return hasClass(el, clazz);
    }
  }, {
    key: "removeClass",
    value: function removeClass$1(el, clazz) {
      removeClass(el, clazz);
    }
  }, {
    key: "toggleClass",
    value: function toggleClass$1(el, clazz) {
      toggleClass(el, clazz);
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(el, name, value) {
      el.setAttribute(name, value);
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(el, name) {
      return el.getAttribute(name);
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(el, atts) {
      for (var i in atts) {
        el.setAttribute(i, atts[i]);
      }
    }
  }, {
    key: "removeAttribute",
    value: function removeAttribute(el, attName) {
      el.removeAttribute && el.removeAttribute(attName);
    }
  }, {
    key: "on",
    value: function on(el, event, callbackOrSelector, callback) {
      var _this2 = this;
      var _one = function _one(_el) {
        if (callback == null) {
          _this2.eventManager.on(_el, event, callbackOrSelector);
        } else {
          _this2.eventManager.on(_el, event, callbackOrSelector, callback);
        }
      };
      if (isNodeList(el)) {
        forEach(el, function (el) {
          return _one(el);
        });
      } else {
        _one(el);
      }
      return this;
    }
  }, {
    key: "off",
    value: function off(el, event, callback) {
      var _this3 = this;
      if (isNodeList(el)) {
        forEach(el, function (_el) {
          return _this3.eventManager.off(_el, event, callback);
        });
      } else {
        this.eventManager.off(el, event, callback);
      }
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger(el, event, originalEvent, payload, detail) {
      this.eventManager.trigger(el, event, originalEvent, payload, detail);
    }
  }, {
    key: "getOffsetRelativeToRoot",
    value: function getOffsetRelativeToRoot(el) {
      return offsetRelativeToRoot(el);
    }
  }, {
    key: "getOffset",
    value: function getOffset(el) {
      var jel = el;
      var container = this.getContainer();
      var out = {
        x: jel.offsetLeft,
        y: jel.offsetTop
      },
          op = el !== container && jel.offsetParent !== container ? jel.offsetParent : null,
          _maybeAdjustScroll = function _maybeAdjustScroll(offsetParent) {
        if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
          out.x -= offsetParent.scrollLeft;
          out.y -= offsetParent.scrollTop;
        }
      };
      while (op != null) {
        out.x += op.offsetLeft;
        out.y += op.offsetTop;
        _maybeAdjustScroll(op);
        op = op.offsetParent === container ? null : op.offsetParent;
      }
      if (container != null && (container.scrollTop > 0 || container.scrollLeft > 0)) {
        var pp = jel.offsetParent != null ? this.getStyle(jel.offsetParent, PROPERTY_POSITION) : STATIC,
            p = this.getStyle(jel, PROPERTY_POSITION);
        if (p !== ABSOLUTE && p !== FIXED && pp !== ABSOLUTE && pp !== FIXED) {
          out.x -= container.scrollLeft;
          out.y -= container.scrollTop;
        }
      }
      return out;
    }
  }, {
    key: "getSize",
    value: function getSize(el) {
      return jsplumb_browser_ui_es_size(el);
    }
  }, {
    key: "getStyle",
    value: function getStyle(el, prop) {
      if (_typeof(window.getComputedStyle) !== UNDEFINED) {
        return getComputedStyle(el, null).getPropertyValue(prop);
      } else {
        return el.currentStyle[prop];
      }
    }
  }, {
    key: "getGroupContentArea",
    value: function getGroupContentArea(group) {
      var da = this.getSelector(group.el, SELECTOR_GROUP_CONTAINER);
      return da && da.length > 0 ? da[0] : group.el;
    }
  }, {
    key: "getSelector",
    value: function getSelector(ctx, spec) {
      var sel = null;
      if (arguments.length === 1) {
        if (!isString(ctx)) {
          var nodeList = document.createDocumentFragment();
          nodeList.appendChild(ctx);
          return fromArray(nodeList.childNodes);
        }
        sel = fromArray(document.querySelectorAll(ctx));
      } else {
        sel = fromArray(ctx.querySelectorAll(spec));
      }
      return sel;
    }
  }, {
    key: "setPosition",
    value: function setPosition(el, p) {
      var jel = el;
      jel.style.left = p.x + "px";
      jel.style.top = p.y + "px";
    }
  }, {
    key: "setDraggable",
    value: function setDraggable(element, draggable) {
      if (draggable) {
        this.removeAttribute(element, ATTRIBUTE_NOT_DRAGGABLE);
      } else {
        this.setAttribute(element, ATTRIBUTE_NOT_DRAGGABLE, TRUE);
      }
    }
  }, {
    key: "isDraggable",
    value: function isDraggable(el) {
      var d = this.getAttribute(el, ATTRIBUTE_NOT_DRAGGABLE);
      return d == null || d === FALSE;
    }
  }, {
    key: "toggleDraggable",
    value: function toggleDraggable(el) {
      var state = this.isDraggable(el);
      this.setDraggable(el, !state);
      return !state;
    }
  }, {
    key: "_attachEventDelegates",
    value: function _attachEventDelegates() {
      var currentContainer = this.getContainer();
      this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_OVERLAY, this._overlayClick);
      this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_OVERLAY, this._overlayDblClick);
      this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_OVERLAY, this._overlayTap);
      this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_OVERLAY, this._overlayDblTap);
      this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_CONNECTOR, this._connectorClick);
      this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_CONNECTOR, this._connectorDblClick);
      this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_CONNECTOR, this._connectorTap);
      this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_CONNECTOR, this._connectorDblTap);
      this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_ENDPOINT, this._endpointClick);
      this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_ENDPOINT, this._endpointDblClick);
      this.eventManager.on(currentContainer, EVENT_CLICK, this.managedElementsSelector, this._elementClick);
      this.eventManager.on(currentContainer, EVENT_TAP, this.managedElementsSelector, this._elementTap);
      this.eventManager.on(currentContainer, EVENT_DBL_TAP, this.managedElementsSelector, this._elementDblTap);
      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_CONNECTOR, this._connectorMouseover);
      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_CONNECTOR, this._connectorMouseout);
      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_ENDPOINT, this._endpointMouseover);
      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_ENDPOINT, this._endpointMouseout);
      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_OVERLAY, this._overlayMouseover);
      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_OVERLAY, this._overlayMouseout);
      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_MANAGED_ELEMENT, this._elementMouseenter);
      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_MANAGED_ELEMENT, this._elementMouseexit);
    }
  }, {
    key: "_detachEventDelegates",
    value: function _detachEventDelegates() {
      var currentContainer = this.getContainer();
      if (currentContainer) {
        this.eventManager.off(currentContainer, EVENT_CLICK, this._connectorClick);
        this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._connectorDblClick);
        this.eventManager.off(currentContainer, EVENT_TAP, this._connectorTap);
        this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._connectorDblTap);
        this.eventManager.off(currentContainer, EVENT_CLICK, this._endpointClick);
        this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._endpointDblClick);
        this.eventManager.off(currentContainer, EVENT_CLICK, this._overlayClick);
        this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._overlayDblClick);
        this.eventManager.off(currentContainer, EVENT_TAP, this._overlayTap);
        this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._overlayDblTap);
        this.eventManager.off(currentContainer, EVENT_CLICK, this._elementClick);
        this.eventManager.off(currentContainer, EVENT_TAP, this._elementTap);
        this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._elementDblTap);
        this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._connectorMouseover);
        this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._connectorMouseout);
        this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._endpointMouseover);
        this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._endpointMouseout);
        this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._overlayMouseover);
        this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._overlayMouseout);
        this.eventManager.off(currentContainer, EVENT_MOUSEENTER, this._elementMouseenter);
        this.eventManager.off(currentContainer, EVENT_MOUSEEXIT, this._elementMouseexit);
      }
    }
  }, {
    key: "setContainer",
    value: function setContainer(newContainer) {
      var _this4 = this;
      if (newContainer === document || newContainer === document.body) {
        throw new Error("Cannot set document or document.body as container element");
      }
      this._detachEventDelegates();
      var dragFilters;
      if (this.dragManager != null) {
        dragFilters = this.dragManager.reset();
      }
      this.setAttribute(newContainer, ATTRIBUTE_CONTAINER, jsplumb_util_es_uuid().replace("-", ""));
      var currentContainer = this.getContainer();
      if (currentContainer != null) {
        currentContainer.removeAttribute(ATTRIBUTE_CONTAINER);
        var children = fromArray(currentContainer.childNodes).filter(function (cn) {
          return cn != null && (_this4.hasClass(cn, CLASS_CONNECTOR) || _this4.hasClass(cn, CLASS_ENDPOINT) || _this4.hasClass(cn, CLASS_OVERLAY) || cn.getAttribute && cn.getAttribute(ATTRIBUTE_MANAGED) != null);
        });
        forEach(children, function (el) {
          newContainer.appendChild(el);
        });
      }
      jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "setContainer", this).call(this, newContainer);
      if (this.eventManager != null) {
        this._attachEventDelegates();
      }
      if (this.dragManager != null) {
        this.dragManager.addHandler(new jsplumb_browser_ui_es_EndpointDragHandler(this));
        this.dragManager.addHandler(new jsplumb_browser_ui_es_GroupDragHandler(this, this.dragSelection), this.groupDragOptions);
        this.elementDragHandler = new jsplumb_browser_ui_es_ElementDragHandler(this, this.dragSelection);
        this.dragManager.addHandler(this.elementDragHandler, this.elementDragOptions);
        if (dragFilters != null) {
          this.dragManager.setFilters(dragFilters);
        }
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "reset", this).call(this);
      var container = this.getContainer();
      var els = container.querySelectorAll([SELECTOR_MANAGED_ELEMENT, SELECTOR_ENDPOINT, SELECTOR_CONNECTOR, SELECTOR_OVERLAY].join(","));
      forEach(els, function (el) {
        return el.parentNode && el.parentNode.removeChild(el);
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._detachEventDelegates();
      if (this.dragManager != null) {
        this.dragManager.reset();
      }
      this.clearDragSelection();
      jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "destroy", this).call(this);
    }
  }, {
    key: "unmanage",
    value: function unmanage(el, removeElement) {
      this.removeFromDragSelection(el);
      jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "unmanage", this).call(this, el, removeElement);
    }
  }, {
    key: "addToDragSelection",
    value: function addToDragSelection() {
      var _this5 = this;
      for (var _len = arguments.length, el = new Array(_len), _key = 0; _key < _len; _key++) {
        el[_key] = arguments[_key];
      }
      forEach(el, function (_el) {
        return _this5.dragSelection.add(_el);
      });
    }
  }, {
    key: "clearDragSelection",
    value: function clearDragSelection() {
      this.dragSelection.clear();
    }
  }, {
    key: "removeFromDragSelection",
    value: function removeFromDragSelection() {
      var _this6 = this;
      for (var _len2 = arguments.length, el = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        el[_key2] = arguments[_key2];
      }
      forEach(el, function (_el) {
        return _this6.dragSelection.remove(_el);
      });
    }
  }, {
    key: "toggleDragSelection",
    value: function toggleDragSelection() {
      var _this7 = this;
      for (var _len3 = arguments.length, el = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        el[_key3] = arguments[_key3];
      }
      forEach(el, function (_el) {
        return _this7.dragSelection.toggle(_el);
      });
    }
  }, {
    key: "addToDragGroup",
    value: function addToDragGroup(spec) {
      var _this$elementDragHand;
      for (var _len4 = arguments.length, els = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        els[_key4 - 1] = arguments[_key4];
      }
      (_this$elementDragHand = this.elementDragHandler).addToDragGroup.apply(_this$elementDragHand, [spec].concat(els));
    }
  }, {
    key: "removeFromDragGroup",
    value: function removeFromDragGroup() {
      var _this$elementDragHand2;
      (_this$elementDragHand2 = this.elementDragHandler).removeFromDragGroup.apply(_this$elementDragHand2, arguments);
    }
  }, {
    key: "setDragGroupState",
    value: function setDragGroupState(state) {
      var _this$elementDragHand3;
      for (var _len5 = arguments.length, els = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        els[_key5 - 1] = arguments[_key5];
      }
      (_this$elementDragHand3 = this.elementDragHandler).setDragGroupState.apply(_this$elementDragHand3, [state].concat(els));
    }
  }, {
    key: "consume",
    value: function consume$1(e, doNotPreventDefault) {
      consume(e, doNotPreventDefault);
    }
  }, {
    key: "rotate",
    value: function rotate(element, rotation, doNotRepaint) {
      var elementId = this.getId(element);
      if (this._managedElements[elementId]) {
        this._managedElements[elementId].el.style.transform = "rotate(" + rotation + "deg)";
        this._managedElements[elementId].el.style.transformOrigin = "center center";
        return jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "rotate", this).call(this, element, rotation, doNotRepaint);
      }
      return {
        c: new Set(),
        e: new Set()
      };
    }
  }, {
    key: "addOverlayClass",
    value: function addOverlayClass(o, clazz) {
      if (isLabelOverlay(o)) {
        o.instance.addClass(getLabelElement(o), clazz);
      } else if (isSVGElementOverlay(o)) {
        o.instance.addClass(jsplumb_browser_ui_es_SVGElementOverlay.ensurePath(o), clazz);
      } else if (isCustomOverlay(o)) {
        o.instance.addClass(getCustomElement(o), clazz);
      } else {
        throw "Could not add class to overlay of type [" + o.type + "]";
      }
    }
  }, {
    key: "removeOverlayClass",
    value: function removeOverlayClass(o, clazz) {
      if (isLabelOverlay(o)) {
        o.instance.removeClass(getLabelElement(o), clazz);
      } else if (isSVGElementOverlay(o)) {
        o.instance.removeClass(jsplumb_browser_ui_es_SVGElementOverlay.ensurePath(o), clazz);
      } else if (isCustomOverlay(o)) {
        o.instance.removeClass(getCustomElement(o), clazz);
      } else {
        throw "Could not remove class from overlay of type [" + o.type + "]";
      }
    }
  }, {
    key: "paintOverlay",
    value: function paintOverlay(o, params, extents) {
      if (isLabelOverlay(o)) {
        getLabelElement(o);
        var XY = o.component.getXY();
        o.canvas.style.left = XY.x + params.d.minx + "px";
        o.canvas.style.top = XY.y + params.d.miny + "px";
      } else if (isSVGElementOverlay(o)) {
        var path = isNaN(params.d.cxy.x) || isNaN(params.d.cxy.y) ? "M 0 0" : "M" + params.d.hxy.x + "," + params.d.hxy.y + " L" + params.d.tail[0].x + "," + params.d.tail[0].y + " L" + params.d.cxy.x + "," + params.d.cxy.y + " L" + params.d.tail[1].x + "," + params.d.tail[1].y + " L" + params.d.hxy.x + "," + params.d.hxy.y;
        jsplumb_browser_ui_es_SVGElementOverlay.paint(o, path, params, extents);
      } else if (isCustomOverlay(o)) {
        getCustomElement(o);
        var _XY = o.component.getXY();
        o.canvas.style.left = _XY.x + params.d.minx + "px";
        o.canvas.style.top = _XY.y + params.d.miny + "px";
      } else {
        throw "Could not paint overlay of type [" + o.type + "]";
      }
    }
  }, {
    key: "setOverlayVisible",
    value: function setOverlayVisible(o, visible) {
      var d = visible ? "block" : "none";
      function s(el) {
        if (el != null) {
          el.style.display = d;
        }
      }
      if (isLabelOverlay(o)) {
        s(getLabelElement(o));
      } else if (isCustomOverlay(o)) {
        s(getCustomElement(o));
      } else if (isSVGElementOverlay(o)) {
        s(o.path);
      }
    }
  }, {
    key: "reattachOverlay",
    value: function reattachOverlay(o, c) {
      if (isLabelOverlay(o)) {
        o.instance._appendElement(getLabelElement(o), this.getContainer());
      } else if (isCustomOverlay(o)) {
        o.instance._appendElement(getCustomElement(o), this.getContainer());
      } else if (isSVGElementOverlay(o)) {
        this._appendElement(jsplumb_browser_ui_es_SVGElementOverlay.ensurePath(o), c.connector.canvas);
      }
    }
  }, {
    key: "setOverlayHover",
    value: function setOverlayHover(o, hover) {
      var method = hover ? "addClass" : "removeClass";
      var canvas;
      if (isLabelOverlay(o)) {
        canvas = getLabelElement(o);
      } else if (isCustomOverlay(o)) {
        canvas = getCustomElement(o);
      } else if (isSVGElementOverlay(o)) {
        canvas = jsplumb_browser_ui_es_SVGElementOverlay.ensurePath(o);
      }
      if (canvas != null) {
        if (this.hoverClass != null) {
          this[method](canvas, this.hoverClass);
        }
        this.setHover(o.component, hover);
      }
    }
  }, {
    key: "destroyOverlay",
    value: function destroyOverlay(o) {
      if (isLabelOverlay(o)) {
        var el = getLabelElement(o);
        el.parentNode.removeChild(el);
        delete o.canvas;
        delete o.cachedDimensions;
      } else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
        jsplumb_browser_ui_es_SVGElementOverlay.destroy(o);
      } else if (isCustomOverlay(o)) {
        var _el2 = getCustomElement(o);
        _el2.parentNode.removeChild(_el2);
        delete o.canvas;
        delete o.cachedDimensions;
      }
    }
  }, {
    key: "drawOverlay",
    value: function drawOverlay(o, component, paintStyle, absolutePosition) {
      if (isLabelOverlay(o) || isCustomOverlay(o)) {
        var td = jsplumb_browser_ui_es_HTMLElementOverlay._getDimensions(o);
        if (td != null && td.w != null && td.h != null) {
          var cxy = {
            x: 0,
            y: 0
          };
          if (absolutePosition) {
            cxy = {
              x: absolutePosition.x,
              y: absolutePosition.y
            };
          } else if (component instanceof jsplumb_core_es_EndpointRepresentation) {
            var locToUse = Array.isArray(o.location) ? o.location : [o.location, o.location];
            cxy = {
              x: locToUse[0] * component.w,
              y: locToUse[1] * component.h
            };
          } else {
            var loc = o.location,
                absolute = false;
            if (isString(o.location) || o.location < 0 || o.location > 1) {
              loc = parseInt("" + o.location, 10);
              absolute = true;
            }
            cxy = component.pointOnPath(loc, absolute);
          }
          var minx = cxy.x - td.w / 2,
              miny = cxy.y - td.h / 2;
          return {
            component: o,
            d: {
              minx: minx,
              miny: miny,
              td: td,
              cxy: cxy
            },
            xmin: minx,
            xmax: minx + td.w,
            ymin: miny,
            ymax: miny + td.h
          };
        } else {
          return {
            xmin: 0,
            xmax: 0,
            ymin: 0,
            ymax: 0
          };
        }
      } else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
        return o.draw(component, paintStyle, absolutePosition);
      } else {
        throw "Could not draw overlay of type [" + o.type + "]";
      }
    }
  }, {
    key: "updateLabel",
    value: function updateLabel(o) {
      if (isFunction(o.label)) {
        var lt = o.label(this);
        if (lt != null) {
          getLabelElement(o).innerText = lt;
        } else {
          getLabelElement(o).innerText = "";
        }
      } else {
        if (o.labelText == null) {
          o.labelText = o.label;
          if (o.labelText != null) {
            getLabelElement(o).innerText = o.labelText;
          } else {
            getLabelElement(o).innerText = "";
          }
        }
      }
    }
  }, {
    key: "setHover",
    value: function setHover(component, hover) {
      component._hover = hover;
      if (component instanceof jsplumb_core_es_Endpoint && component.endpoint != null) {
        this.setEndpointHover(component, hover);
      } else if (component instanceof jsplumb_core_es_Connection && component.connector != null) {
        this.setConnectorHover(component.connector, hover);
      }
    }
  }, {
    key: "paintConnector",
    value: function paintConnector(connector, paintStyle, extents) {
      paintSvgConnector(this, connector, paintStyle, extents);
    }
  }, {
    key: "setConnectorHover",
    value: function setConnectorHover(connector, h, doNotCascade) {
      if (h === false || !this.currentlyDragging && !this.isHoverSuspended()) {
        var method = h ? "addClass" : "removeClass";
        var canvas = connector.canvas;
        if (canvas != null) {
          if (connector.hoverClass != null) {
            this[method](canvas, connector.hoverClass);
          }
          this[method](canvas, this.hoverClass);
        }
        if (connector.connection.hoverPaintStyle != null) {
          connector.connection.paintStyleInUse = h ? connector.connection.hoverPaintStyle : connector.connection.paintStyle;
          if (!this._suspendDrawing) {
            this.paintConnection(connector.connection);
          }
        }
        if (!doNotCascade) {
          this.setEndpointHover(connector.connection.endpoints[0], h, true);
          this.setEndpointHover(connector.connection.endpoints[1], h, true);
        }
      }
    }
  }, {
    key: "destroyConnector",
    value: function destroyConnector(connection) {
      if (connection.connector != null) {
        cleanup(connection.connector);
      }
    }
  }, {
    key: "addConnectorClass",
    value: function addConnectorClass(connector, clazz) {
      if (connector.canvas) {
        this.addClass(connector.canvas, clazz);
      }
    }
  }, {
    key: "removeConnectorClass",
    value: function removeConnectorClass(connector, clazz) {
      if (connector.canvas) {
        this.removeClass(connector.canvas, clazz);
      }
    }
  }, {
    key: "getConnectorClass",
    value: function getConnectorClass(connector) {
      if (connector.canvas) {
        return connector.canvas.className.baseVal;
      } else {
        return "";
      }
    }
  }, {
    key: "setConnectorVisible",
    value: function setConnectorVisible(connector, v) {
      setVisible(connector, v);
    }
  }, {
    key: "applyConnectorType",
    value: function applyConnectorType(connector, t) {
      if (connector.canvas && t.cssClass) {
        var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
        this.addClass(connector.canvas, classes.join(" "));
      }
    }
  }, {
    key: "addEndpointClass",
    value: function addEndpointClass(ep, c) {
      var canvas = getEndpointCanvas(ep.endpoint);
      if (canvas != null) {
        this.addClass(canvas, c);
      }
    }
  }, {
    key: "applyEndpointType",
    value: function applyEndpointType(ep, t) {
      if (t.cssClass) {
        var canvas = getEndpointCanvas(ep.endpoint);
        if (canvas) {
          var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
          this.addClass(canvas, classes.join(" "));
        }
      }
    }
  }, {
    key: "destroyEndpoint",
    value: function destroyEndpoint(ep) {
      var anchorClass = this.endpointAnchorClassPrefix + (ep.currentAnchorClass ? "-" + ep.currentAnchorClass : "");
      this.removeClass(ep.element, anchorClass);
      cleanup(ep.endpoint);
    }
  }, {
    key: "renderEndpoint",
    value: function renderEndpoint(ep, paintStyle) {
      var renderer = jsplumb_browser_ui_es_endpointMap[ep.endpoint.type];
      if (renderer != null) {
        jsplumb_browser_ui_es_SvgEndpoint.paint(ep.endpoint, renderer, paintStyle);
      } else {
        log("jsPlumb: no endpoint renderer found for type [" + ep.endpoint.type + "]");
      }
    }
  }, {
    key: "removeEndpointClass",
    value: function removeEndpointClass(ep, c) {
      var canvas = getEndpointCanvas(ep.endpoint);
      if (canvas != null) {
        this.removeClass(canvas, c);
      }
    }
  }, {
    key: "getEndpointClass",
    value: function getEndpointClass(ep) {
      var canvas = getEndpointCanvas(ep.endpoint);
      if (canvas != null) {
        return canvas.className;
      } else {
        return "";
      }
    }
  }, {
    key: "setEndpointHover",
    value: function setEndpointHover(endpoint, h, doNotCascade) {
      if (endpoint != null && (h === false || !this.currentlyDragging && !this.isHoverSuspended())) {
        var method = h ? "addClass" : "removeClass";
        var canvas = getEndpointCanvas(endpoint.endpoint);
        if (canvas != null) {
          if (endpoint.hoverClass != null) {
            this[method](canvas, endpoint.hoverClass);
          }
        }
        if (endpoint.hoverPaintStyle != null) {
          endpoint.paintStyleInUse = h ? endpoint.hoverPaintStyle : endpoint.paintStyle;
          if (!this._suspendDrawing) {
            this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
          }
        }
        if (!doNotCascade) {
          for (var i = 0; i < endpoint.connections.length; i++) {
            this.setConnectorHover(endpoint.connections[i].connector, h, true);
          }
        }
      }
    }
  }, {
    key: "setEndpointVisible",
    value: function setEndpointVisible(ep, v) {
      setVisible(ep.endpoint, v);
    }
  }, {
    key: "setGroupVisible",
    value: function setGroupVisible(group, state) {
      var m = group.el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
      for (var i = 0; i < m.length; i++) {
        if (state) {
          this.show(m[i], true);
        } else {
          this.hide(m[i], true);
        }
      }
    }
  }, {
    key: "deleteConnection",
    value: function deleteConnection(connection, params) {
      if (connection != null && connection.deleted !== true) {
        this.setEndpointHover(connection.endpoints[0], false, true);
        this.setEndpointHover(connection.endpoints[1], false, true);
        return jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "deleteConnection", this).call(this, connection, params);
      } else {
        return false;
      }
    }
  }, {
    key: "addSourceSelector",
    value: function addSourceSelector(selector, params, exclude) {
      this.addDragFilter(selector);
      return jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "addSourceSelector", this).call(this, selector, params, exclude);
    }
  }, {
    key: "removeSourceSelector",
    value: function removeSourceSelector(selector) {
      this.removeDragFilter(selector.selector);
      jsplumb_browser_ui_es_get(jsplumb_browser_ui_es_getPrototypeOf(BrowserJsPlumbInstance.prototype), "removeSourceSelector", this).call(this, selector);
    }
  }]);
  return BrowserJsPlumbInstance;
}(jsplumb_core_es_JsPlumbInstance);

var CIRCLE = "circle";
var register$2 = function register() {
  registerEndpointRenderer(DotEndpoint.type, {
    makeNode: function makeNode(ep, style) {
      return _node(CIRCLE, {
        "cx": ep.w / 2,
        "cy": ep.h / 2,
        "r": ep.radius
      });
    },
    updateNode: function updateNode(ep, node) {
      _attr(node, {
        "cx": "" + ep.w / 2,
        "cy": "" + ep.h / 2,
        "r": "" + ep.radius
      });
    }
  });
};

var RECT = "rect";
var register$1 = function register() {
  registerEndpointRenderer(RectangleEndpoint.type, {
    makeNode: function makeNode(ep, style) {
      return _node(RECT, {
        "width": ep.w,
        "height": ep.h
      });
    },
    updateNode: function updateNode(ep, node) {
      _attr(node, {
        "width": ep.w,
        "height": ep.h
      });
    }
  });
};

var BLANK_ATTRIBUTES = {
  "width": 10,
  "height": 0,
  "fill": "transparent",
  "stroke": "transparent"
};
var jsplumb_browser_ui_es_register = function register() {
  registerEndpointRenderer(BlankEndpoint.type, {
    makeNode: function makeNode(ep, style) {
      return _node("rect", BLANK_ATTRIBUTES);
    },
    updateNode: function updateNode(ep, node) {
      _attr(node, BLANK_ATTRIBUTES);
    }
  });
};

register$2();
jsplumb_browser_ui_es_register();
register$1();
var _jsPlumbInstanceIndex = 0;
function getInstanceIndex() {
  var i = _jsPlumbInstanceIndex + 1;
  _jsPlumbInstanceIndex++;
  return i;
}
function newInstance(defaults) {
  return new jsplumb_browser_ui_es_BrowserJsPlumbInstance(getInstanceIndex(), defaults);
}
function ready(f) {
  var _do = function _do() {
    if (/complete|loaded|interactive/.test(document.readyState) && typeof document.body !== "undefined" && document.body != null) {
      f();
    } else {
      setTimeout(_do, 9);
    }
  };
  _do();
}



// CONCATENATED MODULE: ./src/helpers/symbols.ts



var JsPlumbKey = Symbol('JsPlumb');
// CONCATENATED MODULE: ./node_modules/@jsplumb/connector-flowchart/js/jsplumb.connector-flowchart.es.js


function jsplumb_connector_flowchart_es_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function jsplumb_connector_flowchart_es_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function jsplumb_connector_flowchart_es_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) jsplumb_connector_flowchart_es_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) jsplumb_connector_flowchart_es_defineProperties(Constructor, staticProps);
  return Constructor;
}

function jsplumb_connector_flowchart_es_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function jsplumb_connector_flowchart_es_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) jsplumb_connector_flowchart_es_setPrototypeOf(subClass, superClass);
}

function jsplumb_connector_flowchart_es_getPrototypeOf(o) {
  jsplumb_connector_flowchart_es_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return jsplumb_connector_flowchart_es_getPrototypeOf(o);
}

function jsplumb_connector_flowchart_es_setPrototypeOf(o, p) {
  jsplumb_connector_flowchart_es_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return jsplumb_connector_flowchart_es_setPrototypeOf(o, p);
}

function jsplumb_connector_flowchart_es_isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function jsplumb_connector_flowchart_es_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function jsplumb_connector_flowchart_es_possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return jsplumb_connector_flowchart_es_assertThisInitialized(self);
}

function jsplumb_connector_flowchart_es_createSuper(Derived) {
  var hasNativeReflectConstruct = jsplumb_connector_flowchart_es_isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = jsplumb_connector_flowchart_es_getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = jsplumb_connector_flowchart_es_getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return jsplumb_connector_flowchart_es_possibleConstructorReturn(this, result);
  };
}

function sgn(n) {
  return n < 0 ? -1 : n === 0 ? 0 : 1;
}
function segmentDirections(segment) {
  return [sgn(segment[2] - segment[0]), sgn(segment[3] - segment[1])];
}
function segLength(s) {
  return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
}
function _cloneArray(a) {
  var _a = [];
  _a.push.apply(_a, a);
  return _a;
}
var jsplumb_connector_flowchart_es_FlowchartConnector = function (_AbstractConnector) {
  jsplumb_connector_flowchart_es_inherits(FlowchartConnector, _AbstractConnector);
  var _super = jsplumb_connector_flowchart_es_createSuper(FlowchartConnector);
  function FlowchartConnector(connection, params) {
    var _this;
    jsplumb_connector_flowchart_es_classCallCheck(this, FlowchartConnector);
    _this = _super.call(this, connection, params);
    _this.connection = connection;
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "type", FlowchartConnector.type);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "internalSegments", []);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "midpoint", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "alwaysRespectStubs", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "cornerRadius", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "lastx", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "lasty", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "lastOrientation", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "loopbackRadius", void 0);
    jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_assertThisInitialized(_this), "isLoopbackCurrently", void 0);
    _this.midpoint = params.midpoint == null || isNaN(params.midpoint) ? 0.5 : params.midpoint;
    _this.cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0;
    _this.alwaysRespectStubs = params.alwaysRespectStubs === true;
    _this.lastx = null;
    _this.lasty = null;
    _this.lastOrientation = null;
    _this.loopbackRadius = params.loopbackRadius || 25;
    _this.isLoopbackCurrently = false;
    return _this;
  }
  jsplumb_connector_flowchart_es_createClass(FlowchartConnector, [{
    key: "getDefaultStubs",
    value: function getDefaultStubs() {
      return [30, 30];
    }
  }, {
    key: "addASegment",
    value: function addASegment(x, y, paintInfo) {
      if (this.lastx === x && this.lasty === y) {
        return;
      }
      var lx = this.lastx == null ? paintInfo.sx : this.lastx,
          ly = this.lasty == null ? paintInfo.sy : this.lasty,
          o = lx === x ? "v" : "h";
      this.lastx = x;
      this.lasty = y;
      this.internalSegments.push([lx, ly, x, y, o]);
    }
  }, {
    key: "writeSegments",
    value: function writeSegments(paintInfo) {
      var current = null,
          next,
          currentDirection,
          nextDirection;
      for (var i = 0; i < this.internalSegments.length - 1; i++) {
        current = current || _cloneArray(this.internalSegments[i]);
        next = _cloneArray(this.internalSegments[i + 1]);
        currentDirection = segmentDirections(current);
        nextDirection = segmentDirections(next);
        if (this.cornerRadius > 0 && current[4] !== next[4]) {
          var minSegLength = Math.min(segLength(current), segLength(next));
          var radiusToUse = Math.min(this.cornerRadius, minSegLength / 2);
          current[2] -= currentDirection[0] * radiusToUse;
          current[3] -= currentDirection[1] * radiusToUse;
          next[0] += nextDirection[0] * radiusToUse;
          next[1] += nextDirection[1] * radiusToUse;
          var ac = currentDirection[1] === nextDirection[0] && nextDirection[0] === 1 || currentDirection[1] === nextDirection[0] && nextDirection[0] === 0 && currentDirection[0] !== nextDirection[1] || currentDirection[1] === nextDirection[0] && nextDirection[0] === -1,
              sgny = next[1] > current[3] ? 1 : -1,
              sgnx = next[0] > current[2] ? 1 : -1,
              sgnEqual = sgny === sgnx,
              cx = sgnEqual && ac || !sgnEqual && !ac ? next[0] : current[2],
              cy = sgnEqual && ac || !sgnEqual && !ac ? current[3] : next[1];
          this._addSegment(jsplumb_core_es_StraightSegment, {
            x1: current[0],
            y1: current[1],
            x2: current[2],
            y2: current[3]
          });
          this._addSegment(jsplumb_core_es_ArcSegment, {
            r: radiusToUse,
            x1: current[2],
            y1: current[3],
            x2: next[0],
            y2: next[1],
            cx: cx,
            cy: cy,
            ac: ac
          });
        } else {
          this._addSegment(jsplumb_core_es_StraightSegment, {
            x1: current[0],
            y1: current[1],
            x2: current[2],
            y2: current[3]
          });
        }
        current = next;
      }
      if (next != null) {
        this._addSegment(jsplumb_core_es_StraightSegment, {
          x1: next[0],
          y1: next[1],
          x2: next[2],
          y2: next[3]
        });
      }
    }
  }, {
    key: "_compute",
    value: function _compute(paintInfo, params) {
      var _this2 = this;
      this.internalSegments.length = 0;
      this.lastx = null;
      this.lasty = null;
      this.lastOrientation = null;
      var commonStubCalculator = function commonStubCalculator(axis) {
        return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
      },
          stubCalculators = {
        perpendicular: commonStubCalculator,
        orthogonal: commonStubCalculator,
        opposite: function opposite(axis) {
          var pi = paintInfo,
              idx = axis === "x" ? 0 : 1,
              areInProximity = {
            "x": function x() {
              return pi.so[idx] === 1 && (pi.startStubX > pi.endStubX && pi.tx > pi.startStubX || pi.sx > pi.endStubX && pi.tx > pi.sx) || pi.so[idx] === -1 && (pi.startStubX < pi.endStubX && pi.tx < pi.startStubX || pi.sx < pi.endStubX && pi.tx < pi.sx);
            },
            "y": function y() {
              return pi.so[idx] === 1 && (pi.startStubY > pi.endStubY && pi.ty > pi.startStubY || pi.sy > pi.endStubY && pi.ty > pi.sy) || pi.so[idx] === -1 && (pi.startStubY < pi.endStubY && pi.ty < pi.startStubY || pi.sy < pi.endStubY && pi.ty < pi.sy);
            }
          };
          if (!_this2.alwaysRespectStubs && areInProximity[axis]()) {
            return {
              "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
              "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
            }[axis];
          } else {
            return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
          }
        }
      };
      var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
          idx = paintInfo.sourceAxis === "x" ? 0 : 1,
          oidx = paintInfo.sourceAxis === "x" ? 1 : 0,
          ss = stubs[idx],
          oss = stubs[oidx],
          es = stubs[idx + 2],
          oes = stubs[oidx + 2];
      this.addASegment(stubs[0], stubs[1], paintInfo);
      var midx = paintInfo.startStubX + (paintInfo.endStubX - paintInfo.startStubX) * this.midpoint,
          midy = paintInfo.startStubY + (paintInfo.endStubY - paintInfo.startStubY) * this.midpoint;
      var orientations = {
        x: [0, 1],
        y: [1, 0]
      },
          lineCalculators = {
        perpendicular: function perpendicular(axis, ss, oss, es, oes) {
          var pi = paintInfo,
              sis = {
            x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
            y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
          },
              stubs = {
            x: [[pi.startStubX, pi.endStubX], null, [pi.endStubX, pi.startStubX]],
            y: [[pi.startStubY, pi.endStubY], null, [pi.endStubY, pi.startStubY]]
          },
              midLines = {
            x: [[midx, pi.startStubY], [midx, pi.endStubY]],
            y: [[pi.startStubX, midy], [pi.endStubX, midy]]
          },
              linesToEnd = {
            x: [[pi.endStubX, pi.startStubY]],
            y: [[pi.startStubX, pi.endStubY]]
          },
              startToEnd = {
            x: [[pi.startStubX, pi.endStubY], [pi.endStubX, pi.endStubY]],
            y: [[pi.endStubX, pi.startStubY], [pi.endStubX, pi.endStubY]]
          },
              startToMidToEnd = {
            x: [[pi.startStubX, midy], [pi.endStubX, midy], [pi.endStubX, pi.endStubY]],
            y: [[midx, pi.startStubY], [midx, pi.endStubY], [pi.endStubX, pi.endStubY]]
          },
              otherStubs = {
            x: [pi.startStubY, pi.endStubY],
            y: [pi.startStubX, pi.endStubX]
          },
              soIdx = orientations[axis][0],
              toIdx = orientations[axis][1],
              _so = pi.so[soIdx] + 1,
              _to = pi.to[toIdx] + 1,
              otherFlipped = pi.to[toIdx] === -1 && otherStubs[axis][1] < otherStubs[axis][0] || pi.to[toIdx] === 1 && otherStubs[axis][1] > otherStubs[axis][0],
              stub1 = stubs[axis][_so][0],
              stub2 = stubs[axis][_so][1],
              segmentIndexes = sis[axis][_so][_to];
          if (pi.segment === segmentIndexes[3] || pi.segment === segmentIndexes[2] && otherFlipped) {
            return midLines[axis];
          } else if (pi.segment === segmentIndexes[2] && stub2 < stub1) {
            return linesToEnd[axis];
          } else if (pi.segment === segmentIndexes[2] && stub2 >= stub1 || pi.segment === segmentIndexes[1] && !otherFlipped) {
            return startToMidToEnd[axis];
          } else if (pi.segment === segmentIndexes[0] || pi.segment === segmentIndexes[1] && otherFlipped) {
            return startToEnd[axis];
          }
        },
        orthogonal: function orthogonal(axis, startStub, otherStartStub, endStub, otherEndStub) {
          var pi = paintInfo,
              extent = {
            "x": pi.so[0] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
            "y": pi.so[1] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
          }[axis];
          return {
            "x": [[extent, otherStartStub], [extent, otherEndStub], [endStub, otherEndStub]],
            "y": [[otherStartStub, extent], [otherEndStub, extent], [otherEndStub, endStub]]
          }[axis];
        },
        opposite: function opposite(axis, ss, oss, es, oes) {
          var pi = paintInfo,
              otherAxis = {
            "x": "y",
            "y": "x"
          }[axis],
              dim = {
            "x": "h",
            "y": "w"
          }[axis],
              comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];
          if (params.sourceEndpoint.elementId === params.targetEndpoint.elementId) {
            var _val = oss + (1 - params.sourceEndpoint._anchor[otherAxis]) * params.sourceInfo[dim] + _this2.maxStub;
            return {
              "x": [[ss, _val], [es, _val]],
              "y": [[_val, ss], [_val, es]]
            }[axis];
          } else if (!comparator || pi.so[idx] === 1 && ss > es || pi.so[idx] === -1 && ss < es) {
            return {
              "x": [[ss, midy], [es, midy]],
              "y": [[midx, ss], [midx, es]]
            }[axis];
          } else if (pi.so[idx] === 1 && ss < es || pi.so[idx] === -1 && ss > es) {
            return {
              "x": [[midx, pi.sy], [midx, pi.ty]],
              "y": [[pi.sx, midy], [pi.tx, midy]]
            }[axis];
          }
        }
      };
      var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
      if (p) {
        for (var i = 0; i < p.length; i++) {
          this.addASegment(p[i][0], p[i][1], paintInfo);
        }
      }
      this.addASegment(stubs[2], stubs[3], paintInfo);
      this.addASegment(paintInfo.tx, paintInfo.ty, paintInfo);
      this.writeSegments(paintInfo);
    }
  }]);
  return FlowchartConnector;
}(jsplumb_core_es_AbstractConnector);
jsplumb_connector_flowchart_es_defineProperty(jsplumb_connector_flowchart_es_FlowchartConnector, "type", "Flowchart");

Connectors.register(jsplumb_connector_flowchart_es_FlowchartConnector.type, jsplumb_connector_flowchart_es_FlowchartConnector);



// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function defineProperty_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function arrayWithoutHoles_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js







function iterableToArray_iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function nonIterableSpread_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function toConsumableArray_toConsumableArray(arr) {
  return arrayWithoutHoles_arrayWithoutHoles(arr) || iterableToArray_iterableToArray(arr) || _unsupportedIterableToArray(arr) || nonIterableSpread_nonIterableSpread();
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// CONCATENATED MODULE: ./node_modules/seemly/es/css/index.js
function depx(value) {
    if (typeof value === 'string') {
        if (value.endsWith('px')) {
            return Number(value.slice(0, value.length - 2));
        }
        return Number(value);
    }
    return value;
}
function pxfy(value) {
    if (value === undefined || value === null)
        return undefined;
    if (typeof value === 'number')
        return `${value}px`;
    if (value.endsWith('px'))
        return value;
    return `${value}px`;
}

function getMargin(value, position) {
    const parts = value.trim().split(/\s+/g);
    const margin = {
        top: parts[0]
    };
    switch (parts.length) {
        case 1:
            margin.right = parts[0];
            margin.bottom = parts[0];
            margin.left = parts[0];
            break;
        case 2:
            margin.right = parts[1];
            margin.left = parts[1];
            margin.bottom = parts[0];
            break;
        case 3:
            margin.right = parts[1];
            margin.bottom = parts[2];
            margin.left = parts[1];
            break;
        case 4:
            margin.right = parts[1];
            margin.bottom = parts[2];
            margin.left = parts[3];
            break;
        default:
            throw new Error('[seemly/getMargin]:' + value + ' is not a valid value.');
    }
    if (position === undefined)
        return margin;
    return margin[position];
}
function getGap(value, orient) {
    const [rowGap, colGap] = value.split(' ');
    if (!orient)
        return {
            row: rowGap,
            col: colGap || rowGap
        };
    return orient === 'row' ? rowGap : colGap;
}



// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheClear.js
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ var _listCacheClear = (listCacheClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/eq.js
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ var lodash_es_eq = (eq);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assocIndexOf.js


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (lodash_es_eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ var _assocIndexOf = (assocIndexOf);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheDelete.js


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/* harmony default export */ var _listCacheDelete = (listCacheDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheGet.js


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ var _listCacheGet = (listCacheGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheHas.js


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

/* harmony default export */ var _listCacheHas = (listCacheHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheSet.js


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ var _listCacheSet = (listCacheSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_ListCache.js






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

/* harmony default export */ var _ListCache = (ListCache);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackClear.js


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

/* harmony default export */ var _stackClear = (stackClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackDelete.js
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/* harmony default export */ var _stackDelete = (stackDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackGet.js
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ var _stackGet = (stackGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackHas.js
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ var _stackHas = (stackHas);

// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__("26ee");

// CONCATENATED MODULE: ./node_modules/lodash-es/_Symbol.js


/** Built-in value references. */
var _Symbol_Symbol = _root["a" /* default */].Symbol;

/* harmony default export */ var _Symbol = (_Symbol_Symbol);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getRawTag.js


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ var _getRawTag = (getRawTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var _objectToString_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return _objectToString_nativeObjectToString.call(value);
}

/* harmony default export */ var _objectToString = (objectToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetTag.js




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

/* harmony default export */ var _baseGetTag = (baseGetTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/isObject.js
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject_isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ var lodash_es_isObject = (isObject_isObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/isFunction.js



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction_isFunction(value) {
  if (!lodash_es_isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ var lodash_es_isFunction = (isFunction_isFunction);

// CONCATENATED MODULE: ./node_modules/lodash-es/_coreJsData.js


/** Used to detect overreaching core-js shims. */
var coreJsData = _root["a" /* default */]['__core-js_shared__'];

/* harmony default export */ var _coreJsData = (coreJsData);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isMasked.js


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ var _isMasked = (isMasked);

// CONCATENATED MODULE: ./node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ var _toSource = (toSource);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsNative.js





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var _baseIsNative_funcProto = Function.prototype,
    _baseIsNative_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;

/** Used to check objects for own properties. */
var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!lodash_es_isObject(value) || _isMasked(value)) {
    return false;
  }
  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

/* harmony default export */ var _baseIsNative = (baseIsNative);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getValue.js
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ var _getValue = (getValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getNative.js



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

/* harmony default export */ var _getNative = (getNative);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Map.js



/* Built-in method references that are verified to be native. */
var _Map_Map = _getNative(_root["a" /* default */], 'Map');

/* harmony default export */ var _Map = (_Map_Map);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeCreate.js


/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

/* harmony default export */ var _nativeCreate = (nativeCreate);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashClear.js


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

/* harmony default export */ var _hashClear = (hashClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashDelete.js
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _hashDelete = (hashDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashGet.js


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var _hashGet_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ var _hashGet = (hashGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashHas.js


/** Used for built-in method references. */
var _hashHas_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : _hashHas_hasOwnProperty.call(data, key);
}

/* harmony default export */ var _hashHas = (hashHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashSet.js


/** Used to stand-in for `undefined` hash values. */
var _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? _hashSet_HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ var _hashSet = (hashSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Hash.js






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

/* harmony default export */ var _Hash = (Hash);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheClear.js




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

/* harmony default export */ var _mapCacheClear = (mapCacheClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isKeyable.js
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ var _isKeyable = (isKeyable);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getMapData.js


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ var _getMapData = (getMapData);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheDelete.js


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _mapCacheDelete = (mapCacheDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheGet.js


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

/* harmony default export */ var _mapCacheGet = (mapCacheGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheHas.js


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

/* harmony default export */ var _mapCacheHas = (mapCacheHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheSet.js


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ var _mapCacheSet = (mapCacheSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_MapCache.js






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

/* harmony default export */ var _MapCache = (MapCache);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackSet.js




/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ var _stackSet = (stackSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Stack.js







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

/* harmony default export */ var _Stack = (Stack);

// CONCATENATED MODULE: ./node_modules/lodash-es/_defineProperty.js


var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* harmony default export */ var lodash_es_defineProperty = (defineProperty);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignValue.js


/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && lodash_es_defineProperty) {
    lodash_es_defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ var _baseAssignValue = (baseAssignValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assignMergeValue.js



/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !lodash_es_eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignMergeValue = (assignMergeValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createBaseFor.js
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/* harmony default export */ var _createBaseFor = (createBaseFor);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseFor.js


/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

/* harmony default export */ var _baseFor = (baseFor);

// EXTERNAL MODULE: ./node_modules/lodash-es/_cloneBuffer.js
var _cloneBuffer = __webpack_require__("dff1");

// CONCATENATED MODULE: ./node_modules/lodash-es/_Uint8Array.js


/** Built-in value references. */
var Uint8Array = _root["a" /* default */].Uint8Array;

/* harmony default export */ var _Uint8Array = (Uint8Array);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneArrayBuffer.js


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

/* harmony default export */ var _cloneArrayBuffer = (cloneArrayBuffer);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneTypedArray.js


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ var _cloneTypedArray = (cloneTypedArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_copyArray.js
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ var _copyArray = (copyArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseCreate.js


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!lodash_es_isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/* harmony default export */ var _baseCreate = (baseCreate);

// CONCATENATED MODULE: ./node_modules/lodash-es/_overArg.js
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ var _overArg = (overArg);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getPrototype.js


/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

/* harmony default export */ var _getPrototype = (getPrototype);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var _isPrototype_objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || _isPrototype_objectProto;

  return value === proto;
}

/* harmony default export */ var _isPrototype = (isPrototype);

// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneObject.js




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

/* harmony default export */ var _initCloneObject = (initCloneObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/isObjectLike.js
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsArguments.js



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
}

/* harmony default export */ var _baseIsArguments = (baseIsArguments);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArguments.js



/** Used for built-in method references. */
var isArguments_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ var lodash_es_isArguments = (isArguments);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArray.js
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ var lodash_es_isArray = (isArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ var lodash_es_isLength = (isLength);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLike.js



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike_isArrayLike(value) {
  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
}

/* harmony default export */ var lodash_es_isArrayLike = (isArrayLike_isArrayLike);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLikeObject.js



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return lodash_es_isObjectLike(value) && lodash_es_isArrayLike(value);
}

/* harmony default export */ var lodash_es_isArrayLikeObject = (isArrayLikeObject);

// EXTERNAL MODULE: ./node_modules/lodash-es/isBuffer.js
var isBuffer = __webpack_require__("58e0");

// CONCATENATED MODULE: ./node_modules/lodash-es/isPlainObject.js




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var isPlainObject_funcProto = Function.prototype,
    isPlainObject_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var isPlainObject_funcToString = isPlainObject_funcProto.toString;

/** Used to check objects for own properties. */
var isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = isPlainObject_funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = isPlainObject_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    isPlainObject_funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ var lodash_es_isPlainObject = (isPlainObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsTypedArray.js




/** `Object#toString` result references. */
var _baseIsTypedArray_argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    _baseIsTypedArray_funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    _baseIsTypedArray_objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[_baseIsTypedArray_objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return lodash_es_isObjectLike(value) &&
    lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

/* harmony default export */ var _baseIsTypedArray = (baseIsTypedArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUnary.js
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ var _baseUnary = (baseUnary);

// EXTERNAL MODULE: ./node_modules/lodash-es/_nodeUtil.js
var _nodeUtil = __webpack_require__("c6eb");

// CONCATENATED MODULE: ./node_modules/lodash-es/isTypedArray.js




/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil["a" /* default */] && _nodeUtil["a" /* default */].isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

/* harmony default export */ var lodash_es_isTypedArray = (isTypedArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_safeGet.js
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/* harmony default export */ var _safeGet = (safeGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assignValue.js



/** Used for built-in method references. */
var _assignValue_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignValue = (assignValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_copyObject.js



/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

/* harmony default export */ var _copyObject = (copyObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTimes.js
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ var _baseTimes = (baseTimes);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var _isIndex_MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? _isIndex_MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ var _isIndex = (isIndex);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayLikeKeys.js







/** Used for built-in method references. */
var _arrayLikeKeys_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = lodash_es_isArray(value),
      isArg = !isArr && lodash_es_isArguments(value),
      isBuff = !isArr && !isArg && Object(isBuffer["a" /* default */])(value),
      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _arrayLikeKeys = (arrayLikeKeys);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeysIn.js
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _nativeKeysIn = (nativeKeysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeysIn.js




/** Used for built-in method references. */
var _baseKeysIn_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!lodash_es_isObject(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _baseKeysIn = (baseKeysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/keysIn.js




/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

/* harmony default export */ var lodash_es_keysIn = (keysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/toPlainObject.js



/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return _copyObject(value, lodash_es_keysIn(value));
}

/* harmony default export */ var lodash_es_toPlainObject = (toPlainObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMergeDeep.js
















/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key),
      srcValue = _safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = lodash_es_isArray(srcValue),
        isBuff = !isArr && Object(isBuffer["a" /* default */])(srcValue),
        isTyped = !isArr && !isBuff && lodash_es_isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (lodash_es_isArray(objValue)) {
        newValue = objValue;
      }
      else if (lodash_es_isArrayLikeObject(objValue)) {
        newValue = _copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = Object(_cloneBuffer["a" /* default */])(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (lodash_es_isPlainObject(srcValue) || lodash_es_isArguments(srcValue)) {
      newValue = objValue;
      if (lodash_es_isArguments(objValue)) {
        newValue = lodash_es_toPlainObject(objValue);
      }
      else if (!lodash_es_isObject(objValue) || lodash_es_isFunction(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}

/* harmony default export */ var _baseMergeDeep = (baseMergeDeep);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMerge.js








/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack);
    if (lodash_es_isObject(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, lodash_es_keysIn);
}

/* harmony default export */ var _baseMerge = (baseMerge);

// CONCATENATED MODULE: ./node_modules/lodash-es/identity.js
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ var lodash_es_identity = (identity);

// CONCATENATED MODULE: ./node_modules/lodash-es/_apply.js
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ var _apply = (apply);

// CONCATENATED MODULE: ./node_modules/lodash-es/_overRest.js


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

/* harmony default export */ var _overRest = (overRest);

// CONCATENATED MODULE: ./node_modules/lodash-es/constant.js
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ var lodash_es_constant = (constant);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSetToString.js




/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !lodash_es_defineProperty ? lodash_es_identity : function(func, string) {
  return lodash_es_defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': lodash_es_constant(string),
    'writable': true
  });
};

/* harmony default export */ var _baseSetToString = (baseSetToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_shortOut.js
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ var _shortOut = (shortOut);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setToString.js



/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

/* harmony default export */ var _setToString = (setToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseRest.js




/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, lodash_es_identity), func + '');
}

/* harmony default export */ var _baseRest = (baseRest);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isIterateeCall.js





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!lodash_es_isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (lodash_es_isArrayLike(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return lodash_es_eq(object[index], value);
  }
  return false;
}

/* harmony default export */ var _isIterateeCall = (isIterateeCall);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createAssigner.js



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ var _createAssigner = (createAssigner);

// CONCATENATED MODULE: ./node_modules/lodash-es/merge.js



/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge_merge = _createAssigner(function(object, source, srcIndex) {
  _baseMerge(object, source, srcIndex);
});

/* harmony default export */ var lodash_es_merge = (merge_merge);

// CONCATENATED MODULE: ./node_modules/@css-render/vue3-ssr/esm/index.js

const ssrContextKey = Symbol('@css-render/vue3-ssr');
function createStyleString(id, style) {
    return `<style cssr-id="${id}">\n${style}\n</style>`;
}
function esm_ssrAdapter(id, style) {
    const ssrContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(ssrContextKey, null);
    if (ssrContext === null) {
        console.error('[css-render/vue3-ssr]: no ssr context found.');
        return;
    }
    const { styles, ids } = ssrContext;
    // we need to impl other options to make it behaves the same as the client side
    if (ids.has(id))
        return;
    if (styles !== null) {
        ids.add(id);
        styles.push(createStyleString(id, style));
    }
}
function useSsrAdapter() {
    const context = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(ssrContextKey, null);
    if (context === null)
        return undefined;
    return {
        adapter: esm_ssrAdapter,
        context
    };
}
function esm_setup(app) {
    const styles = [];
    const ssrContext = {
        styles,
        ids: new Set()
    };
    app.provide(ssrContextKey, ssrContext);
    return {
        collect() {
            const res = styles.join('\n');
            styles.length = 0;
            return res;
        }
    };
}

// CONCATENATED MODULE: ./node_modules/css-render/esm/parse.js
function ampCount(selector) {
    let cnt = 0;
    for (let i = 0; i < selector.length; ++i) {
        if (selector[i] === '&')
            ++cnt;
    }
    return cnt;
}
/**
 * Don't just use ',' to separate css selector. For example:
 * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.
 * Make sure comma doesn't exist inside parentheses.
 */
const seperatorRegex = /\s*,(?![^(]*\))\s*/g;
const extraSpaceRegex = /\s+/g;
/**
 * selector must includes '&'
 * selector is trimmed
 * every part of amp is trimmed
 */
function resolveSelectorWithAmp(amp, selector) {
    const nextAmp = [];
    selector.split(seperatorRegex).forEach(partialSelector => {
        let round = ampCount(partialSelector);
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (!round) {
            amp.forEach(partialAmp => {
                nextAmp.push(
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                (partialAmp && partialAmp + ' ') + partialSelector);
            });
            return;
        }
        else if (round === 1) {
            amp.forEach(partialAmp => {
                nextAmp.push(partialSelector.replace('&', partialAmp));
            });
            return;
        }
        let partialNextAmp = [
            partialSelector
        ];
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        while (round--) {
            const nextPartialNextAmp = [];
            partialNextAmp.forEach(selectorItr => {
                amp.forEach(partialAmp => {
                    nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));
                });
            });
            partialNextAmp = nextPartialNextAmp;
        }
        partialNextAmp.forEach(part => nextAmp.push(part));
    });
    return nextAmp;
}
/**
 * selector mustn't includes '&'
 * selector is trimmed
 */
function resolveSelector(amp, selector) {
    const nextAmp = [];
    selector.split(seperatorRegex).forEach(partialSelector => {
        amp.forEach(partialAmp => {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            nextAmp.push(((partialAmp && partialAmp + ' ') + partialSelector));
        });
    });
    return nextAmp;
}
function parseSelectorPath(selectorPaths) {
    let amp = [''];
    selectorPaths.forEach(selector => {
        // eslint-disable-next-line
        selector = selector && selector.trim();
        if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        !selector) {
            /**
             * if it's a empty selector, do nothing
             */
            return;
        }
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (selector.includes('&')) {
            amp = resolveSelectorWithAmp(amp, selector);
        }
        else {
            amp = resolveSelector(amp, selector);
        }
    });
    return amp.join(', ').replace(extraSpaceRegex, ' ');
}

// CONCATENATED MODULE: ./node_modules/css-render/esm/render.js

const kebabRegex = /[A-Z]/g;
function kebabCase(pattern) {
    return pattern.replace(kebabRegex, match => '-' + match.toLowerCase());
}
/** TODO: refine it to solve nested object */
function upwrapProperty(prop, indent = '  ') {
    if (typeof prop === 'object' && prop !== null) {
        return (' {\n' +
            Object.entries(prop).map(v => {
                return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
            }).join('\n') +
            '\n' + indent + '}');
    }
    return `: ${prop};`;
}
/** unwrap properties */
function upwrapProperties(props, instance, params) {
    if (typeof props === 'function') {
        return props({
            context: instance.context,
            props: params
        });
    }
    return props;
}
function createStyle(selector, props, instance, params) {
    if (!props)
        return '';
    // eslint-disable-next-line
    const unwrappedProps = upwrapProperties(props, instance, params);
    if (!unwrappedProps)
        return '';
    if (typeof unwrappedProps === 'string') {
        return `${selector} {\n${unwrappedProps}\n}`;
    }
    const propertyNames = Object.keys(unwrappedProps);
    if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock)
            return selector + ' {\n}';
        return '';
    }
    const statements = selector
        ? [
            selector + ' {'
        ]
        : [];
    propertyNames.forEach(propertyName => {
        const property = unwrappedProps[propertyName];
        if (propertyName === 'raw') {
            statements.push('\n' + property + '\n');
            return;
        }
        propertyName = kebabCase(propertyName);
        if (property !== null && property !== undefined) {
            statements.push(`  ${propertyName}${upwrapProperty(property)}`);
        }
    });
    if (selector) {
        statements.push('}');
    }
    return statements.join('\n');
}
function loopCNodeListWithCallback(children, options, callback) {
    /* istanbul ignore if */
    if (!children)
        return;
    children.forEach(child => {
        if (Array.isArray(child)) {
            loopCNodeListWithCallback(child, options, callback);
        }
        else if (typeof child === 'function') {
            const grandChildren = child(options);
            if (Array.isArray(grandChildren)) {
                loopCNodeListWithCallback(grandChildren, options, callback);
            }
            else if (grandChildren) {
                callback(grandChildren);
            }
        }
        else if (child) {
            callback(child);
        }
    });
}
function traverseCNode(node, selectorPaths, styles, instance, params, styleSheet) {
    const $ = node.$;
    if (!$ || typeof $ === 'string') {
        // as a string selector
        selectorPaths.push($);
    }
    else if (typeof $ === 'function') {
        // as a lazy selector
        selectorPaths.push($({
            context: instance.context,
            props: params
        }));
    }
    else { // as a option selector
        if ($.before)
            $.before(instance.context);
        if (!$.$ || typeof $.$ === 'string') {
            selectorPaths.push($.$);
        }
        else /* istanbul ignore else */ if ($.$) {
            selectorPaths.push($.$({
                context: instance.context,
                props: params
            }));
        }
    }
    const selector = parseSelectorPath(selectorPaths);
    const style = createStyle(selector, node.props, instance, params);
    if (styleSheet && style) {
        styleSheet.insertRule(style);
    }
    if (!styleSheet && style.length)
        styles.push(style);
    if (node.children) {
        loopCNodeListWithCallback(node.children, {
            context: instance.context,
            props: params
        }, childNode => {
            if (typeof childNode === 'string') {
                const style = createStyle(selector, { raw: childNode }, instance, params);
                if (styleSheet) {
                    styleSheet.insertRule(style);
                }
                else {
                    styles.push(style);
                }
            }
            else {
                traverseCNode(childNode, selectorPaths, styles, instance, params, styleSheet);
            }
        });
    }
    selectorPaths.pop();
    if ($ && $.after)
        $.after(instance.context);
}
function render_render(node, instance, props, insertRule = false) {
    const styles = [];
    traverseCNode(node, [], styles, instance, props, insertRule
        ? node.instance.__styleSheet
        : undefined);
    if (insertRule)
        return '';
    return styles.join('\n\n');
}

// CONCATENATED MODULE: ./node_modules/@emotion/hash/dist/hash.browser.esm.js
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

/* harmony default export */ var hash_browser_esm = (murmur2);

// CONCATENATED MODULE: ./node_modules/css-render/esm/utils.js
function removeElement(el) {
    /* istanbul ignore if */
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (!el)
        return;
    const parentElement = el.parentElement;
    /* istanbul ignore else */
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (parentElement)
        parentElement.removeChild(el);
}
function queryElement(id) {
    return document.querySelector(`style[cssr-id="${id}"]`);
}
function utils_createElement(id) {
    const el = document.createElement('style');
    el.setAttribute('cssr-id', id);
    return el;
}

// CONCATENATED MODULE: ./node_modules/css-render/esm/mount.js
/* eslint-disable @typescript-eslint/strict-boolean-expressions */



if (typeof window !== 'undefined') {
    window.__cssrContext = {};
}
function unmount(intance, node, id) {
    const { els } = node;
    // If id is undefined, unmount all styles
    if (id === undefined) {
        els.forEach(removeElement);
        node.els = [];
    }
    else {
        const target = queryElement(id);
        // eslint-disable-next-line
        if (target && els.includes(target)) {
            removeElement(target);
            node.els = els.filter((el) => el !== target);
        }
    }
}
function addElementToList(els, target) {
    els.push(target);
}
function mount(instance, node, id, props, head, slient, force, ssrAdapter
// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
) {
    var _a;
    if (slient && !ssrAdapter) {
        if (id === undefined) {
            // it is possible to use hash to get rid of the requirements of id
            // if you are interested in it, please create a pr
            // i have no time to impl it
            console.error('[css-render/mount]: `id` is required in `slient` mode.');
            // @ts-expect-error
            return;
        }
        const cssrContext = window.__cssrContext;
        if (!cssrContext[id]) {
            cssrContext[id] = true;
            render_render(node, instance, props, slient);
        }
        // @ts-expect-error
        return;
    }
    let style;
    if (id === undefined) {
        style = node.render(props);
        id = hash_browser_esm(style);
    }
    if (ssrAdapter) {
        ssrAdapter.adapter(id, style !== null && style !== void 0 ? style : node.render(props));
        // @ts-expect-error
        return;
    }
    const queriedTarget = queryElement(id);
    if (queriedTarget !== null && !force) {
        // @ts-expect-error
        return queriedTarget;
    }
    const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : utils_createElement(id);
    if (style === undefined)
        style = node.render(props);
    target.textContent = style;
    // @ts-expect-error
    if (queriedTarget !== null)
        return queriedTarget;
    if (head) {
        const firstStyleEl = (_a = document.head.querySelector('style, link')) !== null && _a !== void 0 ? _a : null;
        document.head.insertBefore(target, firstStyleEl);
    }
    else {
        document.head.appendChild(target);
    }
    addElementToList(node.els, target);
    // @ts-expect-error
    return queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : target;
}


// CONCATENATED MODULE: ./node_modules/css-render/esm/c.js


function wrappedRender(props) {
    return render_render(this, this.instance, props);
}
// do not guard node calling, it should throw an error.
function wrappedMount(options = {}
// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
) {
    const { id, ssr, props, head = false, slient = false, force = false } = options;
    const targetElement = mount(this.instance, this, id, props, head, slient, force, ssr);
    return targetElement;
}
function wrappedUnmount(options = {}) {
    /* istanbul ignore next */
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    const { id } = options;
    unmount(this.instance, this, id);
}
const createCNode = function (instance, $, props, children) {
    return {
        instance,
        $,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
    };
};
const c_c = function (instance, $, props, children) {
    if (Array.isArray($)) {
        return createCNode(instance, { $: null }, null, $);
    }
    if (Array.isArray(props)) {
        return createCNode(instance, $, null, props);
    }
    else if (Array.isArray(children)) {
        return createCNode(instance, $, props, children);
    }
    else {
        return createCNode(instance, $, props, null);
    }
};

// CONCATENATED MODULE: ./node_modules/css-render/esm/CssRender.js


function CssRender(config = {}) {
    let styleSheet = null;
    const cssr = {
        c: ((...args) => c_c(cssr, ...args)),
        use: (plugin, ...args) => plugin.install(cssr, ...args),
        find: queryElement,
        context: {},
        config,
        get __styleSheet() {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!styleSheet) {
                const style = document.createElement('style');
                document.head.appendChild(style);
                styleSheet = document.styleSheets[document.styleSheets.length - 1];
                return styleSheet;
            }
            return styleSheet;
        }
    };
    return cssr;
}

// CONCATENATED MODULE: ./node_modules/css-render/esm/index.js
/* istanbul ignore file */





/* harmony default export */ var esm = (CssRender);

// CONCATENATED MODULE: ./node_modules/@css-render/plugin-bem/esm/index.js
/* eslint-disable @typescript-eslint/restrict-template-expressions */
/* eslint-disable @typescript-eslint/strict-boolean-expressions */
function esm_plugin(options) {
    let _bPrefix = '.';
    let _ePrefix = '__';
    let _mPrefix = '--';
    let c;
    if (options) {
        let t = options.blockPrefix;
        if (t) {
            _bPrefix = t;
        }
        t = options.elementPrefix;
        if (t) {
            _ePrefix = t;
        }
        t = options.modifierPrefix;
        if (t) {
            _mPrefix = t;
        }
    }
    const _plugin = {
        install(instance) {
            c = instance.c;
            const ctx = instance.context;
            ctx.bem = {};
            ctx.bem.b = null;
            ctx.bem.els = null;
        }
    };
    function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
            before(ctx) {
                memorizedB = ctx.bem.b;
                memorizedE = ctx.bem.els;
                ctx.bem.els = null;
            },
            after(ctx) {
                ctx.bem.b = memorizedB;
                ctx.bem.els = memorizedE;
            },
            $({ context, props }) {
                arg = typeof arg === 'string' ? arg : arg({ context, props });
                context.bem.b = arg;
                return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
            }
        };
    }
    function e(arg) {
        let memorizedE;
        return {
            before(ctx) {
                memorizedE = ctx.bem.els;
            },
            after(ctx) {
                ctx.bem.els = memorizedE;
            },
            $({ context, props }) {
                arg = typeof arg === 'string' ? arg : arg({ context, props });
                context.bem.els = arg.split(',').map(v => v.trim());
                return context.bem.els
                    .map(el => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}__${el}`).join(', ');
            }
        };
    }
    function m(arg) {
        return {
            $({ context, props }) {
                arg = typeof arg === 'string' ? arg : arg({ context, props });
                const modifiers = arg.split(',').map(v => v.trim());
                function elementToSelector(el) {
                    return modifiers.map(modifier => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== undefined ? `${_ePrefix}${el}` : ''}${_mPrefix}${modifier}`).join(', ');
                }
                const els = context.bem.els;
                if (els !== null) {
                    if (false) {}
                    return elementToSelector(els[0]);
                }
                else {
                    return elementToSelector();
                }
            }
        };
    }
    function notM(arg) {
        return {
            $({ context, props }) {
                arg = typeof arg === 'string' ? arg : arg({ context, props });
                const els = context.bem.els;
                if (false) {}
                return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${(els !== null && els.length > 0) ? `${_ePrefix}${els[0]}` : ''}${_mPrefix}${arg})`;
            }
        };
    }
    const cB = ((...args) => c(b(args[0]), args[1], args[2]));
    const cE = ((...args) => c(e(args[0]), args[1], args[2]));
    const cM = ((...args) => c(m(args[0]), args[1], args[2]));
    const cNotM = ((...args) => c(notM(args[0]), args[1], args[2]));
    Object.assign(_plugin, {
        cB, cE, cM, cNotM
    });
    return _plugin;
}

/* harmony default export */ var plugin_bem_esm = (esm_plugin);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/cssr/index.js
/* eslint-disable @typescript-eslint/restrict-template-expressions */


const namespace = 'n';
const prefix = `.${namespace}-`;
const elementPrefix = '__';
const modifierPrefix = '--';
const cssr_cssr = esm();
const cssr_plugin = plugin_bem_esm({
    blockPrefix: prefix,
    elementPrefix,
    modifierPrefix
});
cssr_cssr.use(cssr_plugin);
const { c: cssr_c, find } = cssr_cssr;
const { cB, cE, cM, cNotM } = cssr_plugin;
function insideFormItem(status, style) {
    if (status === null)
        return style;
    return cssr_c([
        ({ props: { bPrefix } }) => cssr_c(`${bPrefix || prefix}form-item`, [
            cssr_c(`${bPrefix || prefix}form-item-blank`, [
                cssr_c(`&${bPrefix || prefix}form-item-blank${modifierPrefix}${status}`, [
                    style
                ])
            ])
        ])
    ]);
}
function insideModal(style) {
    return cssr_c(({ props: { bPrefix } }) => `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`, [style]);
}
function insidePopover(style) {
    return cssr_c(({ props: { bPrefix } }) => `${bPrefix || prefix}popover:not(${bPrefix || prefix}tooltip)`, [style]);
}
function asModal(style) {
    return cssr_c(({ props: { bPrefix } }) => `&${bPrefix || prefix}modal`, style);
}
// child block
const cCB = ((...args) => {
    return cssr_c('>', [cB(...args)]);
});



// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/common/_common.js
/* harmony default export */ var _common = ({
    fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    fontFamilyMono: 'v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace',
    fontWeight: '400',
    fontWeightStrong: '500',
    cubicBezierEaseInOut: 'cubic-bezier(.4, 0, .2, 1)',
    cubicBezierEaseOut: 'cubic-bezier(0, 0, .2, 1)',
    cubicBezierEaseIn: 'cubic-bezier(.4, 0, 1, 1)',
    borderRadius: '3px',
    borderRadiusSmall: '2px',
    fontSize: '14px',
    fontSizeTiny: '12px',
    fontSizeSmall: '14px',
    fontSizeMedium: '14px',
    fontSizeLarge: '15px',
    fontSizeHuge: '16px',
    lineHeight: '1.6',
    heightTiny: '22px',
    heightSmall: '28px',
    heightMedium: '34px',
    heightLarge: '40px',
    heightHuge: '46px',
    transformDebounceScale: 'scale(1)'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/global/index.cssr.js


const {
  fontSize: index_cssr_fontSize,
  fontFamily,
  lineHeight: index_cssr_lineHeight
} = _common; // All the components need the style
// It is static and won't be changed in the app's lifetime
// If user want to overrides it they need to use `n-global-style` is provided
//
// Technically we can remove font-size & font-family & line-height to make
// it pure. However the coding cost doesn't worth it.
//
// -webkit-tap-hilight-color:
// https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-tap-highlight-color
// In some android devices, there will be the style.

/* harmony default export */ var index_cssr = (cssr_c('body', `
 margin: 0;
 font-size: ${index_cssr_fontSize};
 font-family: ${fontFamily};
 line-height: ${index_cssr_lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [cssr_c('input', `
 font-family: inherit;
 font-size: inherit;
 `)]));
// CONCATENATED MODULE: ./node_modules/vooks/es/use-memo.js

function useMemo(getterOrOptions) {
    const computedValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(getterOrOptions);
    // Maybe it's not possible to lazy evaluate the value, since we can't make
    // render phase capture the deps behind useMemo
    const valueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(computedValueRef.value);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(computedValueRef, (value) => {
        valueRef.value = value;
    });
    if (typeof getterOrOptions === 'function') {
        return valueRef;
    }
    else {
        return {
            __v_isRef: true,
            get value() {
                return valueRef.value;
            },
            set value(v) {
                getterOrOptions.set(v);
            }
        };
    }
}
/* harmony default export */ var use_memo = (useMemo);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/naive/warn.js
const warnedMessages = new Set();
function warnOnce(location, message) {
    const mergedMessage = `[naive/${location}]: ${message}`;
    if (warnedMessages.has(mergedMessage))
        return;
    warnedMessages.add(mergedMessage);
    console.error(mergedMessage);
}
function warn(location, message) {
    console.error(`[naive/${location}]: ${message}`);
}
function throwError(location, message) {
    throw new Error(`[naive/${location}]: ${message}`);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_mixins/use-config.js


const defaultClsPrefix = 'n';
function useConfig(props = {}, options = {
    defaultBordered: true
}) {
    const NConfigProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(configProviderInjectionKey, null);
    return {
        NConfigProvider,
        mergedBorderedRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            var _a, _b;
            const { bordered } = props;
            if (bordered !== undefined)
                return bordered;
            return ((_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true);
        }),
        mergedClsPrefixRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const clsPrefix = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
            return clsPrefix || defaultClsPrefix;
        }),
        namespaceRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
    };
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/config-provider/src/ConfigProvider.js





const configProviderInjectionKey = Symbol('configProviderInjection');
const configProviderProps = {
    abstract: Boolean,
    bordered: {
        type: Boolean,
        default: undefined
    },
    clsPrefix: String,
    locale: Object,
    dateLocale: Object,
    namespace: String,
    rtl: Array,
    tag: {
        type: String,
        default: 'div'
    },
    hljs: Object,
    theme: Object,
    themeOverrides: Object,
    componentOptions: Object,
    icons: Object,
    breakpoints: Object,
    // deprecated
    as: {
        type: String,
        validator: () => {
            warn('config-provider', '`as` is deprecated, please use `tag` instead.');
            return true;
        },
        default: undefined
    }
};
/* harmony default export */ var ConfigProvider = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'ConfigProvider',
    alias: ['App'],
    props: configProviderProps,
    setup(props) {
        const NConfigProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(configProviderInjectionKey, null);
        const mergedThemeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { theme } = props;
            if (theme === null)
                return undefined;
            const inheritedTheme = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value;
            return theme === undefined
                ? inheritedTheme
                : inheritedTheme === undefined
                    ? theme
                    : Object.assign({}, inheritedTheme, theme);
        });
        const mergedThemeOverridesRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { themeOverrides } = props;
            // stop inheriting themeOverrides
            if (themeOverrides === null)
                return undefined;
            // use inherited themeOverrides
            if (themeOverrides === undefined) {
                return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
            }
            else {
                const inheritedThemeOverrides = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
                if (inheritedThemeOverrides === undefined) {
                    // no inherited, use self overrides
                    return themeOverrides;
                }
                else {
                    // merge overrides
                    return lodash_es_merge({}, inheritedThemeOverrides, themeOverrides);
                }
            }
        });
        const mergedNamespaceRef = use_memo(() => {
            const { namespace } = props;
            return namespace === undefined
                ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value
                : namespace;
        });
        const mergedBorderedRef = use_memo(() => {
            const { bordered } = props;
            return bordered === undefined
                ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value
                : bordered;
        });
        const mergedIconsRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { icons } = props;
            return icons === undefined ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedIconsRef.value : icons;
        });
        const mergedComponentPropsRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { componentOptions } = props;
            if (componentOptions !== undefined)
                return componentOptions;
            return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value;
        });
        const mergedClsPrefixRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { clsPrefix } = props;
            if (clsPrefix !== undefined)
                return clsPrefix;
            return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
        });
        const mergedRtlRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { rtl } = props;
            if (rtl === undefined) {
                return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef.value;
            }
            const rtlEnabledState = {};
            for (const rtlInfo of rtl) {
                rtlEnabledState[rtlInfo.name] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["markRaw"])(rtlInfo);
            }
            return rtlEnabledState;
        });
        const mergedBreakpointsRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return props.breakpoints || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef.value);
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(configProviderInjectionKey, {
            mergedBreakpointsRef,
            mergedRtlRef,
            mergedIconsRef,
            mergedComponentPropsRef,
            mergedBorderedRef,
            mergedNamespaceRef,
            mergedClsPrefixRef,
            mergedLocaleRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { locale } = props;
                if (locale === null)
                    return undefined;
                return locale === undefined
                    ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedLocaleRef.value
                    : locale;
            }),
            mergedDateLocaleRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { dateLocale } = props;
                if (dateLocale === null)
                    return undefined;
                return dateLocale === undefined
                    ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedDateLocaleRef.value
                    : dateLocale;
            }),
            mergedHljsRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { hljs } = props;
                return hljs === undefined ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedHljsRef.value : hljs;
            }),
            mergedThemeRef,
            mergedThemeOverridesRef
        });
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            mergedNamespace: mergedNamespaceRef,
            mergedTheme: mergedThemeRef,
            mergedThemeOverrides: mergedThemeOverridesRef
        };
    },
    render() {
        return !this.abstract
            ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(this.as || this.tag, {
                class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
            }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'default'))
            : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'default');
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_mixins/use-theme.js
/* eslint-disable @typescript-eslint/consistent-type-assertions */





function createTheme(theme) {
    return theme;
}
function useTheme(resolveId, mountId, style, defaultTheme, props, clsPrefixRef) {
    const ssrAdapter = useSsrAdapter();
    if (style) {
        const mountStyle = () => {
            const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
            style.mount({
                id: clsPrefix === undefined ? mountId : clsPrefix + mountId,
                head: true,
                props: {
                    bPrefix: clsPrefix ? `.${clsPrefix}-` : undefined
                },
                ssr: ssrAdapter
            });
            index_cssr.mount({
                id: 'naive-ui/global',
                head: true,
                ssr: ssrAdapter
            });
        };
        if (ssrAdapter) {
            mountStyle();
        }
        else {
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(mountStyle);
        }
    }
    const NConfigProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(configProviderInjectionKey, null);
    const mergedThemeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        var _a;
        // keep props to make theme overrideable
        const { theme: { common: selfCommon, self, peers = {} } = {}, themeOverrides: selfOverrides = {}, builtinThemeOverrides: builtinOverrides = {} } = props;
        const { common: selfCommonOverrides, peers: peersOverrides } = selfOverrides;
        const { common: globalCommon = undefined, [resolveId]: { common: globalSelfCommon = undefined, self: globalSelf = undefined, peers: globalPeers = {} } = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
        const { common: globalCommonOverrides = undefined, [resolveId]: globalSelfOverrides = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
        const { common: globalSelfCommonOverrides, peers: globalPeersOverrides = {} } = globalSelfOverrides;
        const mergedCommon = lodash_es_merge({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = lodash_es_merge(
        // {}, executed every time, no need for empty obj
        (_a = (self || globalSelf || defaultTheme.self)) === null || _a === void 0 ? void 0 : _a(mergedCommon), builtinOverrides, globalSelfOverrides, selfOverrides);
        return {
            common: mergedCommon,
            self: mergedSelf,
            peers: lodash_es_merge({}, defaultTheme.peers, globalPeers, peers),
            peerOverrides: lodash_es_merge({}, globalPeersOverrides, peersOverrides)
        };
    });
    return mergedThemeRef;
}
useTheme.props = {
    theme: Object,
    themeOverrides: Object,
    builtinThemeOverrides: Object
};
/**
 * props.theme (Theme):
 * {
 *   common: CommonThemeVars,
 *   self(): ThemeVars,
 *   peers: { Component: Theme }
 * }
 * provider.theme:
 * {
 *   common: CommonThemeVars,
 *   Button: Theme
 *   ...
 * }
 * defaultTheme:
 * {
 *   common: CommonThemeVars,
 *   self(): ThemeVars,
 *   peers: { Component: Theme }
 * }
 *
 * props.themeOverrides (ThemeOverrides):
 * {
 *   common: CommonThemeVars,
 *   peers: { Component: ThemeOverrides },
 *   ...ThemeVars
 * }
 * provider.themeOverrides:
 * {
 *   common: CommonThemeVars,
 *   Component: ThemeOverrides
 *   ...
 * }
 *
 * mergedTheme:
 * {
 *   common: CommonThemeVars,
 *   self: ThemeVars,
 *   peers: { Component: Theme },
 *   overrides: { Component: ThemeOverrides }
 * }
 */
/* harmony default export */ var use_theme = (useTheme);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/keysOf.js
function keysOf(obj) {
    return Object.keys(obj);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/call.js
function call(funcs, ...args) {
    if (Array.isArray(funcs)) {
        funcs.forEach((func) => call(func, ...args));
    }
    else
        return funcs(...args);
}


// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/cssr/create-key.js
function createKey(prefix, suffix) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (prefix +
        (suffix === 'default'
            ? ''
            : suffix.replace(/^[a-z]/, (startChar) => startChar.toUpperCase())));
}
createKey('abc', 'def');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_mixins/use-style.js




function useStyle(mountId, style, clsPrefixRef) {
    if (!style) {
        if (false)
            {}
        return;
    }
    const ssrAdapter = useSsrAdapter();
    const mountStyle = () => {
        const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
        style.mount({
            id: clsPrefix === undefined ? mountId : clsPrefix + mountId,
            head: true,
            props: {
                bPrefix: clsPrefix ? `.${clsPrefix}-` : undefined
            },
            ssr: ssrAdapter
        });
        index_cssr.mount({
            id: 'naive-ui/global',
            head: true,
            ssr: ssrAdapter
        });
    };
    if (ssrAdapter) {
        mountStyle();
    }
    else {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(mountStyle);
    }
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icon/src/styles/index.cssr.js

/* harmony default export */ var styles_index_cssr = (cB('base-icon', `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cssr_c('svg', {
  height: '1em',
  width: '1em'
})]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icon/src/Icon.js



/* harmony default export */ var Icon = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'BaseIcon',
    props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
            type: Boolean,
            default: undefined
        },
        ariaHidden: {
            type: Boolean,
            default: undefined
        },
        clsPrefix: {
            type: String,
            required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
    },
    setup(props) {
        useStyle('BaseIcon', styles_index_cssr, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'clsPrefix'));
    },
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("i", { class: `${this.clsPrefix}-base-icon`, onClick: this.onClick, onMousedown: this.onMousedown, onMouseup: this.onMouseup, role: this.role, "aria-label": this.ariaLabel, "aria-hidden": this.ariaHidden, "aria-disabled": this.ariaDisabled }, this.$slots));
    }
}));

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSlice.js
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* harmony default export */ var _baseSlice = (baseSlice);

// CONCATENATED MODULE: ./node_modules/lodash-es/_castSlice.js


/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : _baseSlice(array, start, end);
}

/* harmony default export */ var _castSlice = (castSlice);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hasUnicode.js
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/* harmony default export */ var _hasUnicode = (hasUnicode);

// CONCATENATED MODULE: ./node_modules/lodash-es/_asciiToArray.js
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/* harmony default export */ var _asciiToArray = (asciiToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_unicodeToArray.js
/** Used to compose unicode character classes. */
var _unicodeToArray_rsAstralRange = '\\ud800-\\udfff',
    _unicodeToArray_rsComboMarksRange = '\\u0300-\\u036f',
    _unicodeToArray_reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    _unicodeToArray_rsComboSymbolsRange = '\\u20d0-\\u20ff',
    _unicodeToArray_rsComboRange = _unicodeToArray_rsComboMarksRange + _unicodeToArray_reComboHalfMarksRange + _unicodeToArray_rsComboSymbolsRange,
    _unicodeToArray_rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + _unicodeToArray_rsAstralRange + ']',
    rsCombo = '[' + _unicodeToArray_rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + _unicodeToArray_rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    _unicodeToArray_rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + _unicodeToArray_rsVarRange + ']?',
    rsOptJoin = '(?:' + _unicodeToArray_rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/* harmony default export */ var _unicodeToArray = (unicodeToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToArray.js




/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return _hasUnicode(string)
    ? _unicodeToArray(string)
    : _asciiToArray(string);
}

/* harmony default export */ var _stringToArray = (stringToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayMap.js
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/* harmony default export */ var _arrayMap = (arrayMap);

// CONCATENATED MODULE: ./node_modules/lodash-es/isSymbol.js



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (lodash_es_isObjectLike(value) && _baseGetTag(value) == symbolTag);
}

/* harmony default export */ var lodash_es_isSymbol = (isSymbol);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseToString.js





/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (lodash_es_isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (lodash_es_isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ var _baseToString = (baseToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/toString.js


/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString_toString(value) {
  return value == null ? '' : _baseToString(value);
}

/* harmony default export */ var lodash_es_toString = (toString_toString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createCaseFirst.js





/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = lodash_es_toString(string);

    var strSymbols = _hasUnicode(string)
      ? _stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? _castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/* harmony default export */ var _createCaseFirst = (createCaseFirst);

// CONCATENATED MODULE: ./node_modules/lodash-es/upperFirst.js


/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = _createCaseFirst('toUpperCase');

/* harmony default export */ var lodash_es_upperFirst = (upperFirst);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/replaceable.js



// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function replaceable(name, icon) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
        name: lodash_es_upperFirst(name),
        setup() {
            const { NConfigProvider } = useConfig();
            return () => {
                var _a;
                const iconOverride = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedIconsRef.value) === null || _a === void 0 ? void 0 : _a[name];
                return iconOverride ? iconOverride() : icon;
            };
        }
    });
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Close.js


/* harmony default export */ var Close = (replaceable('close', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 12 12", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { fill: "currentColor", "fill-rule": "nonzero" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z" }))))));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/close/src/styles/index.cssr.js
 // vars:
// --close-color
// --close-color-hover
// --close-color-pressed
// --close-color-disabled

/* harmony default export */ var src_styles_index_cssr = (cB('base-close', `
 cursor: pointer;
 color: var(--close-color);
`, [cssr_c('&:hover', {
  color: 'var(--close-color-hover)'
}), cssr_c('&:active', {
  color: 'var(--close-color-pressed)'
}), cM('disabled', {
  cursor: 'not-allowed!important',
  color: 'var(--close-color-disabled)'
})]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/close/src/Close.js





/* harmony default export */ var src_Close = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'BaseClose',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        disabled: {
            type: Boolean,
            default: undefined
        },
        onClick: Function
    },
    setup(props) {
        useStyle('BaseClose', src_styles_index_cssr, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'clsPrefix'));
        return () => {
            const { clsPrefix, disabled } = props;
            return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { role: "button", ariaDisabled: disabled, ariaLabel: "close", clsPrefix: clsPrefix, class: [
                    `${clsPrefix}-base-close`,
                    disabled && `${clsPrefix}-base-close--disabled`
                ], onClick: disabled ? undefined : props.onClick }, {
                default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Close, null)
            }));
        };
    }
}));

// CONCATENATED MODULE: ./node_modules/seemly/es/color/colors.js
/* harmony default export */ var colors = ({
    black: '#000',
    silver: '#C0C0C0',
    gray: '#808080',
    white: '#FFF',
    maroon: '#800000',
    red: '#F00',
    purple: '#800080',
    fuchsia: '#F0F',
    green: '#008000',
    lime: '#0F0',
    olive: '#808000',
    yellow: '#FF0',
    navy: '#000080',
    blue: '#00F',
    teal: '#008080',
    aqua: '#0FF',
    transparent: '#0000'
});

// CONCATENATED MODULE: ./node_modules/seemly/es/color/index.js

const color_prefix = '^\\s*';
const suffix = '\\s*$';
const percent = '\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*'; // 4 offset
const color_float = '\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*'; // 4 offset
const hex = '([0-9A-Fa-f])';
const dhex = '([0-9A-Fa-f]{2})';
const hslRegex = new RegExp(`${color_prefix}hsl\\s*\\(${color_float},${percent},${percent}\\)${suffix}`);
const hsvRegex = new RegExp(`${color_prefix}hsv\\s*\\(${color_float},${percent},${percent}\\)${suffix}`);
const hslaRegex = new RegExp(`${color_prefix}hsla\\s*\\(${color_float},${percent},${percent},${color_float}\\)${suffix}`);
const hsvaRegex = new RegExp(`${color_prefix}hsva\\s*\\(${color_float},${percent},${percent},${color_float}\\)${suffix}`);
const rgbRegex = new RegExp(`${color_prefix}rgb\\s*\\(${color_float},${color_float},${color_float}\\)${suffix}`);
const rgbaRegex = new RegExp(`${color_prefix}rgba\\s*\\(${color_float},${color_float},${color_float},${color_float}\\)${suffix}`);
const sHexRegex = new RegExp(`${color_prefix}#${hex}${hex}${hex}${suffix}`);
const hexRegex = new RegExp(`${color_prefix}#${dhex}${dhex}${dhex}${suffix}`);
const sHexaRegex = new RegExp(`${color_prefix}#${hex}${hex}${hex}${hex}${suffix}`);
const hexaRegex = new RegExp(`${color_prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
function parseHex(value) {
    return parseInt(value, 16);
}
/**
 * Convert color string to hsla array
 * @param color format like hsl(180, 100%, 100%), hsla(180, 100%, 100%, 1)
 * @returns
 */
function hsla(color) {
    try {
        let i;
        if ((i = hslaRegex.exec(color))) {
            return [
                roundDeg(i[1]),
                roundPercent(i[5]),
                roundPercent(i[9]),
                roundAlpha(i[13])
            ];
        }
        else if ((i = hslRegex.exec(color))) {
            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }
        throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
    }
    catch (e) {
        throw e;
    }
}
/**
 * Convert color string to hsva array
 * @param color format like hsv(180, 100%, 100%), hsva(180, 100%, 100%, 1)
 * @returns
 */
function hsva(color) {
    try {
        let i;
        if ((i = hsvaRegex.exec(color))) {
            return [
                roundDeg(i[1]),
                roundPercent(i[5]),
                roundPercent(i[9]),
                roundAlpha(i[13])
            ];
        }
        else if ((i = hsvRegex.exec(color))) {
            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }
        throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
    }
    catch (e) {
        throw e;
    }
}
/**
 * Convert color string to rgba array.
 * @param color format like #000[0], #000000[00], rgb(0, 0, 0), rgba(0, 0, 0, 0) and basic color keywords https://www.w3.org/TR/css-color-3/#html4 and transparent
 * @returns
 */
function rgba(color) {
    try {
        let i;
        if ((i = hexRegex.exec(color))) {
            return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
        }
        else if ((i = rgbRegex.exec(color))) {
            return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
        }
        else if ((i = rgbaRegex.exec(color))) {
            return [
                roundChannel(i[1]),
                roundChannel(i[5]),
                roundChannel(i[9]),
                roundAlpha(i[13])
            ];
        }
        else if ((i = sHexRegex.exec(color))) {
            return [
                parseHex(i[1] + i[1]),
                parseHex(i[2] + i[2]),
                parseHex(i[3] + i[3]),
                1
            ];
        }
        else if ((i = hexaRegex.exec(color))) {
            return [
                parseHex(i[1]),
                parseHex(i[2]),
                parseHex(i[3]),
                roundAlpha(parseHex(i[4]) / 255)
            ];
        }
        else if ((i = sHexaRegex.exec(color))) {
            return [
                parseHex(i[1] + i[1]),
                parseHex(i[2] + i[2]),
                parseHex(i[3] + i[3]),
                roundAlpha(parseHex(i[4] + i[4]) / 255)
            ];
        }
        else if (color in colors) {
            return rgba(colors[color]);
        }
        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
    }
    catch (e) {
        throw e;
    }
}
function normalizeAlpha(alphaValue) {
    return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
}
function stringifyRgb(r, g, b) {
    return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
}
function stringifyRgba(r, g, b, a) {
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
}
function compositeChannel(v1, a1, v2, a2, a) {
    return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
}
function composite(background, overlay) {
    if (!Array.isArray(background))
        background = rgba(background);
    if (!Array.isArray(overlay))
        overlay = rgba(overlay);
    const a1 = background[3];
    const a2 = overlay[3];
    const alpha = roundAlpha(a1 + a2 - a1 * a2);
    return stringifyRgba(compositeChannel(background[0], a1, overlay[0], a2, alpha), compositeChannel(background[1], a1, overlay[1], a2, alpha), compositeChannel(background[2], a1, overlay[2], a2, alpha), alpha);
}
function changeColor(base, options) {
    const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
    if (options.alpha) {
        return stringifyRgba(r, g, b, options.alpha);
    }
    return stringifyRgba(r, g, b, a);
}
function scaleColor(base, options) {
    const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
    const { lightness = 1, alpha = 1 } = options;
    return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
}
function getAlpha(base) {
    var _a;
    const alpha = (_a = (Array.isArray(base) ? base : rgba(base))[3]) !== null && _a !== void 0 ? _a : 1;
    return alpha;
}
function getAlphaString(base) {
    return `${getAlpha(base)}`;
}
function roundAlpha(value) {
    const v = Math.round(Number(value) * 100) / 100;
    if (v > 1)
        return 1;
    if (v < 0)
        return 0;
    return v;
}
function roundDeg(value) {
    const v = Math.round(Number(value));
    if (v >= 360)
        return 0;
    if (v < 0)
        return 0;
    return v;
}
function roundChannel(value) {
    const v = Math.round(Number(value));
    if (v > 255)
        return 255;
    if (v < 0)
        return 0;
    return v;
}
function roundPercent(value) {
    const v = Math.round(Number(value));
    if (v > 100)
        return 100;
    if (v < 0)
        return 0;
    return v;
}
function toRgbString(base) {
    const [r, g, b] = Array.isArray(base) ? base : rgba(base);
    return stringifyRgb(r, g, b);
}
function toRgbaString(base) {
    const [r, g, b] = base;
    if (3 in base) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base[3])})`;
    }
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
}
function toHsvString(base) {
    return `hsv(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
}
function toHsvaString(base) {
    const [h, s, v] = base;
    if (3 in base) {
        return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base[3])})`;
    }
    return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
}
function toHslString(base) {
    return `hsl(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
}
function toHslaString(base) {
    const [h, s, l] = base;
    if (3 in base) {
        return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base[3])})`;
    }
    return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
}
/**
 *
 * @param base [255, 255, 255, 255], [255, 255, 255], any hex string
 * @returns
 */
function toHexaString(base) {
    if (typeof base === 'string') {
        let i;
        if (i = hexRegex.exec(base)) {
            return `${i[0]}FF`;
        }
        else if (i = hexaRegex.exec(base)) {
            return i[0];
        }
        else if (i = sHexRegex.exec(base)) {
            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
        }
        else if (i = sHexaRegex.exec(base)) {
            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
        }
        throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
    }
    const hex = `#${base
        .slice(0, 3)
        .map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0'))
        .join('')}`;
    const a = base.length === 3
        ? 'FF'
        : roundChannel(base[3] * 255)
            .toString(16)
            .padStart(2, '0')
            .toUpperCase();
    return hex + a;
}
/**
 *
 * @param base [255, 255, 255, 255], [255, 255, 255], any hex string
 * @returns
 */
function toHexString(base) {
    if (typeof base === 'string') {
        let i;
        if (i = hexRegex.exec(base)) {
            return i[0];
        }
        else if (i = hexaRegex.exec(base)) {
            return i[0].slice(0, 7);
        }
        else if (i = (sHexRegex.exec(base) || sHexaRegex.exec(base))) {
            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
        }
        throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
    }
    return `#${base
        .slice(0, 3)
        .map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0'))
        .join('')}`;
}


// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/common/light.js


const base = {
    neutralBase: '#FFF',
    neutralInvertBase: '#000',
    neutralTextBase: '#000',
    neutralPopover: '#fff',
    neutralCard: '#fff',
    neutralModal: '#fff',
    neutralBody: '#fff',
    alpha1: '0.82',
    alpha2: '0.72',
    alpha3: '0.38',
    alpha4: '0.24',
    alpha5: '0.18',
    alphaClose: '0.52',
    alphaDisabled: '0.5',
    alphaDisabledInput: '0.02',
    alphaPending: '0.05',
    alphaTablePending: '0.02',
    alphaPressed: '0.07',
    alphaAvatar: '0.2',
    alphaRail: '0.14',
    alphaProgressRail: '.08',
    alphaBorder: '0.12',
    alphaDivider: '0.06',
    alphaInput: '0',
    alphaAction: '0.02',
    alphaTab: '0.04',
    alphaScrollbar: '0.25',
    alphaScrollbarHover: '0.4',
    alphaCode: '0.05',
    alphaTag: '0.02',
    // primary
    primaryHover: '#36ad6a',
    primaryDefault: '#18a058',
    primaryActive: '#0c7a43',
    primarySuppl: '#36ad6a',
    // info
    infoHover: '#4098fc',
    infoDefault: '#2080f0',
    infoActive: '#1060c9',
    infoSuppl: '#4098fc',
    // error
    errorHover: '#de576d',
    errorDefault: '#d03050',
    errorActive: '#ab1f3f',
    errorSuppl: '#de576d',
    // warning
    warningHover: '#fcb040',
    warningDefault: '#f0a020',
    warningActive: '#c97c10',
    warningSuppl: '#fcb040',
    // success
    successHover: '#36ad6a',
    successDefault: '#18a058',
    successActive: '#0c7a43',
    successSuppl: '#36ad6a'
};
const baseBackgroundRgb = rgba(base.neutralBase);
const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
const overlayPrefix = 'rgba(' + baseInvertBackgroundRgb.slice(0, 3).join(', ') + ', ';
function light_overlay(alpha) {
    return overlayPrefix + String(alpha) + ')';
}
function neutral(alpha) {
    const overlayRgba = Array.from(baseInvertBackgroundRgb);
    overlayRgba[3] = Number(alpha);
    return composite(baseBackgroundRgb, overlayRgba);
}
const derived = Object.assign(Object.assign({ name: 'common' }, _common), { baseColor: base.neutralBase, 
    // primary color
    primaryColor: base.primaryDefault, primaryColorHover: base.primaryHover, primaryColorPressed: base.primaryActive, primaryColorSuppl: base.primarySuppl, 
    // info color
    infoColor: base.infoDefault, infoColorHover: base.infoHover, infoColorPressed: base.infoActive, infoColorSuppl: base.infoSuppl, 
    // success color
    successColor: base.successDefault, successColorHover: base.successHover, successColorPressed: base.successActive, successColorSuppl: base.successSuppl, 
    // warning color
    warningColor: base.warningDefault, warningColorHover: base.warningHover, warningColorPressed: base.warningActive, warningColorSuppl: base.warningSuppl, 
    // error color
    errorColor: base.errorDefault, errorColorHover: base.errorHover, errorColorPressed: base.errorActive, errorColorSuppl: base.errorSuppl, 
    // text color
    textColorBase: base.neutralTextBase, textColor1: 'rgb(31, 34, 37)', textColor2: 'rgb(51, 54, 57)', textColor3: 'rgb(118, 124, 130)', 
    // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
    // textColor5: neutral(base.alpha5),
    textColorDisabled: neutral(base.alpha4), placeholderColor: neutral(base.alpha4), placeholderColorDisabled: neutral(base.alpha5), iconColor: neutral(base.alpha4), iconColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }), iconColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }), iconColorDisabled: neutral(base.alpha5), opacity1: base.alpha1, opacity2: base.alpha2, opacity3: base.alpha3, opacity4: base.alpha4, opacity5: base.alpha5, dividerColor: 'rgb(239, 239, 245)', borderColor: 'rgb(224, 224, 230)', 
    // close
    closeColor: neutral(Number(base.alphaClose)), closeColorHover: neutral(Number(base.alphaClose) * 1.25), closeColorPressed: neutral(Number(base.alphaClose) * 0.8), closeColorDisabled: neutral(base.alpha4), 
    // clear
    clearColor: neutral(base.alpha4), clearColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }), clearColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }), scrollbarColor: light_overlay(base.alphaScrollbar), scrollbarColorHover: light_overlay(base.alphaScrollbarHover), scrollbarWidth: '5px', scrollbarHeight: '5px', scrollbarBorderRadius: '5px', progressRailColor: neutral(base.alphaProgressRail), railColor: 'rgb(219, 219, 223)', popoverColor: base.neutralPopover, tableColor: base.neutralCard, cardColor: base.neutralCard, modalColor: base.neutralModal, bodyColor: base.neutralBody, tagColor: 'rgb(250, 250, 252)', avatarColor: neutral(base.alphaAvatar), invertedColor: 'rgb(0, 20, 40)', inputColor: neutral(base.alphaInput), codeColor: 'rgb(244, 244, 248)', tabColor: 'rgb(247, 247, 250)', actionColor: 'rgb(250, 250, 252)', tableHeaderColor: 'rgb(250, 250, 252)', hoverColor: 'rgb(243, 243, 245)', 
    // use color with alpha since it can be nested with header filter & sorter effect
    tableColorHover: 'rgba(0, 0, 100, 0.02)', pressedColor: 'rgb(237, 237, 239)', opacityDisabled: base.alphaDisabled, inputColorDisabled: 'rgb(250, 250, 252)', 
    // secondary button color
    // can also be used in tertiary button & quaternary button
    buttonColor2: 'rgba(46, 51, 56, .05)', buttonColor2Hover: 'rgba(46, 51, 56, .09)', buttonColor2Pressed: 'rgba(46, 51, 56, .13)', boxShadow1: '0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)', boxShadow2: '0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)', boxShadow3: '0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)' });
/* harmony default export */ var light = (derived);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/card/styles/_common.js
/* harmony default export */ var styles_common = ({
    paddingSmall: '12px 16px 12px',
    paddingMedium: '19px 24px 20px',
    paddingLarge: '23px 32px 24px',
    paddingHuge: '27px 40px 28px',
    titleFontSizeSmall: '16px',
    titleFontSizeMedium: '18px',
    titleFontSizeLarge: '18px',
    titleFontSizeHuge: '18px',
    closeSize: '18px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/card/styles/light.js


const light_self = (vars) => {
    const { primaryColor, borderRadius, lineHeight, fontSize, cardColor, textColor2, textColor1, dividerColor, fontWeightStrong, closeColor, closeColorHover, closeColorPressed, modalColor, boxShadow1, popoverColor, actionColor } = vars;
    return Object.assign(Object.assign({}, styles_common), { lineHeight, color: cardColor, colorModal: modalColor, colorPopover: popoverColor, colorTarget: primaryColor, colorEmbedded: actionColor, textColor: textColor2, titleTextColor: textColor1, borderColor: dividerColor, actionColor: actionColor, titleFontWeight: fontWeightStrong, closeColor: closeColor, closeColorHover: closeColorHover, closeColorPressed: closeColorPressed, fontSizeSmall: fontSize, fontSizeMedium: fontSize, fontSizeLarge: fontSize, fontSizeHuge: fontSize, boxShadow: boxShadow1, borderRadius });
};
const cardLight = {
    name: 'Card',
    common: light,
    self: light_self
};
/* harmony default export */ var styles_light = (cardLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/card/src/styles/index.cssr.js
 // vars:
// --bezier
// --border-radius
// --color
// --color-modal
// --color-popover
// --text-color
// --line-height
// --padding-top
// --padding-bottom
// --padding-left
// --font-size
// --action-color
// --title-font-weight
// --title-font-size
// --title-text-color
// --close-color
// --close-color-hover
// --close-color-pressed
// --border-color
// --close-size
// --box-shadow

/* harmony default export */ var card_src_styles_index_cssr = (cssr_c([cB('card', `
 font-size: var(--font-size);
 line-height: var(--line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--border-radius);
 background-color: var(--color);
 color: var(--text-color);
 transition: 
 color .3s var(--bezier),
 background-color .3s var(--bezier),
 box-shadow .3s var(--bezier),
 border-color .3s var(--bezier);
 `, [cM('hoverable', [cssr_c('&:hover', 'box-shadow: var(--box-shadow);')]), cM('content-segmented', [cssr_c('>', [cE('content', {
  paddingTop: 'var(--padding-bottom)'
})])]), cM('content-soft-segmented', [cssr_c('>', [cE('content', `
 margin: 0 var(--padding-left);
 padding: var(--padding-bottom) 0;
 `)])]), cM('footer-segmented', [cssr_c('>', [cE('footer', {
  paddingTop: 'var(--padding-bottom)'
})])]), cM('footer-soft-segmented', [cssr_c('>', [cE('footer', `
 padding: var(--padding-bottom) 0;
 margin: 0 var(--padding-left);
 `)])]), cssr_c('>', [cB('card-header', `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--title-font-size);
 padding:
 var(--padding-top)
 var(--padding-left)
 var(--padding-bottom)
 var(--padding-left);
 `, [cE('main', `
 font-weight: var(--title-font-weight);
 transition: color .3s var(--bezier);
 flex: 1;
 color: var(--title-text-color);
 `), cE('extra', `
 display: flex;
 align-items: center;
 font-size: var(--font-size);
 font-weight: 400;
 transition: color .3s var(--bezier);
 color: var(--text-color);
 `), cE('close', `
 font-size: var(--close-size);
 transition: color .3s var(--bezier);
 `)]), cE('action', `
 box-sizing: border-box;
 transition:
 background-color .3s var(--bezier),
 border-color .3s var(--bezier);
 background-clip: padding-box;
 background-color: var(--action-color);
 `), cE('content', 'flex: 1;'), cE('content, footer', `
 box-sizing: border-box;
 padding: 0 var(--padding-left) var(--padding-bottom) var(--padding-left);
 font-size: var(--font-size);
 `, [cssr_c('&:first-child', {
  paddingTop: 'var(--padding-bottom)'
})]), cE('action', `
 background-color: var(--action-color);
 padding: var(--padding-bottom) var(--padding-left);
 `)]), cB('card-cover', `
 overflow: hidden;
 width: 100%;
 border-radius: var(--border-radius) var(--border-radius) 0 0;
 `, [cssr_c('img', `
 display: block;
 width: 100%;
 `)]), cM('bordered', `
 border: 1px solid var(--border-color);
 `, [cssr_c('&:target', 'border-color: var(--color-target);')]), cM('action-segmented', [cssr_c('>', [cE('action', [cssr_c('&:not(:first-child)', {
  borderTop: '1px solid var(--border-color)'
})])])]), cM('content-segmented, content-soft-segmented', [cssr_c('>', [cE('content', {
  transition: 'border-color 0.3s var(--bezier)'
}, [cssr_c('&:not(:first-child)', {
  borderTop: '1px solid var(--border-color)'
})])])]), cM('footer-segmented, footer-soft-segmented', [cssr_c('>', [cE('footer', {
  transition: 'border-color 0.3s var(--bezier)'
}, [cssr_c('&:not(:first-child)', {
  borderTop: '1px solid var(--border-color)'
})])])])]), insideModal(cB('card', {
  background: 'var(--color-modal)'
})), insidePopover(cB('card', {
  background: 'var(--color-popover)'
})), cB('card', [asModal({
  background: 'var(--color-modal)'
})])]));
// CONCATENATED MODULE: ./node_modules/css-render/esm/exists.js

function exists(id, ssr) {
    if (id === undefined)
        return false;
    if (ssr) {
        const { context: { ids } } = ssr;
        return ids.has(id);
    }
    return queryElement(id) !== null;
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_mixins/use-rtl.js



function useRtl(mountId, rtlStateRef, clsPrefixRef) {
    if (!rtlStateRef)
        return undefined;
    const ssrAdapter = useSsrAdapter();
    const componentRtlStateRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { value: rtlState } = rtlStateRef;
        if (!rtlState) {
            return undefined;
        }
        const componentRtlState = rtlState[mountId];
        if (!componentRtlState) {
            return undefined;
        }
        return componentRtlState;
    });
    const mountStyle = () => {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(() => {
            const { value: clsPrefix } = clsPrefixRef;
            const id = `${clsPrefix}${mountId}Rtl`;
            // if it already exists, we only need to watch clsPrefix, although in most
            // of time it's unnecessary... However we can at least listen less
            // handlers, which is great.
            if (exists(id, ssrAdapter))
                return;
            const { value: componentRtlState } = componentRtlStateRef;
            if (!componentRtlState)
                return;
            componentRtlState.style.mount({
                id,
                head: true,
                props: {
                    bPrefix: clsPrefix ? `.${clsPrefix}-` : undefined
                },
                ssr: ssrAdapter
            });
        });
    };
    if (ssrAdapter) {
        mountStyle();
    }
    else {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(mountStyle);
    }
    return componentRtlStateRef;
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/card/src/Card.js








const cardBaseProps = {
    title: String,
    contentStyle: [Object, String],
    headerStyle: [Object, String],
    footerStyle: [Object, String],
    embedded: Boolean,
    segmented: {
        type: [Boolean, Object],
        default: false
    },
    size: {
        type: String,
        default: 'medium'
    },
    bordered: {
        type: Boolean,
        default: true
    },
    closable: {
        type: Boolean,
        default: false
    },
    hoverable: Boolean,
    onClose: [Function, Array]
};
const cardBasePropKeys = keysOf(cardBaseProps);
const cardProps = Object.assign(Object.assign({}, use_theme.props), cardBaseProps);
/* harmony default export */ var Card = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Card',
    props: cardProps,
    setup(props) {
        const handleCloseClick = () => {
            const { onClose } = props;
            if (onClose)
                call(onClose);
        };
        const { mergedClsPrefixRef, NConfigProvider } = useConfig(props);
        const themeRef = use_theme('Card', 'Card', card_src_styles_index_cssr, styles_light, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl('Card', NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef, mergedClsPrefixRef);
        return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
            handleCloseClick,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { size } = props;
                const { self: { color, colorModal, colorTarget, textColor, titleTextColor, titleFontWeight, borderColor, actionColor, borderRadius, closeColor, closeColorHover, closeColorPressed, lineHeight, closeSize, boxShadow, colorPopover, colorEmbedded, [createKey('padding', size)]: padding, [createKey('fontSize', size)]: fontSize, [createKey('titleFontSize', size)]: titleFontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;
                const { top: paddingTop, left: paddingLeft, bottom: paddingBottom } = getMargin(padding);
                return {
                    '--bezier': cubicBezierEaseInOut,
                    '--border-radius': borderRadius,
                    '--color': props.embedded ? colorEmbedded : color,
                    '--color-modal': colorModal,
                    '--color-popover': colorPopover,
                    '--color-target': colorTarget,
                    '--text-color': textColor,
                    '--line-height': lineHeight,
                    '--action-color': actionColor,
                    '--title-text-color': titleTextColor,
                    '--title-font-weight': titleFontWeight,
                    '--close-color': closeColor,
                    '--close-color-hover': closeColorHover,
                    '--close-color-pressed': closeColorPressed,
                    '--border-color': borderColor,
                    '--box-shadow': boxShadow,
                    // size
                    '--padding-top': paddingTop,
                    '--padding-bottom': paddingBottom,
                    '--padding-left': paddingLeft,
                    '--font-size': fontSize,
                    '--title-font-size': titleFontSize,
                    '--close-size': closeSize
                };
            })
        };
    },
    render() {
        const { segmented, bordered, hoverable, mergedClsPrefix, rtlEnabled, $slots } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                `${mergedClsPrefix}-card`,
                {
                    [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
                    [`${mergedClsPrefix}-card--content${typeof segmented !== 'boolean' && segmented.content === 'soft'
                        ? '-soft'
                        : ''}-segmented`]: segmented === true || (segmented !== false && segmented.content),
                    [`${mergedClsPrefix}-card--footer${typeof segmented !== 'boolean' && segmented.footer === 'soft'
                        ? '-soft'
                        : ''}-segmented`]: segmented === true || (segmented !== false && segmented.footer),
                    [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || (segmented !== false && segmented.action),
                    [`${mergedClsPrefix}-card--bordered`]: bordered,
                    [`${mergedClsPrefix}-card--hoverable`]: hoverable
                }
            ], style: this.cssVars },
            $slots.cover ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card-cover`, role: "none" }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'cover'))) : null,
            $slots.header || this.title || this.closable ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card-header`, style: this.headerStyle },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card-header__main`, role: "heading" }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'header', {}, () => [this.title])),
                $slots['header-extra'] ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card-header__extra` }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'header-extra'))) : null,
                this.closable ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Close, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-card-header__close`, onClick: this.handleCloseClick })) : null)) : null,
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card__content`, style: this.contentStyle, role: "none" }, $slots),
            $slots.footer ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card__footer`, style: this.footerStyle, role: "none" }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'footer'))) : null,
            $slots.action ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-card__action`, role: "none" }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'action'))) : null));
    }
}));

// CONCATENATED MODULE: ./node_modules/vooks/es/use-merged-state.js

function useMergedState(controlledStateRef, uncontrolledStateRef) {
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(controlledStateRef, value => {
        if (value !== undefined) {
            uncontrolledStateRef.value = value;
        }
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        if (controlledStateRef.value === undefined) {
            return uncontrolledStateRef.value;
        }
        return controlledStateRef.value;
    });
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_mixins/use-form-item.js

const formItemInjectionKey = Symbol('formItem');
function useFormItem(props, { defaultSize = 'medium', mergedSize, mergedDisabled } = {}) {
    const NFormItem = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(formItemInjectionKey, null);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(formItemInjectionKey, null);
    const mergedSizeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(mergedSize
        ? () => mergedSize(NFormItem)
        : () => {
            const { size } = props;
            if (size)
                return size;
            if (NFormItem) {
                const { mergedSize } = NFormItem;
                if (mergedSize.value !== undefined) {
                    return mergedSize.value;
                }
            }
            return defaultSize;
        });
    const mergedDisabledRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(mergedDisabled
        ? () => mergedDisabled(NFormItem)
        : () => {
            const { disabled } = props;
            if (disabled !== undefined) {
                return disabled;
            }
            if (NFormItem) {
                return NFormItem.disabled.value;
            }
            return false;
        });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
        if (NFormItem) {
            NFormItem.restoreValidation();
        }
    });
    return {
        mergedSizeRef,
        mergedDisabledRef,
        nTriggerFormBlur() {
            if (NFormItem) {
                NFormItem.handleContentBlur();
            }
        },
        nTriggerFormChange() {
            if (NFormItem) {
                NFormItem.handleContentChange();
            }
        },
        nTriggerFormFocus() {
            if (NFormItem) {
                NFormItem.handleContentFocus();
            }
        },
        nTriggerFormInput() {
            if (NFormItem) {
                NFormItem.handleContentInput();
            }
        }
    };
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/src/CheckboxGroup.js




const checkboxGroupInjectionKey = Symbol('checkboxGroup');
const checkboxGroupProps = {
    min: Number,
    max: Number,
    size: String,
    value: Array,
    defaultValue: {
        type: Array,
        default: null
    },
    disabled: {
        type: Boolean,
        default: undefined
    },
    'onUpdate:value': [Function, Array],
    onUpdateValue: [Function, Array],
    // deprecated
    onChange: {
        type: [Function, Array],
        validator: () => {
            if (false) {}
            return true;
        },
        default: undefined
    }
};
/* harmony default export */ var CheckboxGroup = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'CheckboxGroup',
    props: checkboxGroupProps,
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const uncontrolledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultValue);
        const controlledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => props.value);
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const checkedCount = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            var _a;
            return ((_a = mergedValueRef.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
        });
        const valueSetRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            if (Array.isArray(mergedValueRef.value)) {
                return new Set(mergedValueRef.value);
            }
            return new Set();
        });
        function toggleCheckbox(checked, checkboxValue) {
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            const { onChange, 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
            if (Array.isArray(mergedValueRef.value)) {
                const groupValue = Array.from(mergedValueRef.value);
                const index = groupValue.findIndex((value) => value === checkboxValue);
                if (checked) {
                    if (!~index) {
                        groupValue.push(checkboxValue);
                        if (onUpdateValue)
                            call(onUpdateValue, groupValue);
                        if (_onUpdateValue)
                            call(_onUpdateValue, groupValue);
                        nTriggerFormInput();
                        nTriggerFormChange();
                        uncontrolledValueRef.value = groupValue;
                        // deprecated
                        if (onChange)
                            call(onChange, groupValue);
                    }
                }
                else {
                    if (~index) {
                        groupValue.splice(index, 1);
                        if (onUpdateValue)
                            call(onUpdateValue, groupValue);
                        if (_onUpdateValue)
                            call(_onUpdateValue, groupValue);
                        if (onChange)
                            call(onChange, groupValue); // deprecated
                        uncontrolledValueRef.value = groupValue;
                        nTriggerFormInput();
                        nTriggerFormChange();
                    }
                }
            }
            else {
                if (checked) {
                    if (onUpdateValue)
                        call(onUpdateValue, [checkboxValue]);
                    if (_onUpdateValue)
                        call(_onUpdateValue, [checkboxValue]);
                    if (onChange)
                        call(onChange, [checkboxValue]); // deprecated
                    uncontrolledValueRef.value = [checkboxValue];
                    nTriggerFormInput();
                    nTriggerFormChange();
                }
                else {
                    if (onUpdateValue)
                        call(onUpdateValue, []);
                    if (_onUpdateValue)
                        call(_onUpdateValue, []);
                    if (onChange)
                        call(onChange, []); // deprecated
                    uncontrolledValueRef.value = [];
                    nTriggerFormInput();
                    nTriggerFormChange();
                }
            }
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(checkboxGroupInjectionKey, {
            checkedCountRef: checkedCount,
            maxRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'max'),
            minRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'min'),
            valueSetRef: valueSetRef,
            disabledRef: mergedDisabledRef,
            mergedSizeRef: mergedSizeRef,
            toggleCheckbox
        });
        return {
            mergedClsPrefix: mergedClsPrefixRef
        };
    },
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${this.mergedClsPrefix}-checkbox-group`, role: "group" }, this.$slots));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/flatten.js

// o(n) flatten
function flatten(vNodes, filterCommentNode = true, result = []) {
    vNodes.forEach((vNode) => {
        if (vNode === null)
            return;
        if (typeof vNode !== 'object') {
            if (typeof vNode === 'string' || typeof vNode === 'number') {
                result.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(String(vNode)));
            }
            return;
        }
        if (Array.isArray(vNode)) {
            flatten(vNode, filterCommentNode, result);
            return;
        }
        if (vNode.type === external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"]) {
            if (vNode.children === null)
                return;
            if (Array.isArray(vNode.children)) {
                flatten(vNode.children, filterCommentNode, result);
            }
            // rawSlot
        }
        else if (vNode.type !== external_commonjs_vue_commonjs2_vue_root_Vue_["Comment"]) {
            result.push(vNode);
        }
    });
    return result;
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/get-slot.js
function getSlot(instance, slotName = 'default', fallback = []) {
    const slots = instance.$slots;
    const slot = slots[slotName];
    if (slot === undefined)
        return fallback;
    return slot();
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/space/styles/_common.js
/* harmony default export */ var space_styles_common = ({
    gapSmall: '4px 8px',
    gapMedium: '8px 12px',
    gapLarge: '12px 16px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/space/styles/light.js

const styles_light_self = () => {
    return space_styles_common;
};
const spaceLight = {
    name: 'Space',
    self: styles_light_self
};
/* harmony default export */ var space_styles_light = (spaceLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/space/src/Space.js





const spaceProps = Object.assign(Object.assign({}, use_theme.props), { align: String, justify: {
        type: String,
        default: 'start'
    }, inline: Boolean, vertical: Boolean, size: {
        type: [String, Number, Array],
        default: 'medium'
    }, itemStyle: [String, Object], wrap: {
        type: Boolean,
        default: true
    } });
/* harmony default export */ var Space = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Space',
    props: spaceProps,
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = use_theme('Space', 'Space', undefined, space_styles_light, props, mergedClsPrefixRef);
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            margin: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { size } = props;
                if (Array.isArray(size)) {
                    return {
                        horizontal: size[0],
                        vertical: size[1]
                    };
                }
                if (typeof size === 'number') {
                    return {
                        horizontal: size,
                        vertical: size
                    };
                }
                const { self: { [createKey('gap', size)]: gap } } = themeRef.value;
                const { row, col } = getGap(gap);
                return {
                    horizontal: depx(col),
                    vertical: depx(row)
                };
            })
        };
    },
    render() {
        const { vertical, align, inline, justify, itemStyle, margin, wrap, mergedClsPrefix } = this;
        const children = flatten(getSlot(this));
        if (!children.length)
            return null;
        const horizontalMargin = `${margin.horizontal}px`;
        const semiHorizontalMargin = `${margin.horizontal / 2}px`;
        const verticalMargin = `${margin.vertical}px`;
        const semiVerticalMargin = `${margin.vertical / 2}px`;
        const lastIndex = children.length - 1;
        const isJustifySpace = justify.startsWith('space-');
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { role: "none", class: `${mergedClsPrefix}-space`, style: {
                display: inline ? 'inline-flex' : 'flex',
                flexDirection: vertical ? 'column' : 'row',
                justifyContent: ['start', 'end'].includes(justify)
                    ? 'flex-' + justify
                    : justify,
                flexWrap: !wrap || vertical ? 'nowrap' : 'wrap',
                marginTop: vertical ? '' : `-${semiVerticalMargin}`,
                marginBottom: vertical ? '' : `-${semiVerticalMargin}`,
                alignItems: align
            } }, children.map((child, index) => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { role: "none", style: [
                itemStyle,
                {
                    maxWidth: '100%'
                },
                vertical
                    ? {
                        marginBottom: index !== lastIndex ? verticalMargin : ''
                    }
                    : {
                        marginRight: isJustifySpace
                            ? justify === 'space-between' && index === lastIndex
                                ? ''
                                : semiHorizontalMargin
                            : index !== lastIndex
                                ? horizontalMargin
                                : '',
                        marginLeft: isJustifySpace
                            ? justify === 'space-between' && index === 0
                                ? ''
                                : semiHorizontalMargin
                            : '',
                        paddingTop: semiVerticalMargin,
                        paddingBottom: semiVerticalMargin
                    }
            ] }, child)))));
    }
}));

// CONCATENATED MODULE: ./node_modules/seemly/es/misc/index.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createId(length = 8) {
    return Math.random()
        .toString(16)
        .slice(2, 2 + length);
}
function repeat(count, v) {
    const ret = [];
    for (let i = 0; i < count; ++i) {
        ret.push(v);
    }
    return ret;
}
function indexMap(count, createValue) {
    const ret = [];
    if (!createValue) {
        for (let i = 0; i < count; ++i) {
            ret.push(i);
        }
        return ret;
    }
    for (let i = 0; i < count; ++i) {
        ret.push(createValue(i));
    }
    return ret;
}

function sleep(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    });
}

// CONCATENATED MODULE: ./node_modules/vooks/es/life-cycle/use-is-mounted.js

function use_is_mounted_isMounted() {
    const isMounted = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => { isMounted.value = true; });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(isMounted);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icon-switch-transition/src/IconSwitchTransition.js


/* harmony default export */ var IconSwitchTransition = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'BaseIconSwitchTransition',
    setup(_, { slots }) {
        const isMountedRef = use_is_mounted_isMounted();
        return () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "icon-switch-transition", appear: isMountedRef.value }, slots));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/styles/_common.js
/* harmony default export */ var checkbox_styles_common = ({
    sizeSmall: '14px',
    sizeMedium: '16px',
    sizeLarge: '18px',
    labelPadding: '0 8px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/styles/light.js



const checkbox_styles_light_self = (vars) => {
    const { baseColor, inputColorDisabled, cardColor, modalColor, popoverColor, textColorDisabled, borderColor, primaryColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, borderRadiusSmall } = vars;
    return Object.assign(Object.assign({}, checkbox_styles_common), { fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge, borderRadius: borderRadiusSmall, color: baseColor, colorChecked: primaryColor, colorDisabled: inputColorDisabled, colorDisabledChecked: inputColorDisabled, colorTableHeader: cardColor, colorTableHeaderModal: modalColor, colorTableHeaderPopover: popoverColor, checkMarkColor: baseColor, checkMarkColorDisabled: textColorDisabled, checkMarkColorDisabledChecked: textColorDisabled, border: `1px solid ${borderColor}`, borderDisabled: `1px solid ${borderColor}`, borderDisabledChecked: `1px solid ${borderColor}`, borderChecked: `1px solid ${primaryColor}`, borderFocus: `1px solid ${primaryColor}`, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`, textColor: textColor2, textColorDisabled: textColorDisabled });
};
const checkboxLight = {
    name: 'Checkbox',
    common: light,
    self: checkbox_styles_light_self
};
/* harmony default export */ var checkbox_styles_light = (checkboxLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/src/CheckMark.js

/* harmony default export */ var CheckMark = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 64 64", class: "check-icon" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/src/LineMark.js

/* harmony default export */ var LineMark = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 100 100", class: "line-icon" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/transitions/icon-switch.cssr.js


const {
  cubicBezierEaseInOut: icon_switch_cssr_cubicBezierEaseInOut,
  transformDebounceScale
} = _common;
/* harmony default export */ var icon_switch_cssr = (function ({
  originalTransform = '',
  left = 0,
  top = 0,
  transition = `all .3s ${icon_switch_cssr_cubicBezierEaseInOut} !important`
} = {}) {
  return [cssr_c('&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to', {
    transform: originalTransform + ' scale(0.75)',
    left,
    top,
    opacity: 0
  }), cssr_c('&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from', {
    transform: `${transformDebounceScale} ${originalTransform}`,
    left,
    top,
    opacity: 1
  }), cssr_c('&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active', {
    transformOrigin: 'center',
    position: 'absolute',
    left,
    top,
    transition
  })];
});
// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/src/styles/index.cssr.js

 // vars:
// --bezier
// --size
// --border
// --border-focus
// --border-checked
// --border-disabled
// --border-disabled-checked
// --box-shadow-focus
// --color
// --color-checked
// --color-table-header
// --color-table-header-modal
// --color-disabled
// --color-disabled-checked
// --text-color
// --text-color-disabled
// --check-mark-color
// --check-mark-color-disabled
// --check-mark-color-disabled-checked
// --border-radius
// --font-size
// --label-padding

/* harmony default export */ var checkbox_src_styles_index_cssr = (cssr_c([cB('checkbox', `
 line-height: 1;
 font-size: var(--font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 align-items: center;
 white-space: nowrap;
 vertical-align: middle;
 --merged-color-table-header: var(--color-table-header);
 `, [cssr_c('&:hover', [cB('checkbox-box', [cE('border', {
  border: 'var(--border-checked)'
})])]), cssr_c('&:focus:not(:active)', [cB('checkbox-box', [cE('border', {
  border: 'var(--border-focus)',
  boxShadow: 'var(--box-shadow-focus)'
})])]), cM('table-header', [cB('checkbox-box', {
  backgroundColor: 'var(--merged-color-table-header)'
})]), cM('checked', [cB('checkbox-box', {
  backgroundColor: 'var(--color-checked)'
}, [cB('checkbox-icon', [// if not set width to 100%, safari & old chrome won't display the icon
cssr_c('.check-icon', `
 width: 100%;
 opacity: 1;
 transform: scale(1);
 `)])])]), cM('indeterminate', [cB('checkbox-box', [cB('checkbox-icon', [cssr_c('.check-icon', `
 opacity: 0;
 transform: scale(.5);
 `), cssr_c('.line-icon', `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM('checked, indeterminate', [cssr_c('&:focus:not(:active)', [cB('checkbox-box', [cE('border', {
  border: 'var(--border-checked)',
  boxShadow: 'var(--box-shadow-focus)'
})])]), cB('checkbox-box', `
 background-color: var(--color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE('border', {
  border: 'var(--border-checked)'
})])]), cM('disabled', {
  cursor: 'not-allowed'
}, [cM('checked', [cB('checkbox-box', `
 background-color: var(--color-disabled-checked);
 `, [cE('border', {
  border: 'var(--border-disabled-checked)'
}), cB('checkbox-icon', [cssr_c('.check-icon, .line-icon', {
  fill: 'var(--check-mark-color-disabled-checked)'
})])])]), cB('checkbox-box', `
 background-color: var(--color-disabled);
 `, [cE('border', {
  border: 'var(--border-disabled)'
}), cB('checkbox-icon', [cssr_c('.check-icon, .line-icon', {
  fill: 'var(--check-mark-color-disabled)'
})])]), cE('label', {
  color: 'var(--text-color-disabled)'
})]), cB('checkbox-box', `
 height: var(--size);
 width: var(--size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--border-radius);
 background-color: var(--color);
 position: relative;
 transition:
 background-color 0.3s var(--bezier);
 `, [cE('border', `
 transition:
 border-color .3s var(--bezier),
 box-shadow .3s var(--bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--border);
 `), cB('checkbox-icon', `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [cssr_c('.check-icon, .line-icon', `
 fill: var(--check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--bezier),
 transform 0.3s var(--bezier),
 opacity 0.3s var(--bezier),
 border-color 0.3s var(--bezier);
 `), icon_switch_cssr({
  left: '1px',
  top: '1px'
})])]), cE('label', `
 color: var(--text-color);
 transition: color .3s var(--bezier);
 user-select: none;
 padding: var(--label-padding);
 `, [cssr_c('&:empty', {
  display: 'none'
})])]), // modal table header checkbox
insideModal(cB('checkbox', `
 --merged-color-table-header: var(--color-table-header-modal);
 `)), // popover table header checkbox
insidePopover(cB('checkbox', `
 --merged-color-table-header: var(--color-table-header-popover);
 `))]));
// CONCATENATED MODULE: ./node_modules/evtd/es/traps.js

const traps = {
    mousemoveoutside: new WeakMap(),
    clickoutside: new WeakMap()
};
function createTrapHandler(name, el, originalHandler) {
    if (name === 'mousemoveoutside') {
        const moveHandler = (e) => {
            if (el.contains(e.target))
                return;
            originalHandler(e);
        };
        return {
            mousemove: moveHandler,
            touchstart: moveHandler
        };
    }
    else if (name === 'clickoutside') {
        let mouseDownOutside = false;
        const downHandler = (e) => {
            mouseDownOutside = !el.contains(e.target);
        };
        const upHanlder = (e) => {
            if (!mouseDownOutside)
                return;
            if (el.contains(e.target))
                return;
            originalHandler(e);
        };
        return {
            mousedown: downHandler,
            mouseup: upHanlder,
            touchstart: downHandler,
            touchend: upHanlder
        };
    }
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    console.error(`[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`);
    return {};
}
function ensureTrapHandlers(name, el, handler) {
    const handlers = traps[name];
    let elHandlers = handlers.get(el);
    if (elHandlers === undefined) {
        handlers.set(el, elHandlers = new WeakMap());
    }
    let trapHandler = elHandlers.get(handler);
    if (trapHandler === undefined) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
    }
    return trapHandler;
}
function trapOn(name, el, handler, options) {
    if (name === 'mousemoveoutside' ||
        name === 'clickoutside') {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach(key => {
            delegate_on(key, document, trapHandlers[key], options);
        });
        return true;
    }
    return false;
}
function trapOff(name, el, handler, options) {
    if (name === 'mousemoveoutside' ||
        name === 'clickoutside') {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach(key => {
            delegate_off(key, document, trapHandlers[key], options);
        });
        return true;
    }
    return false;
}


// CONCATENATED MODULE: ./node_modules/evtd/es/delegate.js

// currently `once` and `passive` is not supported
function createDelegate() {
    if (typeof window === 'undefined') {
        return {
            on: () => { },
            off: () => { }
        };
    }
    const propagationStopped = new WeakMap();
    const immediatePropagationStopped = new WeakMap();
    function trackPropagation() {
        propagationStopped.set(this, true);
    }
    function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
    }
    function spy(event, propName, fn) {
        const source = event[propName];
        event[propName] = function () {
            fn.apply(event, arguments);
            return source.apply(event, arguments);
        };
        return event;
    }
    function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
    }
    const currentTargets = new WeakMap();
    const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');
    function getCurrentTarget() {
        var _a;
        return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
    }
    function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === undefined)
            return;
        Object.defineProperty(event, 'currentTarget', {
            configurable: true,
            enumerable: true,
            get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
    }
    const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
    };
    const typeToWindowEventHandlers = {};
    function createUnifiedHandler() {
        const delegeteHandler = function (e) {
            const { type, eventPhase, target, bubbles } = e;
            if (eventPhase === 2)
                return;
            const phase = eventPhase === 1 ? 'capture' : 'bubble';
            let cursor = target;
            const path = [];
            // collecting bubble path
            while (true) {
                if (cursor === null)
                    cursor = window;
                path.push(cursor);
                if (cursor === window) {
                    break;
                }
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                cursor = (cursor.parentNode || null);
            }
            const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
            const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
            spy(e, 'stopPropagation', trackPropagation);
            spy(e, 'stopImmediatePropagation', trackImmediate);
            defineCurrentTarget(e, getCurrentTarget);
            if (phase === 'capture') {
                if (captureElToHandlers === undefined)
                    return;
                // capture
                for (let i = path.length - 1; i >= 0; --i) {
                    if (propagationStopped.has(e))
                        break;
                    const target = path[i];
                    const handlers = captureElToHandlers.get(target);
                    if (handlers !== undefined) {
                        currentTargets.set(e, target);
                        for (const handler of handlers) {
                            if (immediatePropagationStopped.has(e))
                                break;
                            handler(e);
                        }
                    }
                    if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {
                        const bubbleHandlers = bubbleElToHandlers.get(target);
                        if (bubbleHandlers !== undefined) {
                            for (const handler of bubbleHandlers) {
                                if (immediatePropagationStopped.has(e))
                                    break;
                                handler(e);
                            }
                        }
                    }
                }
            }
            else if (phase === 'bubble') {
                if (bubbleElToHandlers === undefined)
                    return;
                // bubble
                for (let i = 0; i < path.length; ++i) {
                    if (propagationStopped.has(e))
                        break;
                    const target = path[i];
                    const handlers = bubbleElToHandlers.get(target);
                    if (handlers !== undefined) {
                        currentTargets.set(e, target);
                        for (const handler of handlers) {
                            if (immediatePropagationStopped.has(e))
                                break;
                            handler(e);
                        }
                    }
                }
            }
            unspy(e, 'stopPropagation');
            unspy(e, 'stopImmediatePropagation');
            defineCurrentTarget(e);
        };
        delegeteHandler.displayName = 'evtdUnifiedHandler';
        return delegeteHandler;
    }
    function createUnifiedWindowEventHandler() {
        const delegateHandler = function (e) {
            const { type, eventPhase } = e;
            if (eventPhase !== 2)
                return;
            const handlers = typeToWindowEventHandlers[type];
            if (handlers === undefined)
                return;
            handlers.forEach((handler) => handler(e));
        };
        delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';
        return delegateHandler;
    }
    const unifiedHandler = createUnifiedHandler();
    const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
    function ensureElToHandlers(phase, type) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];
        if (phaseHandlers[type] === undefined) {
            phaseHandlers[type] = new Map();
            window.addEventListener(type, unifiedHandler, phase === 'capture');
        }
        return phaseHandlers[type];
    }
    function ensureWindowEventHandlers(type) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        if (windowEventHandlers === undefined) {
            typeToWindowEventHandlers[type] = new Set();
            window.addEventListener(type, unfiendWindowEventHandler);
        }
        return typeToWindowEventHandlers[type];
    }
    function ensureHandlers(elToHandlers, el) {
        let elHandlers = elToHandlers.get(el);
        if (elHandlers === undefined) {
            elToHandlers.set(el, (elHandlers = new Set()));
        }
        return elHandlers;
    }
    function handlerExist(el, phase, type, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type];
        // phase ${type} event has handlers
        if (elToHandlers !== undefined) {
            const handlers = elToHandlers.get(el);
            // phase using el with ${type} event has handlers
            if (handlers !== undefined) {
                if (handlers.has(handler))
                    return true;
            }
        }
        return false;
    }
    function windowEventHandlerExist(type, handler) {
        const handlers = typeToWindowEventHandlers[type];
        if (handlers !== undefined) {
            if (handlers.has(handler)) {
                return true;
            }
        }
        return false;
    }
    function on(type, el, handler, options) {
        let mergedHandler;
        if (typeof options === 'object' && options.once === true) {
            mergedHandler = (e) => {
                off(type, el, mergedHandler, options);
                handler(e);
            };
        }
        else {
            mergedHandler = handler;
        }
        const trapped = trapOn(type, el, mergedHandler, options);
        if (trapped)
            return;
        const phase = options === true ||
            (typeof options === 'object' && options.capture === true)
            ? 'capture'
            : 'bubble';
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el);
        if (!handlers.has(mergedHandler))
            handlers.add(mergedHandler);
        if (el === window) {
            const windowEventHandlers = ensureWindowEventHandlers(type);
            if (!windowEventHandlers.has(mergedHandler)) {
                windowEventHandlers.add(mergedHandler);
            }
        }
    }
    function off(type, el, handler, options) {
        const trapped = trapOff(type, el, handler, options);
        if (trapped)
            return;
        const capture = options === true ||
            (typeof options === 'object' && options.capture === true);
        const phase = capture ? 'capture' : 'bubble';
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el);
        if (el === window) {
            const mirrorPhase = capture ? 'bubble' : 'capture';
            if (!handlerExist(el, mirrorPhase, type, handler) &&
                windowEventHandlerExist(type, handler)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const windowEventHandlers = typeToWindowEventHandlers[type];
                windowEventHandlers.delete(handler);
                if (windowEventHandlers.size === 0) {
                    window.removeEventListener(type, unfiendWindowEventHandler);
                    typeToWindowEventHandlers[type] = undefined;
                }
            }
        }
        if (handlers.has(handler))
            handlers.delete(handler);
        if (handlers.size === 0) {
            elToHandlers.delete(el);
        }
        if (elToHandlers.size === 0) {
            window.removeEventListener(type, unifiedHandler, phase === 'capture');
            phaseToTypeToElToHandlers[phase][type] = undefined;
        }
    }
    return {
        on: on,
        off: off
    };
}
const { on: delegate_on, off: delegate_off } = createDelegate();


// CONCATENATED MODULE: ./node_modules/naive-ui/es/checkbox/src/Checkbox.js












const checkboxProps = Object.assign(Object.assign({}, use_theme.props), { size: String, checked: {
        type: [Boolean, String, Number],
        default: undefined
    }, defaultChecked: {
        type: [Boolean, String, Number],
        default: false
    }, value: [String, Number], disabled: {
        type: Boolean,
        default: undefined
    }, indeterminate: Boolean, label: String, focusable: {
        type: Boolean,
        default: true
    }, checkedValue: {
        type: [Boolean, String, Number],
        default: true
    }, uncheckedValue: {
        type: [Boolean, String, Number],
        default: false
    }, 'onUpdate:checked': [Function, Array], onUpdateChecked: [Function, Array], 
    // private
    privateInsideTable: Boolean, 
    // deprecated
    onChange: [Function, Array] });
/* harmony default export */ var Checkbox = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Checkbox',
    props: checkboxProps,
    setup(props) {
        if (false) {}
        const { mergedClsPrefixRef } = useConfig(props);
        const formItem = useFormItem(props, {
            mergedSize(NFormItem) {
                const { size } = props;
                if (size !== undefined)
                    return size;
                if (NCheckboxGroup) {
                    const { value: mergedSize } = NCheckboxGroup.mergedSizeRef;
                    if (mergedSize !== undefined) {
                        return mergedSize;
                    }
                }
                if (NFormItem) {
                    const { mergedSize } = NFormItem;
                    if (mergedSize !== undefined)
                        return mergedSize.value;
                }
                return 'medium';
            },
            mergedDisabled(NFormItem) {
                const { disabled } = props;
                if (disabled !== undefined)
                    return disabled;
                if (NCheckboxGroup) {
                    if (NCheckboxGroup.disabledRef.value)
                        return true;
                    const { maxRef: { value: max }, checkedCountRef } = NCheckboxGroup;
                    if (max !== undefined &&
                        checkedCountRef.value >= max &&
                        !renderedCheckedRef.value) {
                        return true;
                    }
                    const { minRef: { value: min } } = NCheckboxGroup;
                    if (min !== undefined &&
                        checkedCountRef.value <= min &&
                        renderedCheckedRef.value) {
                        return true;
                    }
                }
                if (NFormItem) {
                    return NFormItem.disabled.value;
                }
                return false;
            }
        });
        const { mergedDisabledRef, mergedSizeRef } = formItem;
        const NCheckboxGroup = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(checkboxGroupInjectionKey, null);
        const uncontrolledCheckedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultChecked);
        const controlledCheckedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'checked');
        const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
        const renderedCheckedRef = use_memo(() => {
            if (NCheckboxGroup) {
                const groupValueSet = NCheckboxGroup.valueSetRef.value;
                if (groupValueSet && props.value !== undefined) {
                    return groupValueSet.has(props.value);
                }
                return false;
            }
            else {
                return mergedCheckedRef.value === props.checkedValue;
            }
        });
        const themeRef = use_theme('Checkbox', 'Checkbox', checkbox_src_styles_index_cssr, checkbox_styles_light, props, mergedClsPrefixRef);
        function toggle(e) {
            if (NCheckboxGroup && props.value !== undefined) {
                NCheckboxGroup.toggleCheckbox(!renderedCheckedRef.value, props.value);
            }
            else {
                const { onChange, 'onUpdate:checked': _onUpdateCheck, onUpdateChecked } = props;
                const { nTriggerFormInput, nTriggerFormChange } = formItem;
                const nextChecked = renderedCheckedRef.value
                    ? props.uncheckedValue
                    : props.checkedValue;
                if (_onUpdateCheck) {
                    call(_onUpdateCheck, nextChecked, e);
                }
                if (onUpdateChecked) {
                    call(onUpdateChecked, nextChecked, e);
                }
                if (onChange)
                    call(onChange, nextChecked, e); // deprecated
                nTriggerFormInput();
                nTriggerFormChange();
                uncontrolledCheckedRef.value = nextChecked;
            }
        }
        function handleClick(e) {
            if (!mergedDisabledRef.value) {
                toggle(e);
            }
        }
        function handleKeyUp(e) {
            if (mergedDisabledRef.value)
                return;
            switch (e.code) {
                case 'Space':
                case 'Enter':
                case 'NumpadEnter':
                    toggle(e);
            }
        }
        function handleKeyDown(e) {
            switch (e.code) {
                case 'Space':
                    e.preventDefault();
            }
        }
        return Object.assign(formItem, {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedDisabled: mergedDisabledRef,
            renderedChecked: renderedCheckedRef,
            mergedTheme: themeRef,
            labelId: createId(),
            handleClick,
            handleKeyUp,
            handleKeyDown,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { value: mergedSize } = mergedSizeRef;
                const { common: { cubicBezierEaseInOut }, self: { borderRadius, color, colorChecked, colorDisabled, colorTableHeader, colorTableHeaderModal, colorTableHeaderPopover, checkMarkColor, checkMarkColorDisabled, border, borderFocus, borderDisabled, borderChecked, boxShadowFocus, textColor, textColorDisabled, checkMarkColorDisabledChecked, colorDisabledChecked, borderDisabledChecked, labelPadding, [createKey('fontSize', mergedSize)]: fontSize, [createKey('size', mergedSize)]: size } } = themeRef.value;
                return {
                    '--size': size,
                    '--bezier': cubicBezierEaseInOut,
                    '--border-radius': borderRadius,
                    '--border': border,
                    '--border-checked': borderChecked,
                    '--border-focus': borderFocus,
                    '--border-disabled': borderDisabled,
                    '--border-disabled-checked': borderDisabledChecked,
                    '--box-shadow-focus': boxShadowFocus,
                    '--color': color,
                    '--color-checked': colorChecked,
                    '--color-table-header': colorTableHeader,
                    '--color-table-header-modal': colorTableHeaderModal,
                    '--color-table-header-popover': colorTableHeaderPopover,
                    '--color-disabled': colorDisabled,
                    '--color-disabled-checked': colorDisabledChecked,
                    '--text-color': textColor,
                    '--text-color-disabled': textColorDisabled,
                    '--check-mark-color': checkMarkColor,
                    '--check-mark-color-disabled': checkMarkColorDisabled,
                    '--check-mark-color-disabled-checked': checkMarkColorDisabledChecked,
                    '--font-size': fontSize,
                    '--label-padding': labelPadding
                };
            })
        });
    },
    render() {
        const { $slots, renderedChecked, mergedDisabled, indeterminate, privateInsideTable, cssVars, labelId, label, mergedClsPrefix, focusable, handleKeyUp, handleKeyDown, handleClick } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                `${mergedClsPrefix}-checkbox`,
                renderedChecked && `${mergedClsPrefix}-checkbox--checked`,
                mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`,
                indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`,
                privateInsideTable && `${mergedClsPrefix}-checkbox--table-header`
            ], tabindex: mergedDisabled || !focusable ? undefined : 0, role: "checkbox", "aria-checked": indeterminate ? 'mixed' : renderedChecked, "aria-labelledby": labelId, style: cssVars, onKeyup: handleKeyUp, onKeydown: handleKeyDown, onClick: handleClick, onMousedown: () => {
                delegate_on('selectstart', window, (e) => {
                    e.preventDefault();
                }, {
                    once: true
                });
            } },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-checkbox-box` },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(IconSwitchTransition, null, {
                    default: () => this.indeterminate ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "indeterminate", class: `${mergedClsPrefix}-checkbox-icon` }, LineMark)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "check", class: `${mergedClsPrefix}-checkbox-icon` }, CheckMark))
                }),
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-checkbox-box__border` })),
            label !== null || $slots.default ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", { class: `${mergedClsPrefix}-checkbox__label`, id: labelId }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'default', undefined, () => [label]))) : null));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/css/format-length.js
const pureNumberRegex = /^(\d|\.)+$/;
const numberRegex = /(\d|\.)+/;
function formatLength(length, { c = 1, offset = 0, attachPx = true } = {}) {
    if (typeof length === 'number') {
        const result = (length + offset) * c;
        if (result === 0)
            return '0';
        return `${result}px`;
    }
    else if (typeof length === 'string') {
        if (pureNumberRegex.test(length)) {
            const result = (Number(length) + offset) * c;
            if (attachPx) {
                if (result === 0)
                    return '0';
                return `${result}px`;
            }
            else {
                return `${result}`;
            }
        }
        else {
            const result = numberRegex.exec(length);
            if (!result)
                return length;
            return length.replace(numberRegex, String((Number(result[0]) + offset) * c));
        }
    }
    return length;
}
/* harmony default export */ var format_length = (formatLength);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/icon/styles/light.js

const icon_styles_light_self = (vars) => {
    const { textColorBase, opacity1, opacity2, opacity3, opacity4, opacity5 } = vars;
    return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
    };
};
const iconLight = {
    name: 'Icon',
    common: light,
    self: icon_styles_light_self
};
/* harmony default export */ var icon_styles_light = (iconLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/icon/src/styles/index.cssr.js
 // vars:
// --bezier
// --color
// --opacity

/* harmony default export */ var icon_src_styles_index_cssr = (cB('icon', `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM('color-transition', {
  transition: 'color .3s var(--bezier)'
}), cM('depth', {
  color: 'var(--color)'
}, [cssr_c('svg', {
  opacity: 'var(--opacity)',
  transition: 'opacity .3s var(--bezier)'
})]), cssr_c('svg', {
  height: '1em',
  width: '1em'
})]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/icon/src/Icon.js





/* harmony default export */ var src_Icon = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    _n_icon__: true,
    name: 'Icon',
    inheritAttrs: false,
    props: Object.assign(Object.assign({}, use_theme.props), { depth: [String, Number], size: [Number, String], color: String }),
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = use_theme('Icon', 'Icon', icon_src_styles_index_cssr, icon_styles_light, props, mergedClsPrefixRef);
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedStyle: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { size, color } = props;
                return {
                    fontSize: format_length(size),
                    color
                };
            }),
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { depth } = props;
                const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
                if (depth !== undefined) {
                    const { color, [`opacity${depth}Depth`]: opacity } = self;
                    return {
                        '--bezier': cubicBezierEaseInOut,
                        '--color': color,
                        '--opacity': opacity
                    };
                }
                return {
                    '--bezier': cubicBezierEaseInOut
                };
            })
        };
    },
    render() {
        var _a;
        const { $parent, depth, mergedClsPrefix } = this;
        if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
            warn('icon', "don't wrap `n-icon` inside `n-icon`");
        }
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])('i', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["mergeProps"])(this.$attrs, {
            role: 'img',
            class: [
                `${mergedClsPrefix}-icon`,
                {
                    [`${mergedClsPrefix}-icon--depth`]: depth,
                    [`${mergedClsPrefix}-icon--color-transition`]: depth !== undefined
                }
            ],
            style: Object.assign(this.cssVars, this.mergedStyle)
        }), this.$slots);
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/color/index.js

function createHoverColor(rgb) {
    return composite(rgb, [255, 255, 255, 0.16]);
}
function createPressedColor(rgb) {
    return composite(rgb, [0, 0, 0, 0.12]);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/fade-in-expand-transition/src/FadeInExpandTransition.js

/* harmony default export */ var FadeInExpandTransition = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'FadeInExpandTransition',
    props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        // reverse mode is only used in tree
        // it make it from expanded to collapsed after mounted
        reverse: Boolean
    },
    setup(props, { slots }) {
        function handleBeforeLeave(el) {
            if (props.width) {
                el.style.maxWidth = `${el.offsetWidth}px`;
            }
            else {
                el.style.maxHeight = `${el.offsetHeight}px`;
            }
            void el.offsetWidth;
        }
        function handleLeave(el) {
            if (props.width) {
                el.style.maxWidth = '0';
            }
            else {
                el.style.maxHeight = '0';
            }
            void el.offsetWidth;
            const { onLeave } = props;
            if (onLeave)
                onLeave();
        }
        function handleAfterLeave(el) {
            if (props.width) {
                el.style.maxWidth = '';
            }
            else {
                el.style.maxHeight = '';
            }
            const { onAfterLeave } = props;
            if (onAfterLeave)
                onAfterLeave();
        }
        function handleEnter(el) {
            el.style.transition = 'none';
            if (props.width) {
                const memorizedWidth = el.offsetWidth;
                el.style.maxWidth = '0';
                void el.offsetWidth;
                el.style.transition = '';
                el.style.maxWidth = `${memorizedWidth}px`;
            }
            else {
                if (props.reverse) {
                    el.style.maxHeight = `${el.offsetHeight}px`;
                    void el.offsetHeight;
                    el.style.transition = '';
                    el.style.maxHeight = '0';
                }
                else {
                    const memorizedHeight = el.offsetHeight;
                    el.style.maxHeight = '0';
                    void el.offsetWidth;
                    el.style.transition = '';
                    el.style.maxHeight = `${memorizedHeight}px`;
                }
            }
            void el.offsetWidth;
        }
        function handleAfterEnter(el) {
            var _a;
            if (props.width) {
                el.style.maxWidth = '';
            }
            else {
                if (!props.reverse) {
                    el.style.maxHeight = '';
                }
            }
            (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
        }
        return () => {
            const type = props.group ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"];
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(type, {
                name: props.width
                    ? 'fade-in-width-expand-transition'
                    : 'fade-in-height-expand-transition',
                mode: props.mode,
                appear: props.appear,
                onEnter: handleEnter,
                onAfterEnter: handleAfterEnter,
                onBeforeLeave: handleBeforeLeave,
                onLeave: handleLeave,
                onAfterLeave: handleAfterLeave
            }, slots);
        };
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/loading/src/styles/index.cssr.js


/* harmony default export */ var loading_src_styles_index_cssr = (cB('base-loading', `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
`, [cE('placeholder', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [icon_switch_cssr({
  left: '50%',
  top: '50%',
  originalTransform: 'translateX(-50%) translateY(-50%)'
})]), cE('icon', `
 height: 1em;
 width: 1em;
 `, [icon_switch_cssr()])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/loading/src/Loading.js




const Loading_duration = '1.6s';
// The loading svg dom comes from https://codepen.io/FezVrasta/pen/oXrgdR
/* harmony default export */ var Loading = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'BaseLoading',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        scale: {
            type: Number,
            default: 1
        },
        radius: {
            type: Number,
            default: 100
        },
        strokeWidth: {
            type: Number,
            default: 28
        },
        stroke: {
            type: String,
            default: undefined
        },
        show: {
            type: Boolean,
            default: true
        }
    },
    setup(props) {
        useStyle('BaseLoading', loading_src_styles_index_cssr, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'clsPrefix'));
    },
    render() {
        const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
        const scaledRadius = radius / scale;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${clsPrefix}-base-loading`, role: "img", "aria-label": "loading" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(IconSwitchTransition, null, {
                default: () => this.show ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { class: `${clsPrefix}-base-loading__icon`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", null,
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("animateTransform", { attributeName: "transform", type: "rotate", values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`, begin: "0s", dur: Loading_duration, fill: "freeze", repeatCount: "indefinite" }),
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 5.67 * radius, "stroke-dashoffset": 18.48 * radius },
                            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("animateTransform", { attributeName: "transform", type: "rotate", values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`, begin: "0s", dur: Loading_duration, fill: "freeze", repeatCount: "indefinite" }),
                            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("animate", { attributeName: "stroke-dashoffset", values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`, begin: "0s", dur: Loading_duration, fill: "freeze", repeatCount: "indefinite" }))))) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "placeholder", class: `${clsPrefix}-base-loading__placeholder` }, this.$slots))
            })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/wave/src/styles/index.cssr.js

/* harmony default export */ var wave_src_styles_index_cssr = (cB('base-wave', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/wave/src/Wave.js



/* harmony default export */ var Wave = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'BaseWave',
    props: {
        clsPrefix: {
            type: String,
            required: true
        }
    },
    setup(props) {
        useStyle('BaseWave', wave_src_styles_index_cssr, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'clsPrefix'));
        const selfRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const activeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        let animationTimerId = null;
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            if (animationTimerId !== null) {
                window.clearTimeout(animationTimerId);
            }
        });
        return {
            active: activeRef,
            selfRef,
            play() {
                if (animationTimerId !== null) {
                    window.clearTimeout(animationTimerId);
                    activeRef.value = false;
                    animationTimerId = null;
                }
                void Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(() => {
                    var _a;
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
                    activeRef.value = true;
                    animationTimerId = window.setTimeout(() => {
                        activeRef.value = false;
                        animationTimerId = null;
                    }, 1000);
                });
            }
        };
    },
    render() {
        const { clsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "selfRef", "aria-hidden": true, class: [
                `${clsPrefix}-base-wave`,
                this.active && `${clsPrefix}-base-wave--active`
            ] }));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/button/styles/_common.js
/* harmony default export */ var button_styles_common = ({
    paddingTiny: '0 6px',
    paddingSmall: '0 10px',
    paddingMedium: '0 14px',
    paddingLarge: '0 18px',
    paddingRoundTiny: '0 10px',
    paddingRoundSmall: '0 14px',
    paddingRoundMedium: '0 18px',
    paddingRoundLarge: '0 22px',
    iconMarginTiny: '6px',
    iconMarginSmall: '6px',
    iconMarginMedium: '6px',
    iconMarginLarge: '6px',
    iconSizeTiny: '14px',
    iconSizeSmall: '18px',
    iconSizeMedium: '18px',
    iconSizeLarge: '20px',
    rippleDuration: '.6s'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/button/styles/light.js


const button_styles_light_self = (vars) => {
    const { heightTiny, heightSmall, heightMedium, heightLarge, borderRadius, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, opacityDisabled, textColor2, textColor3, primaryColorHover, primaryColorPressed, borderColor, primaryColor, baseColor, infoColor, infoColorHover, infoColorPressed, successColor, successColorHover, successColorPressed, warningColor, warningColorHover, warningColorPressed, errorColor, errorColorHover, errorColorPressed, fontWeight, buttonColor2, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
    return Object.assign(Object.assign({}, button_styles_common), { heightTiny,
        heightSmall,
        heightMedium,
        heightLarge, borderRadiusTiny: borderRadius, borderRadiusSmall: borderRadius, borderRadiusMedium: borderRadius, borderRadiusLarge: borderRadius, fontSizeTiny: fontSizeTiny, fontSizeSmall: fontSizeSmall, fontSizeMedium: fontSizeMedium, fontSizeLarge: fontSizeLarge, opacityDisabled: opacityDisabled, 
        // secondary
        colorOpacitySecondary: 0.16, colorOpacitySecondaryHover: 0.2, colorOpacitySecondaryPressed: 0.24, colorSecondary: buttonColor2, colorSecondaryHover: buttonColor2Hover, colorSecondaryPressed: buttonColor2Pressed, 
        // tertiary
        colorTertiary: buttonColor2, colorTertiaryHover: buttonColor2Hover, colorTertiaryPressed: buttonColor2Pressed, 
        // quaternary
        colorQuaternary: '#0000', colorQuaternaryHover: buttonColor2Hover, colorQuaternaryPressed: buttonColor2Pressed, 
        // default type
        color: '#0000', colorHover: '#0000', colorPressed: '#0000', colorFocus: '#0000', colorDisabled: '#0000', textColor: textColor2, textColorTertiary: textColor3, textColorHover: primaryColorHover, textColorPressed: primaryColorPressed, textColorFocus: primaryColorHover, textColorDisabled: textColor2, textColorText: textColor2, textColorTextHover: primaryColorHover, textColorTextPressed: primaryColorPressed, textColorTextFocus: primaryColorHover, textColorTextDisabled: textColor2, textColorGhost: textColor2, textColorGhostHover: primaryColorHover, textColorGhostPressed: primaryColorPressed, textColorGhostFocus: primaryColorHover, textColorGhostDisabled: textColor2, border: `1px solid ${borderColor}`, borderHover: `1px solid ${primaryColorHover}`, borderPressed: `1px solid ${primaryColorPressed}`, borderFocus: `1px solid ${primaryColorHover}`, borderDisabled: `1px solid ${borderColor}`, rippleColor: primaryColor, 
        // primary
        colorPrimary: primaryColor, colorHoverPrimary: primaryColorHover, colorPressedPrimary: primaryColorPressed, colorFocusPrimary: primaryColorHover, colorDisabledPrimary: primaryColor, textColorPrimary: baseColor, textColorHoverPrimary: baseColor, textColorPressedPrimary: baseColor, textColorFocusPrimary: baseColor, textColorDisabledPrimary: baseColor, textColorTextPrimary: primaryColor, textColorTextHoverPrimary: primaryColorHover, textColorTextPressedPrimary: primaryColorPressed, textColorTextFocusPrimary: primaryColorHover, textColorTextDisabledPrimary: textColor2, textColorGhostPrimary: primaryColor, textColorGhostHoverPrimary: primaryColorHover, textColorGhostPressedPrimary: primaryColorPressed, textColorGhostFocusPrimary: primaryColorHover, textColorGhostDisabledPrimary: primaryColor, borderPrimary: `1px solid ${primaryColor}`, borderHoverPrimary: `1px solid ${primaryColorHover}`, borderPressedPrimary: `1px solid ${primaryColorPressed}`, borderFocusPrimary: `1px solid ${primaryColorHover}`, borderDisabledPrimary: `1px solid ${primaryColor}`, rippleColorPrimary: primaryColor, 
        // info
        colorInfo: infoColor, colorHoverInfo: infoColorHover, colorPressedInfo: infoColorPressed, colorFocusInfo: infoColorHover, colorDisabledInfo: infoColor, textColorInfo: baseColor, textColorHoverInfo: baseColor, textColorPressedInfo: baseColor, textColorFocusInfo: baseColor, textColorDisabledInfo: baseColor, textColorTextInfo: infoColor, textColorTextHoverInfo: infoColorHover, textColorTextPressedInfo: infoColorPressed, textColorTextFocusInfo: infoColorHover, textColorTextDisabledInfo: textColor2, textColorGhostInfo: infoColor, textColorGhostHoverInfo: infoColorHover, textColorGhostPressedInfo: infoColorPressed, textColorGhostFocusInfo: infoColorHover, textColorGhostDisabledInfo: infoColor, borderInfo: `1px solid ${infoColor}`, borderHoverInfo: `1px solid ${infoColorHover}`, borderPressedInfo: `1px solid ${infoColorPressed}`, borderFocusInfo: `1px solid ${infoColorHover}`, borderDisabledInfo: `1px solid ${infoColor}`, rippleColorInfo: infoColor, 
        // success
        colorSuccess: successColor, colorHoverSuccess: successColorHover, colorPressedSuccess: successColorPressed, colorFocusSuccess: successColorHover, colorDisabledSuccess: successColor, textColorSuccess: baseColor, textColorHoverSuccess: baseColor, textColorPressedSuccess: baseColor, textColorFocusSuccess: baseColor, textColorDisabledSuccess: baseColor, textColorTextSuccess: successColor, textColorTextHoverSuccess: successColorHover, textColorTextPressedSuccess: successColorPressed, textColorTextFocusSuccess: successColorHover, textColorTextDisabledSuccess: textColor2, textColorGhostSuccess: successColor, textColorGhostHoverSuccess: successColorHover, textColorGhostPressedSuccess: successColorPressed, textColorGhostFocusSuccess: successColorHover, textColorGhostDisabledSuccess: successColor, borderSuccess: `1px solid ${successColor}`, borderHoverSuccess: `1px solid ${successColorHover}`, borderPressedSuccess: `1px solid ${successColorPressed}`, borderFocusSuccess: `1px solid ${successColorHover}`, borderDisabledSuccess: `1px solid ${successColor}`, rippleColorSuccess: successColor, 
        // warning
        colorWarning: warningColor, colorHoverWarning: warningColorHover, colorPressedWarning: warningColorPressed, colorFocusWarning: warningColorHover, colorDisabledWarning: warningColor, textColorWarning: baseColor, textColorHoverWarning: baseColor, textColorPressedWarning: baseColor, textColorFocusWarning: baseColor, textColorDisabledWarning: baseColor, textColorTextWarning: warningColor, textColorTextHoverWarning: warningColorHover, textColorTextPressedWarning: warningColorPressed, textColorTextFocusWarning: warningColorHover, textColorTextDisabledWarning: textColor2, textColorGhostWarning: warningColor, textColorGhostHoverWarning: warningColorHover, textColorGhostPressedWarning: warningColorPressed, textColorGhostFocusWarning: warningColorHover, textColorGhostDisabledWarning: warningColor, borderWarning: `1px solid ${warningColor}`, borderHoverWarning: `1px solid ${warningColorHover}`, borderPressedWarning: `1px solid ${warningColorPressed}`, borderFocusWarning: `1px solid ${warningColorHover}`, borderDisabledWarning: `1px solid ${warningColor}`, rippleColorWarning: warningColor, 
        // error
        colorError: errorColor, colorHoverError: errorColorHover, colorPressedError: errorColorPressed, colorFocusError: errorColorHover, colorDisabledError: errorColor, textColorError: baseColor, textColorHoverError: baseColor, textColorPressedError: baseColor, textColorFocusError: baseColor, textColorDisabledError: baseColor, textColorTextError: errorColor, textColorTextHoverError: errorColorHover, textColorTextPressedError: errorColorPressed, textColorTextFocusError: errorColorHover, textColorTextDisabledError: textColor2, textColorGhostError: errorColor, textColorGhostHoverError: errorColorHover, textColorGhostPressedError: errorColorPressed, textColorGhostFocusError: errorColorHover, textColorGhostDisabledError: errorColor, borderError: `1px solid ${errorColor}`, borderHoverError: `1px solid ${errorColorHover}`, borderPressedError: `1px solid ${errorColorPressed}`, borderFocusError: `1px solid ${errorColorHover}`, borderDisabledError: `1px solid ${errorColor}`, rippleColorError: errorColor, waveOpacity: '0.6', fontWeight,
        fontWeightStrong });
};
const buttonLight = {
    name: 'Button',
    common: light,
    self: button_styles_light_self
};
/* harmony default export */ var button_styles_light = (buttonLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/button/src/styles/button-group.cssr.js

const zero = '0!important';
const n1 = '-1px!important';

function createLeftBorderStyle(type) {
  return cM(type + '-type', [cssr_c('& +', [cB('button', {}, [cM(type + '-type', [cE('border', {
    borderLeftWidth: zero
  }), cE('state-border', {
    left: n1
  })])])])]);
}

function createTopBorderStyle(type) {
  return cM(type + '-type', [cssr_c('& +', [cB('button', [cM(type + '-type', [cE('border', {
    borderTopWidth: zero
  }), cE('state-border', {
    top: n1
  })])])])]);
}

/* harmony default export */ var button_group_cssr = (cB('button-group', `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM('vertical', {
  flexDirection: 'row'
}, [cB('button', [cssr_c('&:first-child:not(:last-child)', `
 margin-right: ${zero};
 border-top-right-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), cssr_c('&:last-child:not(:first-child)', `
 margin-left: ${zero};
 border-top-left-radius: ${zero};
 border-bottom-left-radius: ${zero};
 `), cssr_c('&:not(:first-child):not(:last-child)', `
 margin-left: ${zero};
 margin-right: ${zero};
 border-radius: ${zero};
 `), createLeftBorderStyle('default'), cM('ghost', [createLeftBorderStyle('primary'), createLeftBorderStyle('info'), createLeftBorderStyle('success'), createLeftBorderStyle('warning'), createLeftBorderStyle('error')])])]), cM('vertical', {
  flexDirection: 'column'
}, [cB('button', [cssr_c('&:first-child:not(:last-child)', `
 margin-bottom: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-bottom-left-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), cssr_c('&:last-child:not(:first-child)', `
 margin-top: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-top-left-radius: ${zero};
 border-top-right-radius: ${zero};
 `), cssr_c('&:not(:first-child):not(:last-child)', `
 margin: ${zero};
 border-radius: ${zero};
 `), createTopBorderStyle('default'), cM('ghost', [createTopBorderStyle('primary'), createTopBorderStyle('info'), createTopBorderStyle('success'), createTopBorderStyle('warning'), createTopBorderStyle('error')])])])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/button/src/ButtonGroup.js



const buttonGroupInjectionKey = Symbol('button-group');
const buttonGroupProps = {
    size: {
        type: String,
        default: undefined
    },
    vertical: Boolean
};
/* harmony default export */ var ButtonGroup = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'ButtonGroup',
    props: buttonGroupProps,
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        useStyle('ButtonGroup', button_group_cssr, mergedClsPrefixRef);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(buttonGroupInjectionKey, props);
        return {
            mergedClsPrefix: mergedClsPrefixRef
        };
    },
    render() {
        const { mergedClsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                `${mergedClsPrefix}-button-group`,
                this.vertical && `${mergedClsPrefix}-button-group--vertical`
            ], role: "group" }, this.$slots));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/transitions/fade-in-width-expand.cssr.js


const {
  cubicBezierEaseInOut: fade_in_width_expand_cssr_cubicBezierEaseInOut
} = _common;
/* harmony default export */ var fade_in_width_expand_cssr = (function ({
  duration = '.2s',
  delay = '.1s'
} = {}) {
  return [cssr_c('&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to', {
    opacity: 1
  }), cssr_c('&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from', `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), cssr_c('&.fade-in-width-expand-transition-leave-active', `
 overflow: hidden;
 transition:
 opacity ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut},
 max-width ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut} ${delay},
 margin-left ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut} ${delay},
 margin-right ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut} ${delay};
 `), cssr_c('&.fade-in-width-expand-transition-enter-active', `
 overflow: hidden;
 transition:
 opacity ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut} ${delay},
 max-width ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut},
 margin-left ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut},
 margin-right ${duration} ${fade_in_width_expand_cssr_cubicBezierEaseInOut};
 `)];
});
// CONCATENATED MODULE: ./node_modules/naive-ui/es/button/src/styles/button.cssr.js


 // vars:
// --bezier
// --ripple-duration
// --opacity-disabled
// --text-color
// --text-color-hover
// --text-color-pressed
// --text-color-focus
// --text-color-disabled
// --color
// --color-hover
// --color-pressed
// --color-focus
// --color-disabled
// --border
// --border-hover
// --border-pressed
// --border-focus
// --border-disabled
// --ripple-color
// --border-radius
// --height
// --width
// --font-size
// --padding
// --icon-size
// --icon-margin
// --wave-opacity
// --font-weight
//
// private-vars:
// --border-color-xxx, used for custom color

/* harmony default export */ var button_cssr = (cssr_c([cB('button', `
 font-weight: var(--font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--padding);
 height: var(--height);
 font-size: var(--font-size);
 border-radius: var(--border-radius);
 color: var(--text-color);
 background-color: var(--color);
 width: var(--width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--bezier),
 background-color .3s var(--bezier),
 opacity .3s var(--bezier),
 border-color .3s var(--bezier);
 `, [cM('color', [cE('border', {
  borderColor: 'var(--border-color)'
}), cM('disabled', [cE('border', {
  borderColor: 'var(--border-color-disabled)'
})]), cNotM('disabled', [cssr_c('&:focus', [cE('state-border', {
  borderColor: 'var(--border-color-focus)'
})]), cssr_c('&:hover', [cE('state-border', {
  borderColor: 'var(--border-color-hover)'
})]), cssr_c('&:active', [cE('state-border', {
  borderColor: 'var(--border-color-pressed)'
})]), cM('pressed', [cE('state-border', {
  borderColor: 'var(--border-color-pressed)'
})])])]), cM('disabled', {
  backgroundColor: 'var(--color-disabled)',
  color: 'var(--text-color-disabled)'
}, [cE('border', {
  border: 'var(--border-disabled)'
})]), cNotM('disabled', [cssr_c('&:focus', {
  backgroundColor: 'var(--color-focus)',
  color: 'var(--text-color-focus)'
}, [cE('state-border', {
  border: 'var(--border-focus)'
})]), cssr_c('&:hover', {
  backgroundColor: 'var(--color-hover)',
  color: 'var(--text-color-hover)'
}, [cE('state-border', {
  border: 'var(--border-hover)'
})]), cssr_c('&:active', {
  backgroundColor: 'var(--color-pressed)',
  color: 'var(--text-color-pressed)'
}, [cE('state-border', {
  border: 'var(--border-pressed)'
})]), cM('pressed', {
  backgroundColor: 'var(--color-pressed)',
  color: 'var(--text-color-pressed)'
}, [cE('state-border', {
  border: 'var(--border-pressed)'
})])]), cB('base-wave', `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--ripple-duration);
 animation-timing-function: var(--bezier-ease-out), var(--bezier-ease-out);
 `, [cM('active', {
  zIndex: 1,
  animationName: 'button-wave-spread, button-wave-opacity'
})]), typeof window !== 'undefined' && 'MozBoxSizing' in document.createElement('div').style ? cssr_c('&::moz-focus-inner', {
  border: 0
}) : null, cE('border, state-border', `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--bezier);
 pointer-events: none;
 `), cE('border', {
  border: 'var(--border)'
}), cE('state-border', {
  border: 'var(--border)',
  borderColor: '#0000',
  zIndex: 1
}), cE('icon', `
 margin: var(--icon-margin);
 margin-left: 0;
 height: var(--icon-size);
 width: var(--icon-size);
 max-width: var(--icon-size);
 font-size: var(--icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB('icon-slot', `
 height: var(--icon-size);
 width: var(--icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 `, [icon_switch_cssr({
  top: '50%',
  originalTransform: 'translateY(-50%)'
})]), fade_in_width_expand_cssr()]), cE('content', `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 `, [cssr_c('~', [cE('icon', {
  margin: 'var(--icon-margin)',
  marginRight: 0
})])]), cM('block', `
 display: flex;
 width: 100%;
 `), cM('dashed', [cE('border, state-border', {
  borderStyle: 'dashed !important'
})]), cM('disabled', {
  cursor: 'not-allowed',
  opacity: 'var(--opacity-disabled)'
})]), cssr_c('@keyframes button-wave-spread', {
  from: {
    boxShadow: '0 0 0.5px 0 var(--ripple-color)'
  },
  to: {
    // don't use exact 5px since chrome will display the animation with glitches
    boxShadow: '0 0 0.5px 4.5px var(--ripple-color)'
  }
}), cssr_c('@keyframes button-wave-opacity', {
  from: {
    opacity: 'var(--wave-opacity)'
  },
  to: {
    opacity: 0
  }
})]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/button/src/Button.js











const buttonProps = Object.assign(Object.assign({}, use_theme.props), { color: String, textColor: String, text: Boolean, block: Boolean, loading: Boolean, disabled: Boolean, circle: Boolean, size: String, ghost: Boolean, round: Boolean, secondary: Boolean, tertiary: Boolean, quaternary: Boolean, strong: Boolean, focusable: {
        type: Boolean,
        default: true
    }, keyboard: {
        type: Boolean,
        default: true
    }, tag: {
        type: String,
        default: 'button'
    }, type: {
        type: String,
        default: 'default'
    }, dashed: Boolean, iconPlacement: {
        type: String,
        default: 'left'
    }, attrType: {
        type: String,
        default: 'button'
    }, onClick: [Function, Array], bordered: {
        type: Boolean,
        default: true
    } });
const Button = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Button',
    props: buttonProps,
    setup(props) {
        if (false) {}
        const selfRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const waveRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const enterPressedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        const showBorderRef = use_memo(() => {
            return (!props.quaternary &&
                !props.tertiary &&
                !props.secondary &&
                !props.text &&
                (!props.color || props.ghost || props.dashed) &&
                props.bordered);
        });
        const NButtonGroup = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(buttonGroupInjectionKey, {});
        const { mergedSizeRef } = useFormItem({}, {
            defaultSize: 'medium',
            mergedSize: (NFormItem) => {
                const { size } = props;
                if (size)
                    return size;
                const { size: buttonGroupSize } = NButtonGroup;
                if (buttonGroupSize)
                    return buttonGroupSize;
                const { mergedSize: formItemSize } = NFormItem || {};
                if (formItemSize) {
                    return formItemSize.value;
                }
                return 'medium';
            }
        });
        const mergedFocusableRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
            var _a;
            e.preventDefault();
            if (props.disabled) {
                return;
            }
            if (mergedFocusableRef.value) {
                (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            }
        };
        const handleClick = (e) => {
            if (!props.disabled) {
                const { onClick } = props;
                if (onClick)
                    call(onClick, e);
                if (!props.text) {
                    const { value } = waveRef;
                    if (value) {
                        value.play();
                    }
                }
            }
        };
        const handleKeyup = (e) => {
            switch (e.code) {
                case 'Enter':
                case 'NumpadEnter':
                    if (!props.keyboard) {
                        return;
                    }
                    enterPressedRef.value = false;
            }
        };
        const handleKeydown = (e) => {
            switch (e.code) {
                case 'Enter':
                case 'NumpadEnter':
                    if (!props.keyboard) {
                        e.preventDefault();
                        return;
                    }
                    enterPressedRef.value = true;
            }
        };
        const handleBlur = () => {
            enterPressedRef.value = false;
        };
        const { mergedClsPrefixRef, NConfigProvider } = useConfig(props);
        const themeRef = use_theme('Button', 'Button', button_cssr, button_styles_light, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl('Button', NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef, mergedClsPrefixRef);
        return {
            selfRef,
            waveRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedFocusable: mergedFocusableRef,
            mergedSize: mergedSizeRef,
            showBorder: showBorderRef,
            enterPressed: enterPressedRef,
            rtlEnabled: rtlEnabledRef,
            handleMousedown,
            handleKeydown,
            handleBlur,
            handleKeyup,
            handleClick,
            customColorCssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { color } = props;
                if (!color)
                    return null;
                const hoverColor = createHoverColor(color);
                return {
                    '--border-color': color,
                    '--border-color-hover': hoverColor,
                    '--border-color-pressed': createPressedColor(color),
                    '--border-color-focus': hoverColor,
                    '--border-color-disabled': color
                };
            }),
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const theme = themeRef.value;
                const { common: { cubicBezierEaseInOut, cubicBezierEaseOut }, self } = theme;
                const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self;
                const size = mergedSizeRef.value;
                const { dashed, type, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
                // font
                const fontProps = {
                    fontWeight: strong ? fontWeightStrong : fontWeight
                };
                // color
                let colorProps = {
                    '--color': 'initial',
                    '--color-hover': 'initial',
                    '--color-pressed': 'initial',
                    '--color-focus': 'initial',
                    '--color-disabled': 'initial',
                    '--ripple-color': 'initial',
                    '--text-color': 'initial',
                    '--text-color-hover': 'initial',
                    '--text-color-pressed': 'initial',
                    '--text-color-focus': 'initial',
                    '--text-color-disabled': 'initial'
                };
                const typeIsTertiary = type === 'tertiary';
                const typeIsDefault = type === 'default';
                const mergedType = typeIsTertiary ? 'default' : type;
                if (text) {
                    const propTextColor = textColor || color;
                    const mergedTextColor = propTextColor || self[createKey('textColorText', mergedType)];
                    colorProps = {
                        '--color': '#0000',
                        '--color-hover': '#0000',
                        '--color-pressed': '#0000',
                        '--color-focus': '#0000',
                        '--color-disabled': '#0000',
                        '--ripple-color': '#0000',
                        '--text-color': mergedTextColor,
                        '--text-color-hover': propTextColor
                            ? createHoverColor(propTextColor)
                            : self[createKey('textColorTextHover', mergedType)],
                        '--text-color-pressed': propTextColor
                            ? createPressedColor(propTextColor)
                            : self[createKey('textColorTextPressed', mergedType)],
                        '--text-color-focus': propTextColor
                            ? createHoverColor(propTextColor)
                            : self[createKey('textColorTextHover', mergedType)],
                        '--text-color-disabled': propTextColor ||
                            self[createKey('textColorTextDisabled', mergedType)]
                    };
                }
                else if (ghost || dashed) {
                    const mergedTextColor = textColor || color;
                    colorProps = {
                        '--color': '#0000',
                        '--color-hover': '#0000',
                        '--color-pressed': '#0000',
                        '--color-focus': '#0000',
                        '--color-disabled': '#0000',
                        '--ripple-color': color || self[createKey('rippleColor', mergedType)],
                        '--text-color': mergedTextColor || self[createKey('textColorGhost', mergedType)],
                        '--text-color-hover': mergedTextColor
                            ? createHoverColor(mergedTextColor)
                            : self[createKey('textColorGhostHover', mergedType)],
                        '--text-color-pressed': mergedTextColor
                            ? createPressedColor(mergedTextColor)
                            : self[createKey('textColorGhostPressed', mergedType)],
                        '--text-color-focus': mergedTextColor
                            ? createHoverColor(mergedTextColor)
                            : self[createKey('textColorGhostHover', mergedType)],
                        '--text-color-disabled': mergedTextColor ||
                            self[createKey('textColorGhostDisabled', mergedType)]
                    };
                }
                else if (secondary) {
                    const typeTextColor = typeIsDefault
                        ? self.textColor
                        : typeIsTertiary
                            ? self.textColorTertiary
                            : self[createKey('color', mergedType)];
                    const mergedTextColor = color || typeTextColor;
                    const isColoredType = type !== 'default' && type !== 'tertiary';
                    colorProps = {
                        '--color': isColoredType
                            ? changeColor(mergedTextColor, {
                                alpha: self.colorOpacitySecondary
                            })
                            : self.colorSecondary,
                        '--color-hover': isColoredType
                            ? changeColor(mergedTextColor, {
                                alpha: self.colorOpacitySecondaryHover
                            })
                            : self.colorSecondaryHover,
                        '--color-pressed': isColoredType
                            ? changeColor(mergedTextColor, {
                                alpha: self.colorOpacitySecondaryPressed
                            })
                            : self.colorSecondaryPressed,
                        '--color-focus': isColoredType
                            ? changeColor(mergedTextColor, {
                                alpha: self.colorOpacitySecondaryHover
                            })
                            : self.colorSecondaryHover,
                        '--color-disabled': self.colorSecondary,
                        '--ripple-color': '#0000',
                        '--text-color': mergedTextColor,
                        '--text-color-hover': mergedTextColor,
                        '--text-color-pressed': mergedTextColor,
                        '--text-color-focus': mergedTextColor,
                        '--text-color-disabled': mergedTextColor
                    };
                }
                else if (tertiary || quaternary) {
                    const typeColor = typeIsDefault
                        ? self.textColor
                        : typeIsTertiary
                            ? self.textColorTertiary
                            : self[createKey('color', mergedType)];
                    const mergedColor = color || typeColor;
                    if (tertiary) {
                        colorProps['--color'] = self.colorTertiary;
                        colorProps['--color-hover'] = self.colorTertiaryHover;
                        colorProps['--color-pressed'] = self.colorTertiaryPressed;
                        colorProps['--color-focus'] = self.colorSecondaryHover;
                        colorProps['--color-disabled'] = self.colorTertiary;
                    }
                    else {
                        colorProps['--color'] = self.colorQuaternary;
                        colorProps['--color-hover'] = self.colorQuaternaryHover;
                        colorProps['--color-pressed'] = self.colorQuaternaryPressed;
                        colorProps['--color-focus'] = self.colorQuaternaryHover;
                        colorProps['--color-disabled'] = self.colorQuaternary;
                    }
                    colorProps['--ripple-color'] = '#0000';
                    colorProps['--text-color'] = mergedColor;
                    colorProps['--text-color-hover'] = mergedColor;
                    colorProps['--text-color-pressed'] = mergedColor;
                    colorProps['--text-color-focus'] = mergedColor;
                    colorProps['--text-color-disabled'] = mergedColor;
                }
                else {
                    colorProps = {
                        '--color': color || self[createKey('color', mergedType)],
                        '--color-hover': color
                            ? createHoverColor(color)
                            : self[createKey('colorHover', mergedType)],
                        '--color-pressed': color
                            ? createPressedColor(color)
                            : self[createKey('colorPressed', mergedType)],
                        '--color-focus': color
                            ? createHoverColor(color)
                            : self[createKey('colorFocus', mergedType)],
                        '--color-disabled': color || self[createKey('colorDisabled', mergedType)],
                        '--ripple-color': color || self[createKey('rippleColor', mergedType)],
                        '--text-color': textColor ||
                            (color
                                ? self.textColorPrimary
                                : typeIsTertiary
                                    ? self.textColorTertiary
                                    : self[createKey('textColor', mergedType)]),
                        '--text-color-hover': textColor ||
                            (color
                                ? self.textColorHoverPrimary
                                : self[createKey('textColorHover', mergedType)]),
                        '--text-color-pressed': textColor ||
                            (color
                                ? self.textColorPressedPrimary
                                : self[createKey('textColorPressed', mergedType)]),
                        '--text-color-focus': textColor ||
                            (color
                                ? self.textColorFocusPrimary
                                : self[createKey('textColorFocus', mergedType)]),
                        '--text-color-disabled': textColor ||
                            (color
                                ? self.textColorDisabledPrimary
                                : self[createKey('textColorDisabled', mergedType)])
                    };
                }
                // border
                let borderProps = {
                    '--border': 'initial',
                    '--border-hover': 'initial',
                    '--border-pressed': 'initial',
                    '--border-focus': 'initial',
                    '--border-disabled': 'initial'
                };
                if (text) {
                    borderProps = {
                        '--border': 'none',
                        '--border-hover': 'none',
                        '--border-pressed': 'none',
                        '--border-focus': 'none',
                        '--border-disabled': 'none'
                    };
                }
                else {
                    borderProps = {
                        '--border': self[createKey('border', mergedType)],
                        '--border-hover': self[createKey('borderHover', mergedType)],
                        '--border-pressed': self[createKey('borderPressed', mergedType)],
                        '--border-focus': self[createKey('borderFocus', mergedType)],
                        '--border-disabled': self[createKey('borderDisabled', mergedType)]
                    };
                }
                // size
                const { [createKey('height', size)]: height, [createKey('fontSize', size)]: fontSize, [createKey('padding', size)]: padding, [createKey('paddingRound', size)]: paddingRound, [createKey('iconSize', size)]: iconSize, [createKey('borderRadius', size)]: borderRadius, [createKey('iconMargin', size)]: iconMargin, waveOpacity } = self;
                const sizeProps = {
                    '--width': circle && !text ? height : 'initial',
                    '--height': text ? 'initial' : height,
                    '--font-size': fontSize,
                    '--padding': circle
                        ? 'initial'
                        : text
                            ? 'initial'
                            : round
                                ? paddingRound
                                : padding,
                    '--icon-size': iconSize,
                    '--icon-margin': iconMargin,
                    '--border-radius': text
                        ? 'initial'
                        : circle || round
                            ? height
                            : borderRadius
                };
                return Object.assign(Object.assign(Object.assign(Object.assign({ '--bezier': cubicBezierEaseInOut, '--bezier-ease-out': cubicBezierEaseOut, '--ripple-duration': rippleDuration, '--opacity-disabled': opacityDisabled, '--wave-opacity': waveOpacity }, fontProps), colorProps), borderProps), sizeProps);
            })
        };
    },
    render() {
        const { $slots, mergedClsPrefix, tag: Component } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Component, { ref: "selfRef", class: [
                `${mergedClsPrefix}-button`,
                `${mergedClsPrefix}-button--${this.type}-type`,
                `${mergedClsPrefix}-button--${this.mergedSize}-type`,
                this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
                this.disabled && `${mergedClsPrefix}-button--disabled`,
                this.block && `${mergedClsPrefix}-button--block`,
                this.enterPressed && `${mergedClsPrefix}-button--pressed`,
                !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
                this.color && `${mergedClsPrefix}-button--color`,
                this.secondary && `${mergedClsPrefix}-button--secondary`,
                this.ghost && `${mergedClsPrefix}-button--ghost` // required for button group border collapse
            ], tabindex: this.mergedFocusable ? 0 : -1, type: this.attrType, style: this.cssVars, disabled: this.disabled, onClick: this.handleClick, onBlur: this.handleBlur, onMousedown: this.handleMousedown, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
            $slots.default && this.iconPlacement === 'right' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-button__content` }, $slots)) : null,
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(FadeInExpandTransition, { width: true }, {
                default: () => $slots.icon || this.loading ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", { class: `${mergedClsPrefix}-button__icon`, style: {
                        margin: !$slots.default ? 0 : ''
                    } },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(IconSwitchTransition, null, {
                        default: () => this.loading ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Loading, { clsPrefix: mergedClsPrefix, key: "loading", class: `${mergedClsPrefix}-icon-slot`, strokeWidth: 20 })) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "icon", class: `${mergedClsPrefix}-icon-slot`, role: "none" }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'icon')))
                    }))) : null
            }),
            $slots.default && this.iconPlacement === 'left' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", { class: `${mergedClsPrefix}-button__content` }, $slots)) : null,
            !this.text ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Wave, { ref: "waveRef", clsPrefix: mergedClsPrefix })) : null,
            this.showBorder ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__border`, style: this.customColorCssVars })) : null,
            this.showBorder ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__state-border`, style: this.customColorCssVars })) : null));
    }
});
/* harmony default export */ var src_Button = (Button);
// XButton is for tsx type checking
// It's not compitable with render function `h`
// Currently we don't expose it as public
// If there's any issue about this, we may expose it
// Since most people use template, the type checking phase doesn't work as tsx
const XButton = Button;
// Also, we may make XButton a generic type which support `tag` prop
// but currently vue doesn't export IntrinsicElementAttributes from runtime-dom
// so we can't easily make an attr map by hand
// just leave it for later

// CONCATENATED MODULE: ./node_modules/seemly/es/animation/next-frame-once.js
let onceCbs = [];
const paramsMap = new WeakMap();
function flushOnceCallbacks() {
    onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
    onceCbs = [];
}
function beforeNextFrameOnce(cb, ...params) {
    paramsMap.set(cb, params);
    if (onceCbs.includes(cb))
        return;
    onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
}


// CONCATENATED MODULE: ./node_modules/vueuc/es/shared/v-node.js
function v_node_getSlot(slots, slotName = 'default') {
    const slot = slots[slotName];
    if (slot === undefined) {
        throw new Error(`[vueuc/binder]: slot[${slotName}] is empty.`);
    }
    return slot();
}
function getFirstVNode(slots, slotName = 'default') {
    const slot = slots[slotName];
    if (slot === undefined) {
        throw new Error(`[vueuc/binder]: slot[${slotName}] is empty.`);
    }
    const content = slot();
    // vue will normalize the slot, so slot must be an array
    if (content.length === 1) {
        return content[0];
    }
    else {
        throw new Error(`[vueuc/binder]: slot[${slotName}] should have exactly one child.`);
    }
}

// CONCATENATED MODULE: ./node_modules/vueuc/es/binder/src/utils.js
let viewMeasurer = null;
function ensureViewBoundingRect() {
    if (viewMeasurer === null) {
        viewMeasurer = document.getElementById('v-binder-view-measurer');
        if (viewMeasurer === null) {
            viewMeasurer = document.createElement('div');
            viewMeasurer.id = 'v-binder-view-measurer';
            const { style } = viewMeasurer;
            style.position = 'fixed';
            style.left = '0';
            style.right = '0';
            style.top = '0';
            style.bottom = '0';
            style.pointerEvents = 'none';
            style.visibility = 'hidden';
            document.body.appendChild(viewMeasurer);
        }
    }
    return viewMeasurer.getBoundingClientRect();
}
function getPointRect(x, y) {
    const viewRect = ensureViewBoundingRect();
    return {
        top: y,
        left: x,
        height: 0,
        width: 0,
        right: viewRect.width - x,
        bottom: viewRect.height - y
    };
}
function getRect(el) {
    const elRect = el.getBoundingClientRect();
    const viewRect = ensureViewBoundingRect();
    return {
        left: elRect.left - viewRect.left,
        top: elRect.top - viewRect.top,
        bottom: viewRect.height + viewRect.top - elRect.bottom,
        right: viewRect.width + viewRect.left - elRect.right,
        width: elRect.width,
        height: elRect.height
    };
}
function getParentNode(node) {
    // document type
    if (node.nodeType === 9) {
        return null;
    }
    return node.parentNode;
}
function getScrollParent(node) {
    if (node === null)
        return null;
    const parentNode = getParentNode(node);
    if (parentNode === null) {
        return null;
    }
    // Document
    if (parentNode.nodeType === 9) {
        return document;
    }
    // Element
    if (parentNode.nodeType === 1) {
        // Firefox want us to check `-x` and `-y` variations as well
        const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
            return parentNode;
        }
    }
    return getScrollParent(parentNode);
}

// CONCATENATED MODULE: ./node_modules/vueuc/es/binder/src/Binder.js
/* eslint-disable @typescript-eslint/no-non-null-assertion */





const Binder = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Binder',
    props: {
        syncTargetWithParent: Boolean,
        syncTarget: {
            type: Boolean,
            default: true
        }
    },
    setup(props) {
        var _a;
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('VBinder', (_a = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])()) === null || _a === void 0 ? void 0 : _a.proxy);
        const VBinder = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('VBinder', null);
        const targetRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        /**
         * If there's no nested vbinder, we can simply set the target ref.
         *
         * However, when it comes to:
         * <VBinder> <- syncTarget = false
         *
         *              Should hold target DOM ref, but can't get it directly from
         *              its VTarget. So if there are nested VBinder, we should:
         *              1. Stop setting target DOM from level-1 VTarget
         *              2. Set target DOM from level-2 VTarget
         *              For (1), we need `syncTarget` to `false`
         *              For (2), we need to set `syncTargetWithParent` to `true` on
         *              level-2 VBinder
         *   <VTarget>
         *     <VBinder> <- syncTargetWithParent = true
         *       <VTarget>target</VTarget>
         *     </VBinder>
         *     <VFollower>
         *       content1
         *     </VFollower>
         *   </VTarget>
         *   <VFollower>
         *     content2
         *   </VFollower>
         * </VBinder>
         */
        const setTargetRef = (el) => {
            targetRef.value = el;
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (VBinder && props.syncTargetWithParent) {
                VBinder.setTargetRef(el);
            }
        };
        // scroll related
        let scrollableNodes = [];
        const ensureScrollListener = () => {
            let cursor = targetRef.value;
            while (true) {
                cursor = getScrollParent(cursor);
                if (cursor === null)
                    break;
                scrollableNodes.push(cursor);
            }
            for (const el of scrollableNodes) {
                delegate_on('scroll', el, onScroll, true);
            }
        };
        const removeScrollListeners = () => {
            for (const el of scrollableNodes) {
                delegate_off('scroll', el, onScroll, true);
            }
            scrollableNodes = [];
        };
        const followerScrollListeners = new Set();
        const addScrollListener = (listener) => {
            if (followerScrollListeners.size === 0) {
                ensureScrollListener();
            }
            if (!followerScrollListeners.has(listener)) {
                followerScrollListeners.add(listener);
            }
        };
        const removeScrollListener = (listener) => {
            if (followerScrollListeners.has(listener)) {
                followerScrollListeners.delete(listener);
            }
            if (followerScrollListeners.size === 0) {
                removeScrollListeners();
            }
        };
        const onScroll = () => {
            beforeNextFrameOnce(onScrollRaf);
        };
        const onScrollRaf = () => {
            followerScrollListeners.forEach((listener) => listener());
        };
        // resize related
        const followerResizeListeners = new Set();
        const addResizeListener = (listener) => {
            if (followerResizeListeners.size === 0) {
                delegate_on('resize', window, onResize);
            }
            if (!followerResizeListeners.has(listener)) {
                followerResizeListeners.add(listener);
            }
        };
        const removeResizeListener = (listener) => {
            if (followerResizeListeners.has(listener)) {
                followerResizeListeners.delete(listener);
            }
            if (followerResizeListeners.size === 0) {
                delegate_off('resize', window, onResize);
            }
        };
        const onResize = () => {
            followerResizeListeners.forEach((listener) => listener());
        };
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            delegate_off('resize', window, onResize);
            removeScrollListeners();
        });
        return {
            targetRef,
            setTargetRef,
            addScrollListener,
            removeScrollListener,
            addResizeListener,
            removeResizeListener
        };
    },
    render() {
        return v_node_getSlot(this.$slots);
    }
});
/* harmony default export */ var src_Binder = (Binder);

// CONCATENATED MODULE: ./node_modules/vueuc/es/binder/src/Target.js
/* eslint-disable @typescript-eslint/no-non-null-assertion */


/* harmony default export */ var Target = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Target',
    setup() {
        const { setTargetRef, syncTarget } = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('VBinder');
        const setTargetDirective = {
            mounted: setTargetRef,
            updated: setTargetRef
        };
        return {
            syncTarget,
            setTargetDirective
        };
    },
    render() {
        const { syncTarget, setTargetDirective } = this;
        /**
         * If you are using VBinder as a child of VBinder, the children wouldn't be
         * a valid DOM or component that can be attached to by directive.
         * So we won't sync target on those kind of situation and control the
         * target sync logic manually.
         */
        if (syncTarget) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(getFirstVNode(this.$slots), [[setTargetDirective]]);
        }
        return getFirstVNode(this.$slots);
    }
}));

// CONCATENATED MODULE: ./node_modules/vooks/es/use-compitable.js

function useCompitable(reactive, keys) {
    // @ts-expect-error
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        for (const key of keys) {
            if (reactive[key] !== undefined)
                return reactive[key];
        }
        return reactive[keys[keys.length - 1]];
    });
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/modal/src/interface.js
const modalBodyInjectionKey = Symbol('modalBody');
const modalInjectionKey = Symbol('modal');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/drawer/src/interface.js
const drawerBodyInjectionKey = Symbol('drawerBody');
const drawerInjectionKey = Symbol('drawer');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/popover/src/interface.js
const popoverBodyInjectionKey = Symbol('popoverBodyInjection');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/select-menu/src/interface.js
const internalSelectionMenuInjectionKey = Symbol('internal-select-menu');
const internalSelectionMenuBodyInjectionKey = Symbol('internal-select-menu-body');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/composable/use-adjusted-to.js






const teleportDisabled = '__disabled__';
function useAdjustedTo(props) {
    const modal = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(modalBodyInjectionKey, null);
    const drawer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(drawerBodyInjectionKey, null);
    const popover = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(popoverBodyInjectionKey, null);
    const selectMenu = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(internalSelectionMenuBodyInjectionKey, null);
    return use_memo(() => {
        var _a;
        const { to } = props;
        if (to !== undefined) {
            if (to === false)
                return teleportDisabled;
            if (to === true)
                return 'body';
            return to;
        }
        if (modal === null || modal === void 0 ? void 0 : modal.value) {
            return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
        }
        if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
            return drawer.value;
        if (popover === null || popover === void 0 ? void 0 : popover.value)
            return popover.value;
        if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
            return selectMenu.value;
        return to !== null && to !== void 0 ? to : 'body';
    });
}
// teleport disabled key
useAdjustedTo.tdkey = teleportDisabled;
useAdjustedTo.propTo = {
    type: [String, Object, Boolean],
    default: undefined
};


// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/get-first-slot-vnode.js


function getFirstSlotVNode(slots, slotName = 'default', props = undefined) {
    const slot = slots[slotName];
    if (!slot) {
        warn('getFirstSlotVNode', `slot[${slotName}] is empty`);
        return null;
    }
    const slotContent = flatten(slot(props));
    // vue will normalize the slot, so slot must be an array
    if (slotContent.length === 1) {
        return slotContent[0];
    }
    else {
        warn('getFirstSlotVNode', `slot[${slotName}] should have exactly one child`);
        return null;
    }
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/keep.js
function keep(object, keys = [], rest) {
    const keepedObject = {};
    keys.forEach((key) => {
        keepedObject[key] = object[key];
    });
    return Object.assign(keepedObject, rest);
}

// CONCATENATED MODULE: ./node_modules/vdirs/es/utils.js
const utils_warnedMessages = new Set();
function utils_warnOnce(location, message) {
    const mergedMessage = `[vdirs/${location}]: ${message}`;
    if (utils_warnedMessages.has(mergedMessage))
        return;
    utils_warnedMessages.add(mergedMessage);
}
function utils_warn(location, message) {
    console.error(`[vdirs/${location}]: ${message}`);
}

// CONCATENATED MODULE: ./node_modules/vdirs/es/zindexable/z-index-manager.js

class z_index_manager_ZIndexManager {
    constructor() {
        this.elementZIndex = new Map();
        this.nextZIndex = 2000;
    }
    get elementCount() {
        return this.elementZIndex.size;
    }
    ensureZIndex(el, zIndex) {
        const { elementZIndex } = this;
        if (zIndex !== undefined) {
            el.style.zIndex = `${zIndex}`;
            elementZIndex.delete(el);
            return;
        }
        const { nextZIndex } = this;
        if (elementZIndex.has(el)) {
            const currentZIndex = elementZIndex.get(el);
            if (currentZIndex + 1 === this.nextZIndex)
                return;
        }
        el.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
    }
    unregister(el) {
        const { elementZIndex } = this;
        if (elementZIndex.has(el)) {
            elementZIndex.delete(el);
        }
        else {
            utils_warn('vdirs/z-index-manager/unregister-element', 'Element not found when unregistering.');
        }
        this.squashState();
    }
    squashState() {
        const { elementCount } = this;
        if (!elementCount) {
            this.nextZIndex = 2000;
        }
        if (this.nextZIndex - elementCount > 2500)
            this.rearrange();
    }
    rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
            return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2000;
        elementZIndexPair.forEach(pair => {
            const el = pair[0];
            const zIndex = this.nextZIndex++;
            if (`${zIndex}` !== el.style.zIndex)
                el.style.zIndex = `${zIndex}`;
        });
    }
}
/* harmony default export */ var z_index_manager = (new z_index_manager_ZIndexManager());

// CONCATENATED MODULE: ./node_modules/vdirs/es/zindexable/index.js

const zindexable_ctx = '@@ziContext';
const zindexable = {
    mounted(el, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        z_index_manager.ensureZIndex(el, zIndex);
        el[zindexable_ctx] = {
            enabled
        };
    },
    updated(el, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        const cachedEnabled = el[zindexable_ctx].enabled;
        if (enabled && !cachedEnabled) {
            z_index_manager.ensureZIndex(el, zIndex);
        }
        el[zindexable_ctx].enabled = enabled;
    },
    unmounted(el) {
        z_index_manager.unregister(el);
    }
};
/* harmony default export */ var es_zindexable = (zindexable);

// CONCATENATED MODULE: ./node_modules/vooks/es/utils.js

function hasInstance() {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])() !== null;
}
const isBrowser = typeof window !== 'undefined';

// CONCATENATED MODULE: ./node_modules/vooks/es/on-fonts-ready.js


let fontsReady;
let isFontReady;
const init = () => {
    var _a, _b;
    fontsReady = isBrowser ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : undefined;
    isFontReady = false;
    /* istanbul ignore if */
    if (fontsReady !== undefined) {
        void fontsReady.then(() => {
            isFontReady = true;
        });
    }
    else {
        isFontReady = true;
    }
};
init();
// For testing

/**
 * Call callback on fontsReady is resolved. If fontsReady is already resolved,
 * callback won't be called.
 */
function onFontsReady(cb) {
    /* istanbul ignore next */
    if (isFontReady)
        return;
    let deactivated = false;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
        /* istanbul ignore next */
        if (!isFontReady) {
            fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
                if (deactivated)
                    return;
                cb();
            });
        }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
        deactivated = true;
    });
}

// CONCATENATED MODULE: ./node_modules/vueuc/es/shared/cssr.js

const { c: shared_cssr_c } = CssRender();


// CONCATENATED MODULE: ./node_modules/vooks/es/use-false-until-truthy.js

function useFalseUntilTruthy(originalRef) {
    const currentRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(!!originalRef.value);
    if (currentRef.value)
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(currentRef);
    const stop = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(originalRef, (value) => {
        if (value) {
            currentRef.value = true;
            stop();
        }
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(currentRef);
}

// CONCATENATED MODULE: ./node_modules/vueuc/es/lazy-teleport/src/index.js



/* harmony default export */ var lazy_teleport_src = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'LazyTeleport',
    props: {
        to: {
            type: [String, Object],
            default: undefined
        },
        disabled: Boolean,
        show: {
            type: Boolean,
            required: true
        }
    },
    setup(props) {
        return {
            showTeleport: useFalseUntilTruthy(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'show')),
            mergedTo: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { to } = props;
                return to !== null && to !== void 0 ? to : 'body';
            })
        };
    },
    render() {
        return this.showTeleport
            ? this.disabled
                ? v_node_getSlot(this.$slots)
                : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Teleport"], {
                    disabled: this.disabled,
                    to: this.mergedTo
                }, v_node_getSlot(this.$slots))
            : null;
    }
}));

// CONCATENATED MODULE: ./node_modules/vueuc/es/binder/src/get-placement-style.js
const oppositionPositions = {
    top: 'bottom',
    bottom: 'top',
    left: 'right',
    right: 'left'
};
const oppositeAligns = {
    start: 'end',
    center: 'center',
    end: 'start'
};
const propToCompare = {
    top: 'height',
    bottom: 'height',
    left: 'width',
    right: 'width'
};
const transformOrigins = {
    'bottom-start': 'top left',
    bottom: 'top center',
    'bottom-end': 'top right',
    'top-start': 'bottom left',
    top: 'bottom center',
    'top-end': 'bottom right',
    'right-start': 'top left',
    right: 'center left',
    'right-end': 'bottom left',
    'left-start': 'top right',
    left: 'center right',
    'left-end': 'bottom right'
};
const overlapTransformOrigin = {
    'bottom-start': 'bottom left',
    bottom: 'bottom center',
    'bottom-end': 'bottom right',
    'top-start': 'top left',
    top: 'top center',
    'top-end': 'top right',
    'right-start': 'top right',
    right: 'center right',
    'right-end': 'bottom right',
    'left-start': 'top left',
    left: 'center left',
    'left-end': 'bottom left'
};
const oppositeAlignCssPositionProps = {
    'bottom-start': 'right',
    'bottom-end': 'left',
    'top-start': 'right',
    'top-end': 'left',
    'right-start': 'bottom',
    'right-end': 'top',
    'left-start': 'bottom',
    'left-end': 'top'
};
function getProperPlacementOfFollower(placement, targetRect, followerRect, flip, overlap) {
    if (!flip || overlap) {
        return placement;
    }
    const [position, align] = placement.split('-');
    let properAlign = align !== null && align !== void 0 ? align : 'center';
    if (align !== 'center') {
        const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
        const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
        const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
        // if follower rect is larger than target rect in align direction
        //           [ target ]
        //           [     follower     ]
        // [     follower     ] <---->
        if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
            // [ target ]---|
            // [ follower   |  ]
            if (
            // overflow screen
            (targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] <= followerRect[oppositeAlignCssSizeProp]) &&
                // opposite align has larger space
                (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp])) {
                properAlign = oppositeAligns[align];
            }
        }
        // if follower rect is smaller than target rect in align direction
        // [     target     ]
        // [ follower ]         <---->
        if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
            if (targetRect[currentAlignCssPositionProp] < 0 &&
                // opposite align has larger space
                targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
                properAlign = oppositeAligns[align];
            }
        }
    }
    let properPosition = position;
    if (
    // space is not enough
    !(targetRect[position] >= followerRect[propToCompare[position]]) &&
        // opposite position's space is larger
        targetRect[oppositionPositions[position]] >= followerRect[propToCompare[position]]) {
        properPosition = oppositionPositions[position];
    }
    return properAlign !== 'center' ? `${properPosition}-${properAlign}` : properPosition;
}
function getProperTransformOrigin(placement, overlap) {
    if (overlap)
        return overlapTransformOrigin[placement];
    return transformOrigins[placement];
}
// ------------
// |  offset  |
// |          |
// | [target] |
// |          |
// ------------
function get_placement_style_getOffset(placement, offsetRect, targetRect, overlap) {
    if (overlap) {
        switch (placement) {
            case 'bottom-start':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                    transform: 'translateY(-100%)'
                };
            case 'bottom-end':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                    transform: 'translateX(-100%) translateY(-100%)'
                };
            case 'top-start':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                    transform: ''
                };
            case 'top-end':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                    transform: 'translateX(-100%)'
                };
            case 'right-start':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                    transform: 'translateX(-100%)'
                };
            case 'right-end':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                    transform: 'translateX(-100%) translateY(-100%)'
                };
            case 'left-start':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                    transform: ''
                };
            case 'left-end':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                    transform: 'translateY(-100%)'
                };
            case 'top':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                    transform: 'translateX(-50%)'
                };
            case 'right':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                    transform: 'translateX(-100%) translateY(-50%)'
                };
            case 'left':
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                    transform: 'translateY(-50%)'
                };
            case 'bottom':
            default:
                return {
                    top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                    left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                    transform: 'translateX(-50%) translateY(-100%)'
                };
        }
    }
    switch (placement) {
        case 'bottom-start':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: ''
            };
        case 'bottom-end':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: 'translateX(-100%)'
            };
        case 'top-start':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: 'translateY(-100%)'
            };
        case 'top-end':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: 'translateX(-100%) translateY(-100%)'
            };
        case 'right-start':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: ''
            };
        case 'right-end':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: 'translateY(-100%)'
            };
        case 'left-start':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: 'translateX(-100%)'
            };
        case 'left-end':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: 'translateX(-100%) translateY(-100%)'
            };
        case 'top':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                transform: 'translateY(-100%) translateX(-50%)'
            };
        case 'right':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: 'translateY(-50%)'
            };
        case 'left':
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: 'translateY(-50%) translateX(-100%)'
            };
        case 'bottom':
        default:
            return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                transform: 'translateX(-50%)'
            };
    }
}

// CONCATENATED MODULE: ./node_modules/vueuc/es/binder/src/Follower.js
/* eslint-disable @typescript-eslint/no-non-null-assertion */








const Follower_style = shared_cssr_c([
    shared_cssr_c('.v-binder-follower-container', {
        position: 'absolute',
        left: '0',
        right: '0',
        top: '0',
        height: '0',
        pointerEvents: 'none',
        zIndex: 'auto'
    }),
    shared_cssr_c('.v-binder-follower-content', {
        position: 'absolute',
        zIndex: 'auto'
    }, [
        shared_cssr_c('> *', {
            pointerEvents: 'all'
        })
    ])
]);
/* harmony default export */ var Follower = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Follower',
    inheritAttrs: false,
    props: {
        show: Boolean,
        enabled: {
            type: Boolean,
            default: undefined
        },
        placement: {
            type: String,
            default: 'bottom'
        },
        syncTrigger: {
            type: Array,
            default: ['resize', 'scroll']
        },
        to: [String, Object],
        flip: {
            type: Boolean,
            default: true
        },
        x: Number,
        y: Number,
        width: String,
        minWidth: String,
        containerClass: String,
        teleportDisabled: Boolean,
        zindexable: {
            type: Boolean,
            default: true
        },
        zIndex: Number,
        overlap: Boolean
    },
    setup(props) {
        const VBinder = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('VBinder');
        const mergedEnabledRef = use_memo(() => {
            return props.enabled !== undefined ? props.enabled : props.show;
        });
        const followerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const offsetContainerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const ensureListeners = () => {
            const { syncTrigger } = props;
            if (syncTrigger.includes('scroll')) {
                VBinder.addScrollListener(syncPosition);
            }
            if (syncTrigger.includes('resize')) {
                VBinder.addResizeListener(syncPosition);
            }
        };
        const removeListeners = () => {
            VBinder.removeScrollListener(syncPosition);
            VBinder.removeResizeListener(syncPosition);
        };
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
            if (mergedEnabledRef.value) {
                syncPosition();
                ensureListeners();
            }
        });
        const ssrAdapter = useSsrAdapter();
        Follower_style.mount({
            id: 'vueuc/binder',
            head: true,
            ssr: ssrAdapter
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            removeListeners();
        });
        onFontsReady(() => {
            if (mergedEnabledRef.value) {
                syncPosition();
            }
        });
        const syncPosition = () => {
            if (!mergedEnabledRef.value) {
                return;
            }
            const follower = followerRef.value;
            // sometimes watched props change before its dom is ready
            // for example: show=false, x=undefined, y=undefined
            //              show=true,  x=0,         y=0
            // will cause error
            // I may optimize the watch start point later
            if (follower === null)
                return;
            const target = VBinder.targetRef;
            const { x, y, overlap } = props;
            const targetRect = x !== undefined && y !== undefined
                ? getPointRect(x, y)
                : getRect(target);
            const { width, minWidth, placement, flip } = props;
            follower.setAttribute('v-placement', placement);
            if (overlap) {
                follower.setAttribute('v-overlap', '');
            }
            else {
                follower.removeAttribute('v-overlap');
            }
            const { style } = follower;
            if (width === 'target') {
                style.width = `${targetRect.width}px`;
            }
            else if (width !== undefined) {
                style.width = width;
            }
            else {
                style.width = '';
            }
            if (minWidth === 'target') {
                style.minWidth = `${targetRect.width}px`;
            }
            else if (minWidth !== undefined) {
                style.minWidth = minWidth;
            }
            else {
                style.minWidth = '';
            }
            const followerRect = getRect(follower);
            const offsetContainerRect = getRect(offsetContainerRef.value);
            const properPlacement = getProperPlacementOfFollower(placement, targetRect, followerRect, flip, overlap);
            const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
            const { left, top, transform } = get_placement_style_getOffset(properPlacement, offsetContainerRect, targetRect, overlap);
            // we assume that the content size doesn't change after flip,
            // nor we need to make sync logic more complex
            follower.setAttribute('v-placement', properPlacement);
            follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
            follower.style.transformOrigin = properTransformOrigin;
        };
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(mergedEnabledRef, (value) => {
            if (value) {
                ensureListeners();
                syncOnNextTick();
            }
            else {
                removeListeners();
            }
        });
        const syncOnNextTick = () => {
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])()
                .then(syncPosition)
                .catch((e) => console.error(e));
        };
        ['placement', 'x', 'y', 'flip', 'width', 'overlap', 'minWidth'].forEach((prop) => {
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, prop), syncPosition);
        });
        ['teleportDisabled'].forEach((prop) => {
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, prop), syncOnNextTick);
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'syncTrigger'), (value) => {
            if (!value.includes('resize')) {
                VBinder.removeResizeListener(syncPosition);
            }
            else {
                VBinder.addResizeListener(syncPosition);
            }
            if (!value.includes('scroll')) {
                VBinder.removeScrollListener(syncPosition);
            }
            else {
                VBinder.addScrollListener(syncPosition);
            }
        });
        const isMountedRef = use_is_mounted_isMounted();
        const mergedToRef = use_memo(() => {
            const { to } = props;
            if (to !== undefined)
                return to;
            if (isMountedRef.value) {
                // TODO: find proper container
                return undefined;
            }
            return undefined;
        });
        return {
            VBinder,
            mergedEnabled: mergedEnabledRef,
            offsetContainerRef,
            followerRef,
            mergedTo: mergedToRef,
            syncPosition
        };
    },
    render() {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(lazy_teleport_src, {
            show: this.show,
            to: this.mergedTo,
            disabled: this.teleportDisabled
        }, {
            default: () => {
                const vNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])('div', {
                    class: ['v-binder-follower-container', this.containerClass],
                    ref: 'offsetContainerRef'
                }, [
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])('div', {
                        class: 'v-binder-follower-content',
                        ref: 'followerRef'
                    }, this.$slots)
                ]);
                if (this.zindexable) {
                    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(vNode, [
                        [
                            es_zindexable,
                            {
                                enabled: this.mergedEnabled,
                                zIndex: this.zIndex
                            }
                        ]
                    ]);
                }
                return vNode;
            }
        });
    }
}));

// CONCATENATED MODULE: ./node_modules/vdirs/es/clickoutside.js

const ctxKey = '@@coContext';
const clickoutside = {
    mounted(el, { value }) {
        el[ctxKey] = {
            handler: undefined
        };
        if (typeof value === 'function') {
            el[ctxKey].handler = value;
            delegate_on('clickoutside', el, value);
        }
    },
    updated(el, { value }) {
        const ctx = el[ctxKey];
        if (typeof value === 'function') {
            if (ctx.handler) {
                if (ctx.handler !== value) {
                    delegate_off('clickoutside', el, ctx.handler);
                    ctx.handler = value;
                    delegate_on('clickoutside', el, value);
                }
            }
            else {
                el[ctxKey].handler = value;
                delegate_on('clickoutside', el, value);
            }
        }
        else {
            if (ctx.handler) {
                delegate_off('clickoutside', el, ctx.handler);
                ctx.handler = undefined;
            }
        }
    },
    unmounted(el) {
        const { handler } = el[ctxKey];
        if (handler) {
            delegate_off('clickoutside', el, handler);
        }
        el[ctxKey].handler = undefined;
    }
};
/* harmony default export */ var es_clickoutside = (clickoutside);

// CONCATENATED MODULE: ./node_modules/vdirs/es/mousemoveoutside.js

const mousemoveoutside_ctxKey = '@@mmoContext';
const mousemoveoutside = {
    mounted(el, { value }) {
        el[mousemoveoutside_ctxKey] = {
            handler: undefined
        };
        if (typeof value === 'function') {
            el[mousemoveoutside_ctxKey].handler = value;
            delegate_on('mousemoveoutside', el, value);
        }
    },
    updated(el, { value }) {
        const ctx = el[mousemoveoutside_ctxKey];
        if (typeof value === 'function') {
            if (ctx.handler) {
                if (ctx.handler !== value) {
                    delegate_off('mousemoveoutside', el, ctx.handler);
                    ctx.handler = value;
                    delegate_on('mousemoveoutside', el, value);
                }
            }
            else {
                el[mousemoveoutside_ctxKey].handler = value;
                delegate_on('mousemoveoutside', el, value);
            }
        }
        else {
            if (ctx.handler) {
                delegate_off('mousemoveoutside', el, ctx.handler);
                ctx.handler = undefined;
            }
        }
    },
    unmounted(el) {
        const { handler } = el[mousemoveoutside_ctxKey];
        if (handler) {
            delegate_off('mousemoveoutside', el, handler);
        }
        el[mousemoveoutside_ctxKey].handler = undefined;
    }
};
/* harmony default export */ var es_mousemoveoutside = (mousemoveoutside);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/popover/styles/_common.js
/* harmony default export */ var popover_styles_common = ({
    space: '6px',
    spaceArrow: '10px',
    arrowOffset: '10px',
    arrowOffsetVertical: '10px',
    arrowHeight: '6px',
    padding: '8px 14px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/popover/styles/light.js


const popover_styles_light_self = (vars) => {
    const { boxShadow2, popoverColor, textColor2, borderRadius, fontSize, dividerColor } = vars;
    return Object.assign(Object.assign({}, popover_styles_common), { fontSize,
        borderRadius, color: popoverColor, dividerColor, textColor: textColor2, boxShadow: boxShadow2 });
};
const popoverLight = {
    name: 'Popover',
    common: light,
    self: popover_styles_light_self
};
/* harmony default export */ var popover_styles_light = (popoverLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/popover/src/styles/index.cssr.js

const oppositePlacement = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
}; // vars:
// --bezier
// --bezier-ease-in
// --bezier-ease-out
// --font-size
// --text-color
// --color
// --border-radius
// --arrow-height
// --arrow-offset
// --arrow-offset-vertical
// --padding
// --space
// --space-arrow
// --divider-color

/* harmony default export */ var popover_src_styles_index_cssr = (cssr_c([cB('popover', `
 transition:
 box-shadow .3s var(--bezier),
 background-color .3s var(--bezier),
 color .3s var(--bezier);
 transform-origin: inherit;
 position: relative;
 font-size: var(--font-size);
 color: var(--text-color);
 box-shadow: var(--box-shadow);
 `, [// body transition
cssr_c('&.popover-transition-enter-from, &.popover-transition-leave-to', `
 opacity: 0;
 transform: scale(.85);
 `), cssr_c('&.popover-transition-enter-to, &.popover-transition-leave-from', `
 transform: scale(1);
 opacity: 1;
 `), cssr_c('&.popover-transition-enter-active', `
 transition:
 opacity .15s var(--bezier-ease-out),
 transform .15s var(--bezier-ease-out);
 `), cssr_c('&.popover-transition-leave-active', `
 transition:
 opacity .15s var(--bezier-ease-in),
 transform .15s var(--bezier-ease-in);
 `), cNotM('raw', `
 background-color: var(--color);
 border-radius: var(--border-radius);
 var(--padding);
 `, [cNotM('show-header', 'padding: var(--padding);')]), cE('header', `
 padding: var(--padding);
 border-bottom: 1px solid var(--divider-color);
 transition: border-color .3s var(--bezier);
 `), cE('content', `
 padding: var(--padding);
 `), cB('popover-arrow-wrapper', `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB('popover-arrow', `
 transition: background-color .3s var(--bezier);
 position: absolute;
 display: block;
 width: calc(var(--arrow-height) * 1.414);
 height: calc(var(--arrow-height) * 1.414);
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--color);
 pointer-events: all;
 `)])]), placementStyle('top-start', `
 top: calc(-0.707 * var(--arrow-height));
 left: var(--arrow-offset);
 `), placementStyle('top', `
 top: calc(-0.707 * var(--arrow-height));
 transform: translateX(calc(-0.707 * var(--arrow-height))) rotate(45deg);
 left: 50%;
 `), placementStyle('top-end', `
 top: calc(-0.707 * var(--arrow-height));
 right: var(--arrow-offset);
 `), placementStyle('bottom-start', `
 bottom: calc(-0.707 * var(--arrow-height));
 left: var(--arrow-offset);
 `), placementStyle('bottom', `
 bottom: calc(-0.707 * var(--arrow-height));
 transform: translateX(calc(-0.707 * var(--arrow-height))) rotate(45deg);
 left: 50%;
 `), placementStyle('bottom-end', `
 bottom: calc(-0.707 * var(--arrow-height));
 right: var(--arrow-offset);
 `), placementStyle('left-start', `
 left: calc(-0.707 * var(--arrow-height));
 top: var(--arrow-offset-vertical);
 `), placementStyle('left', `
 left: calc(-0.707 * var(--arrow-height));
 transform: translateY(calc(-0.707 * var(--arrow-height))) rotate(45deg);
 top: 50%;
 `), placementStyle('left-end', `
 left: calc(-0.707 * var(--arrow-height));
 bottom: var(--arrow-offset-vertical);
 `), placementStyle('right-start', `
 right: calc(-0.707 * var(--arrow-height));
 top: var(--arrow-offset-vertical);
 `), placementStyle('right', `
 right: calc(-0.707 * var(--arrow-height));
 transform: translateY(calc(-0.707 * var(--arrow-height))) rotate(45deg);
 top: 50%;
 `), placementStyle('right-end', `
 right: calc(-0.707 * var(--arrow-height));
 bottom: var(--arrow-offset-vertical);
 `)]));

function placementStyle(placement, arrowStyleLiteral) {
  const position = placement.split('-')[0];
  const sizeStyle = ['top', 'bottom'].includes(position) ? 'height: var(--space-arrow);' : 'width: var(--space-arrow);';
  return cssr_c(`[v-placement="${placement}"] >`, [cB('popover', `
 margin-${oppositePlacement[position]}: var(--space);
 `, [cM('show-arrow', `
 margin-${oppositePlacement[position]}: var(--space-arrow);
 `), cM('overlap', `
 margin: 0;
 `), cCB('popover-arrow-wrapper', `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB('popover-arrow', arrowStyleLiteral)])])]);
}
// CONCATENATED MODULE: ./node_modules/naive-ui/es/popover/src/PopoverBody.js










const popoverBodyProps = Object.assign(Object.assign({}, use_theme.props), { to: useAdjustedTo.propTo, show: Boolean, trigger: String, showArrow: Boolean, delay: Number, duration: Number, raw: Boolean, arrowStyle: [String, Object], displayDirective: String, x: Number, y: Number, filp: Boolean, overlap: Boolean, placement: String, width: [Number, String], 
    // private
    animated: Boolean, onClickoutside: Function, 
    /** @deprecated */
    minWidth: Number, maxWidth: Number });
const renderArrow = ({ arrowStyle, clsPrefix }) => {
    return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "__popover-arrow__", class: `${clsPrefix}-popover-arrow-wrapper` },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${clsPrefix}-popover-arrow`, style: arrowStyle })));
};
/* harmony default export */ var PopoverBody = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'PopoverBody',
    inheritAttrs: false,
    props: popoverBodyProps,
    setup(props, { slots, attrs }) {
        const { namespaceRef, mergedClsPrefixRef } = useConfig(props);
        const themeRef = use_theme('Popover', 'Popover', popover_src_styles_index_cssr, popover_styles_light, props, mergedClsPrefixRef);
        const followerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const NPopover = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('NPopover');
        const bodyRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const followerEnabledRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.show);
        const directivesRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { trigger, onClickoutside } = props;
            const directives = [];
            const { positionManuallyRef: { value: positionManually } } = NPopover;
            if (!positionManually) {
                if (trigger === 'click' && !onClickoutside) {
                    directives.push([es_clickoutside, handleClickOutside]);
                }
                if (trigger === 'hover') {
                    directives.push([es_mousemoveoutside, handleMouseMoveOutside]);
                }
            }
            if (onClickoutside) {
                directives.push([es_clickoutside, handleClickOutside]);
            }
            if (props.displayDirective === 'show') {
                directives.push([external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], props.show]);
            }
            return directives;
        });
        const styleRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return [
                {
                    width: props.width === 'trigger' ? '' : format_length(props.width),
                    maxWidth: format_length(props.maxWidth),
                    minWidth: format_length(props.minWidth)
                },
                cssVarsRef.value
            ];
        });
        const cssVarsRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { common: { cubicBezierEaseInOut, cubicBezierEaseIn, cubicBezierEaseOut }, self: { space, spaceArrow, padding, fontSize, textColor, dividerColor, color, boxShadow, borderRadius, arrowHeight, arrowOffset, arrowOffsetVertical } } = themeRef.value;
            return {
                '--box-shadow': boxShadow,
                '--bezier': cubicBezierEaseInOut,
                '--bezier-ease-in': cubicBezierEaseIn,
                '--bezier-ease-out': cubicBezierEaseOut,
                '--font-size': fontSize,
                '--text-color': textColor,
                '--color': color,
                '--divider-color': dividerColor,
                '--border-radius': borderRadius,
                '--arrow-height': arrowHeight,
                '--arrow-offset': arrowOffset,
                '--arrow-offset-vertical': arrowOffsetVertical,
                '--padding': padding,
                '--space': space,
                '--space-arrow': spaceArrow
            };
        });
        NPopover.setBodyInstance({
            syncPosition
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            NPopover.setBodyInstance(null);
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'show'), (value) => {
            // If no animation, no transition component will be applied to the
            // component. So we need to trigger follower manaully.
            if (props.animated)
                return;
            if (value) {
                followerEnabledRef.value = true;
            }
            else {
                followerEnabledRef.value = false;
            }
        });
        function syncPosition() {
            var _a;
            // eslint-disable-next-line no-unused-expressions
            (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
        }
        function handleMouseEnter(e) {
            if (props.trigger === 'hover') {
                NPopover.handleMouseEnter(e);
            }
        }
        function handleMouseLeave(e) {
            if (props.trigger === 'hover') {
                NPopover.handleMouseLeave(e);
            }
        }
        function handleMouseMoveOutside(e) {
            if (props.trigger === 'hover' &&
                !getTriggerElement().contains(e.target)) {
                NPopover.handleMouseMoveOutside(e);
            }
        }
        function handleClickOutside(e) {
            if ((props.trigger === 'click' &&
                !getTriggerElement().contains(e.target)) ||
                props.onClickoutside) {
                NPopover.handleClickOutside(e);
            }
        }
        function getTriggerElement() {
            return NPopover.getTriggerElement();
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(popoverBodyInjectionKey, bodyRef);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(drawerBodyInjectionKey, null);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(modalBodyInjectionKey, null);
        function renderContentNode() {
            let contentNode;
            const { internalRenderBodyRef: { value: renderBody } } = NPopover;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            if (!renderBody) {
                const { value: extraClass } = NPopover.extraClassRef;
                contentNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])('div', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["mergeProps"])({
                    class: [
                        `${mergedClsPrefix}-popover`,
                        extraClass.map((v) => `${mergedClsPrefix}-${v}`),
                        {
                            [`${mergedClsPrefix}-popover--overlap`]: props.overlap,
                            [`${mergedClsPrefix}-popover--show-arrow`]: props.showArrow,
                            [`${mergedClsPrefix}-popover--show-header`]: !!slots.header,
                            [`${mergedClsPrefix}-popover--raw`]: props.raw
                        }
                    ],
                    ref: bodyRef,
                    style: styleRef.value,
                    onMouseenter: handleMouseEnter,
                    onMouseleave: handleMouseLeave
                }, attrs), [
                    slots.header ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null,
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-popover__header` }, slots.header()),
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-popover__content` }, slots))) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(slots, 'default')),
                    props.showArrow
                        ? renderArrow({
                            arrowStyle: props.arrowStyle,
                            clsPrefix: mergedClsPrefix
                        })
                        : null
                ]);
            }
            else {
                contentNode = renderBody(
                // The popover class and overlap class must exists, they will be used
                // to place the body & transition animation.
                // Shadow class exists for reuse box-shadow.
                [
                    `${mergedClsPrefix}-popover`,
                    props.overlap && `${mergedClsPrefix}-popover--overlap`
                ], bodyRef, styleRef.value, handleMouseEnter, handleMouseLeave);
            }
            return props.displayDirective === 'show' || props.show
                ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(contentNode, directivesRef.value)
                : null;
        }
        return {
            namespace: namespaceRef,
            isMounted: NPopover.isMountedRef,
            zIndex: NPopover.zIndexRef,
            followerRef,
            adjustedTo: useAdjustedTo(props),
            followerEnabled: followerEnabledRef,
            renderContentNode
        };
    },
    render() {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Follower, {
            zIndex: this.zIndex,
            show: this.show,
            enabled: this.followerEnabled,
            to: this.adjustedTo,
            x: this.x,
            y: this.y,
            placement: this.placement,
            containerClass: this.namespace,
            ref: 'followerRef',
            overlap: this.overlap,
            width: this.width === 'trigger' ? 'target' : undefined,
            teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
        }, {
            default: () => {
                return this.animated
                    ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], {
                        name: 'popover-transition',
                        appear: this.isMounted,
                        // Don't use watch to enable follower, since the transition may
                        // make position sync timing very subtle and buggy.
                        onEnter: () => {
                            this.followerEnabled = true;
                        },
                        onAfterLeave: () => {
                            this.followerEnabled = false;
                        }
                    }, {
                        default: this.renderContentNode
                    })
                    : this.renderContentNode();
            }
        });
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/popover/src/Popover.js






const bodyPropKeys = Object.keys(popoverBodyProps);
const triggerEventMap = {
    focus: ['onFocus', 'onBlur'],
    click: ['onClick'],
    hover: ['onMouseenter', 'onMouseleave'],
    manual: [],
    nested: ['onFocus', 'onBlur', 'onMouseenter', 'onMouseleave', 'onClick']
};
function appendEvents(vNode, trigger, events) {
    triggerEventMap[trigger].forEach((eventName) => {
        if (!vNode.props)
            vNode.props = {};
        else {
            vNode.props = Object.assign({}, vNode.props);
        }
        const originalHandler = vNode.props[eventName];
        const handler = events[eventName];
        if (!originalHandler)
            vNode.props[eventName] = handler;
        else {
            vNode.props[eventName] = (...args) => {
                originalHandler(...args);
                handler(...args);
            };
        }
    });
}
const textVNodeType = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])('').type;
const popoverBaseProps = {
    show: {
        type: Boolean,
        default: undefined
    },
    defaultShow: Boolean,
    showArrow: {
        type: Boolean,
        default: true
    },
    trigger: {
        type: String,
        default: 'hover'
    },
    delay: {
        type: Number,
        default: 100
    },
    duration: {
        type: Number,
        default: 100
    },
    raw: Boolean,
    placement: {
        type: String,
        default: 'top'
    },
    x: Number,
    y: Number,
    disabled: Boolean,
    getDisabled: Function,
    displayDirective: {
        type: String,
        default: 'if'
    },
    arrowStyle: [String, Object],
    filp: {
        type: Boolean,
        default: true
    },
    animated: {
        type: Boolean,
        default: true
    },
    width: {
        type: [Number, String],
        default: undefined
    },
    overlap: Boolean,
    internalExtraClass: {
        type: Array,
        default: () => []
    },
    onClickoutside: Function,
    // events
    'onUpdate:show': [Function, Array],
    onUpdateShow: [Function, Array],
    zIndex: Number,
    to: useAdjustedTo.propTo,
    internalSyncTargetWithParent: Boolean,
    internalInheritedEventHandlers: {
        type: Array,
        default: () => []
    },
    /** @deprecated */
    onShow: [Function, Array],
    /** @deprecated */
    onHide: [Function, Array],
    /** @deprecated */
    arrow: {
        type: Boolean,
        default: undefined
    },
    /** @deprecated */
    minWidth: Number,
    /** @deprecated */
    maxWidth: Number
};
const popoverProps = Object.assign(Object.assign(Object.assign({}, use_theme.props), popoverBaseProps), { internalRenderBody: Function });
/* harmony default export */ var Popover = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Popover',
    inheritAttrs: false,
    props: popoverProps,
    __popover__: true,
    setup(props) {
        if (false) {}
        const isMountedRef = use_is_mounted_isMounted();
        const binderInstRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        // setup show
        const controlledShowRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => props.show);
        const uncontrolledShowRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultShow);
        const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const mergedShowConsideringDisabledPropRef = use_memo(() => {
            if (props.disabled)
                return false;
            return mergedShowWithoutDisabledRef.value;
        });
        const getMergedDisabled = () => {
            if (props.disabled)
                return true;
            const { getDisabled } = props;
            if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
                return true;
            return false;
        };
        const getMergedShow = () => {
            if (getMergedDisabled())
                return false;
            return mergedShowWithoutDisabledRef.value;
        };
        // setup show-arrow
        const compatibleShowArrowRef = useCompitable(props, ['arrow', 'showArrow']);
        const mergedShowArrowRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            if (props.overlap)
                return false;
            return compatibleShowArrowRef.value;
        });
        // bodyInstance
        let bodyInstance = null;
        const showTimerIdRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const hideTimerIdRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const positionManuallyRef = use_memo(() => {
            return props.x !== undefined && props.y !== undefined;
        });
        // methods
        function doUpdateShow(value) {
            const { 'onUpdate:show': _onUpdateShow, onUpdateShow, onShow, onHide } = props;
            uncontrolledShowRef.value = value;
            if (_onUpdateShow) {
                call(_onUpdateShow, value);
            }
            if (onUpdateShow) {
                call(onUpdateShow, value);
            }
            if (value && onShow) {
                call(onShow, true);
            }
            if (value && onHide) {
                call(onHide, false);
            }
        }
        function syncPosition() {
            if (bodyInstance) {
                bodyInstance.syncPosition();
            }
        }
        function clearShowTimer() {
            const { value: showTimerId } = showTimerIdRef;
            if (showTimerId) {
                window.clearTimeout(showTimerId);
                showTimerIdRef.value = null;
            }
        }
        function clearHideTimer() {
            const { value: hideTimerId } = hideTimerIdRef;
            if (hideTimerId) {
                window.clearTimeout(hideTimerId);
                hideTimerIdRef.value = null;
            }
        }
        function handleFocus() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === 'focus' && !mergedDisabled) {
                if (getMergedShow())
                    return;
                doUpdateShow(true);
            }
        }
        function handleBlur() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === 'focus' && !mergedDisabled) {
                if (!getMergedShow())
                    return;
                doUpdateShow(false);
            }
        }
        function handleMouseEnter() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === 'hover' && !mergedDisabled) {
                clearHideTimer();
                if (showTimerIdRef.value !== null)
                    return;
                if (getMergedShow())
                    return;
                const delayCallback = () => {
                    doUpdateShow(true);
                    showTimerIdRef.value = null;
                };
                const { delay } = props;
                if (delay === 0) {
                    delayCallback();
                }
                else {
                    showTimerIdRef.value = window.setTimeout(delayCallback, delay);
                }
            }
        }
        function handleMouseLeave() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === 'hover' && !mergedDisabled) {
                clearShowTimer();
                if (hideTimerIdRef.value !== null)
                    return;
                if (!getMergedShow())
                    return;
                const delayedCallback = () => {
                    doUpdateShow(false);
                    hideTimerIdRef.value = null;
                };
                const { duration } = props;
                if (duration === 0) {
                    delayedCallback();
                }
                else {
                    hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
                }
            }
        }
        // will be called in popover-content
        function handleMouseMoveOutside() {
            handleMouseLeave();
        }
        // will be called in popover-content
        function handleClickOutside(e) {
            var _a;
            if (!getMergedShow())
                return;
            if (props.trigger === 'click') {
                clearShowTimer();
                clearHideTimer();
                doUpdateShow(false);
            }
            (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function handleClick() {
            if (props.trigger === 'click' && !getMergedDisabled()) {
                clearShowTimer();
                clearHideTimer();
                const nextShow = !getMergedShow();
                doUpdateShow(nextShow);
            }
        }
        function setShow(value) {
            uncontrolledShowRef.value = value;
        }
        function getTriggerElement() {
            var _a;
            return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
        }
        function setBodyInstance(value) {
            bodyInstance = value;
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('NPopover', {
            getTriggerElement,
            handleMouseEnter,
            handleMouseLeave,
            handleClickOutside,
            handleMouseMoveOutside,
            setBodyInstance,
            positionManuallyRef: positionManuallyRef,
            isMountedRef: isMountedRef,
            zIndexRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'zIndex'),
            extraClassRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'internalExtraClass'),
            internalRenderBodyRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'internalRenderBody')
        });
        return {
            binderInstRef,
            positionManually: positionManuallyRef,
            mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
            // if to show popover body
            uncontrolledShow: uncontrolledShowRef,
            mergedShowArrow: mergedShowArrowRef,
            getMergedShow,
            setShow,
            handleClick,
            handleMouseEnter,
            handleMouseLeave,
            handleFocus,
            handleBlur,
            syncPosition
        };
    },
    render() {
        var _a;
        const { positionManually, $slots: slots } = this;
        let triggerVNode;
        let popoverInside = false;
        if (!positionManually) {
            if (slots.activator) {
                triggerVNode = getFirstSlotVNode(slots, 'activator');
            }
            else {
                triggerVNode = getFirstSlotVNode(slots, 'trigger');
            }
            if (triggerVNode) {
                triggerVNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(triggerVNode);
                triggerVNode =
                    triggerVNode.type === textVNodeType
                        ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])('span', [triggerVNode])
                        : triggerVNode;
                const handlers = {
                    onClick: this.handleClick,
                    onMouseenter: this.handleMouseEnter,
                    onMouseleave: this.handleMouseLeave,
                    onFocus: this.handleFocus,
                    onBlur: this.handleBlur
                };
                if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
                    popoverInside = true;
                    // We assume that there's no DOM event handlers on popover element
                    if (!triggerVNode.props) {
                        triggerVNode.props = {
                            internalSyncTargetWithParent: true,
                            internalInheritedEventHandlers: []
                        };
                    }
                    triggerVNode.props.internalSyncTargetWithParent = true;
                    if (!triggerVNode.props.internalInheritedEventHandlers) {
                        triggerVNode.props.internalInheritedEventHandlers = [handlers];
                    }
                    else {
                        triggerVNode.props.internalInheritedEventHandlers = [
                            handlers,
                            ...triggerVNode.props.internalInheritedEventHandlers
                        ];
                    }
                }
                else {
                    const { internalInheritedEventHandlers } = this;
                    const ascendantAndCurrentHandlers = [
                        handlers,
                        ...internalInheritedEventHandlers
                    ];
                    const mergedHandlers = {
                        onBlur: (e) => {
                            ascendantAndCurrentHandlers.forEach((_handlers) => {
                                _handlers.onBlur(e);
                            });
                        },
                        onFocus: (e) => {
                            ascendantAndCurrentHandlers.forEach((_handlers) => {
                                _handlers.onBlur(e);
                            });
                        },
                        onClick: (e) => {
                            ascendantAndCurrentHandlers.forEach((_handlers) => {
                                _handlers.onClick(e);
                            });
                        },
                        onMouseenter: (e) => {
                            ascendantAndCurrentHandlers.forEach((_handlers) => {
                                _handlers.onMouseenter(e);
                            });
                        },
                        onMouseleave: (e) => {
                            ascendantAndCurrentHandlers.forEach((_handlers) => {
                                _handlers.onMouseleave(e);
                            });
                        }
                    };
                    appendEvents(triggerVNode, internalInheritedEventHandlers
                        ? 'nested'
                        : positionManually
                            ? 'manual'
                            : this.trigger, mergedHandlers);
                }
            }
        }
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Binder, { ref: "binderInstRef", syncTarget: !popoverInside, syncTargetWithParent: this.internalSyncTargetWithParent }, {
            default: () => {
                // We need to subscribe it. Sometimes rerender won't ge triggered.
                // `mergedShowConsideringDisabledProp` is not the final disabled status.
                // In ellpisis it's dynamic.
                void this.mergedShowConsideringDisabledProp;
                const mergedShow = this.getMergedShow();
                return [
                    positionManually
                        ? null
                        : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Target, null, {
                            default: () => triggerVNode
                        }),
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(PopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), { showArrow: this.mergedShowArrow, show: mergedShow })), slots)
                ];
            }
        }));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/tooltip/styles/_common.js
/* harmony default export */ var tooltip_styles_common = ({
    padding: '8px 14px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/tooltip/styles/light.js




const tooltip_styles_light_self = (vars) => {
    const { borderRadius, boxShadow2, baseColor } = vars;
    return Object.assign(Object.assign({}, tooltip_styles_common), { borderRadius: borderRadius, boxShadow: boxShadow2, color: 'rgba(0, 0, 0, .85)', textColor: baseColor });
};
const tooltipLight = createTheme({
    name: 'Tooltip',
    common: light,
    peers: {
        Popover: popover_styles_light
    },
    self: tooltip_styles_light_self
});
/* harmony default export */ var tooltip_styles_light = (tooltipLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/tooltip/src/Tooltip.js
// Tooltip: popover wearing waistcoat





const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), use_theme.props);
/* harmony default export */ var Tooltip = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Tooltip',
    props: tooltipProps,
    __popover__: true,
    setup(props) {
        const themeRef = use_theme('Tooltip', 'Tooltip', undefined, tooltip_styles_light, props);
        const popoverRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const tooltipExposedMethod = {
            syncPosition() {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                popoverRef.value.syncPosition();
            },
            setShow(show) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                popoverRef.value.setShow(show);
            }
        };
        return Object.assign(Object.assign({}, tooltipExposedMethod), { popoverRef, mergedTheme: themeRef, popoverThemeOverrides: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                return themeRef.value.self;
            }) });
    },
    render() {
        const { mergedTheme, internalExtraClass } = this;
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Popover, Object.assign(Object.assign({}, this.$props), { theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, builtinThemeOverrides: this.popoverThemeOverrides, internalExtraClass: internalExtraClass.concat('tooltip'), ref: 'popoverRef' }), this.$slots);
    }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/DataBarVertical24Filled.js

const _hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 24 24'
}
const _hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M5.75 3a2.25 2.25 0 0 1 2.248 2.25v13.5a2.25 2.25 0 1 1-4.498 0V5.25A2.25 2.25 0 0 1 5.75 3zm6.5 4a2.25 2.25 0 0 1 2.248 2.25v9.5a2.25 2.25 0 1 1-4.498 0v-9.5A2.25 2.25 0 0 1 12.25 7zm6.5 4a2.25 2.25 0 0 1 2.248 2.25v5.5a2.25 2.25 0 1 1-4.498 0v-5.5A2.249 2.249 0 0 1 18.75 11z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var DataBarVertical24Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'DataBarVertical24Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', _hoisted_1, [_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/Edit16Filled.js

const Edit16Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 16 16'
}
const Edit16Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M12.242 6.586L6.27 12.559a2.5 2.5 0 0 1-1.161.657l-2.291.573a.5.5 0 0 1-.607-.607l.573-2.29a2.5 2.5 0 0 1 .658-1.162l5.971-5.973l2.829 2.829zm1.415-4.242a2 2 0 0 1 0 2.828l-.708.706L10.12 3.05l.708-.706a2 2 0 0 1 2.829 0z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var Edit16Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Edit16Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', Edit16Filled_hoisted_1, [Edit16Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/DataBarVerticalAdd24Filled.js

const DataBarVerticalAdd24Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 24 24'
}
const DataBarVerticalAdd24Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M14.504 4.752a2.752 2.752 0 1 0-5.504 0V19.25a2.752 2.752 0 0 0 3.667 2.597a6.5 6.5 0 0 1 1.837-10.116V4.75z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M21.504 12.38A6.52 6.52 0 0 0 16 11.175V9.751a2.752 2.752 0 0 1 5.504 0v2.628z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M4.752 12a2.752 2.752 0 0 1 2.752 2.752v4.498a2.752 2.752 0 0 1-5.504 0v-4.498A2.752 2.752 0 0 1 4.752 12z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M23 17.5a5.5 5.5 0 1 0-11 0a5.5 5.5 0 0 0 11 0zm-5 .5l.001 2.504a.5.5 0 1 1-1 0V18h-2.505a.5.5 0 0 1 0-1H17v-2.5a.5.5 0 1 1 1 0V17h2.503a.5.5 0 1 1 0 1h-2.502z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var DataBarVerticalAdd24Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'DataBarVerticalAdd24Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', DataBarVerticalAdd24Filled_hoisted_1, [DataBarVerticalAdd24Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/Link16Filled.js

const Link16Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 16 16'
}
const Link16Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M9.75 4h.516A3.742 3.742 0 0 1 14 7.75c0 2.003-1.565 3.641-3.53 3.745l-.197.005l-.516.005a.75.75 0 0 1-.115-1.493l.101-.007l.523-.005A2.242 2.242 0 0 0 12.5 7.75c0-1.192-.92-2.166-2.081-2.245l-.153-.005H9.75a.75.75 0 0 1-.102-1.493L9.75 4h.516h-.516zM5.752 4h.498a.75.75 0 0 1 .102 1.493L6.25 5.5h-.498a2.252 2.252 0 0 0-.154 4.5l.154.005h.498a.75.75 0 0 1 .102 1.493l-.102.007h-.498a3.752 3.752 0 0 1-.199-7.5l.2-.005h.497h-.498zM5.75 7h4.5a.75.75 0 0 1 .102 1.493l-.102.007h-4.5a.75.75 0 0 1-.102-1.493L5.75 7h4.5h-4.5z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var Link16Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Link16Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', Link16Filled_hoisted_1, [Link16Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./src/helpers/functions.ts



function injectStrict(key, fallback) {
  var resolved = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(key, fallback);

  if (!resolved) {
    throw new Error("Could not resolve ".concat(key.description));
  }

  return resolved;
}
// CONCATENATED MODULE: ./src/components/Table.tsx






















function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(s);
}

var Table = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TABLE',
  emits: ['openModal'],
  props: {
    table: {
      type: Object,
      required: true
    },
    selects: {
      type: Array,
      required: true
    }
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props),
        table = _toRefs.table;

    var relations = [].concat(toConsumableArray_toConsumableArray(table.value.relations.map(function (v) {
      return v.local_key;
    })), ["id"]);
    var relationables = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
    var dom = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])();
    var jsplumb = injectStrict(JsPlumbKey);

    var conectRelations = function conectRelations() {
      ready(function () {
        jsplumb.value.batch(function () {
          var _iterator = _createForOfIteratorHelper(table.value.relations),
              _step;

          try {
            var _loop = function _loop() {
              var relation = _step.value;
              var model = props.selects.find(function (v) {
                return v.value == relation.related_model;
              });

              if (model) {
                var sourceUuid = table.value.name + '.' + relation.local_key;
                var targetUuid = model.key + '.' + relation.related_key;
                jsplumb.value.connect({
                  uuids: [sourceUuid, targetUuid]
                });
              }
            };

            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        });
      });
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      ready(function () {
        jsplumb.value.batch(function () {
          jsplumb.value.manage(dom.value.$el);

          var _loop2 = function _loop2(key) {
            var elementNode = relationables.value[key];
            var uuid = table.value.name + '.' + key;
            var endpoint = jsplumb.value.addEndpoint(elementNode, {
              anchor: AnchorLocations.ContinuousLeftRight,
              target: true,
              source: true
            }, {
              uuid: uuid,
              maxConnections: -1,
              paintStyle: {
                stroke: 'white',
                strokeWidth: 2
              },
              connectorStyle: {
                strokeWidth: 2,
                outlineStroke: "white",
                outlineWidth: 1
              },
              connectorOverlays: [{
                type: 'Label',
                options: {
                  id: 'label',
                  cssClass: 'jtk-relationship-name'
                }
              }]
            });
            endpoint.setData({
              relations: table.value.relations.filter(function (v) {
                return v.local_key == key;
              }),
              name: table.value.name,
              classname: table.value.classname
            });
          };

          for (var key in relationables.value) {
            _loop2(key);
          }
        });
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUpdate"])(function () {
      relationables.value = {};
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      ready(function () {
        jsplumb.value.batch(function () {
          jsplumb.value.deleteConnectionsForElement(dom.value.$el);
          jsplumb.value.removeAllEndpoints(dom.value.$el, true);
        });
      });
    });
    var columns = [{
      title: "Columna",
      key: "field",
      render: function render(row) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
          "ref": function ref(el) {
            if (el && relations.includes(row.field)) {
              Object.assign(relationables.value, defineProperty_defineProperty({}, row.field, el));
            }
          }
        }, [row.field, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
          "style": "font-size: 10px;color: gray;text-transform: uppercase;"
        }, [row.type.split(' ')[0]])]);
      }
    }];
    return function () {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Card, {
        "ref": dom,
        "class": "table draggable",
        "title": table.value.name,
        "size": "small",
        "hoverable": true,
        "segmented": {
          footer: 'soft',
          content: 'soft'
        },
        "content-style": "padding: 0; margin: 0;"
      }, {
        header: function header() {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
            "style": {
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              flexDirection: 'column'
            }
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", null, [table.value.name]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
            "style": {
              fontSize: '13px'
            }
          }, [table.value.classname])]);
        },
        default: function _default() {
          var _slot;

          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(CheckboxGroup, {
            'value': table.value.filter.columns,
            "onUpdate:value": function onUpdateValue($event) {
              return table.value.filter.columns = $event;
            }
          }, {
            default: function _default() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Space, {
                "vertical": true
              }, _isSlot(_slot = table.value.columns.map(function (c, i) {
                return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
                  "ref": function ref(refa) {
                    if (refa && relations.includes(c.field)) {
                      Object.assign(relationables.value, defineProperty_defineProperty({}, c.field, refa));
                    }
                  },
                  "style": {
                    padding: '0 10px',
                    width: '100%',
                    display: 'flex'
                  },
                  "key": i
                }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Checkbox, {
                  "value": c.field
                }, {
                  default: function _default() {
                    return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", null, [c.field]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                      "style": "font-size: 10px;color: gray;text-transform: uppercase;margin-left:10px;"
                    }, [c.type.split(' ')[0]])];
                  }
                })]);
              })) ? _slot : {
                default: function _default() {
                  return [_slot];
                }
              })];
            }
          })]);
        },
        footer: function footer() {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", null, [table.value.filter.methods.map(function (f, i) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Space, {
              "justify": "space-between"
            }, {
              default: function _default() {
                return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("p", {
                  "style": "margin: 0px;gap: 10px;display: flex;align-items: center;"
                }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                  default: function _default() {
                    return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(DataBarVertical24Filled, null, null)];
                  }
                }), f.name]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                  "text": true,
                  "size": "large",
                  "onClick": function onClick() {
                    emit('openModal', table.value.name, i);
                  }
                }, {
                  icon: function icon() {
                    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                      default: function _default() {
                        return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Edit16Filled, null, null)];
                      }
                    });
                  }
                })];
              }
            });
          })])]);
        },
        action: function action() {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tooltip, {
            "trigger": "hover"
          }, {
            default: function _default() {
              return 'Agregar Filtros';
            },
            trigger: function trigger() {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                "text": true,
                "size": "large",
                "onClick": function onClick() {
                  return emit('openModal', table.value.name);
                }
              }, {
                icon: function icon() {
                  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(DataBarVerticalAdd24Filled, null, null)];
                    }
                  });
                }
              });
            }
          }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Tooltip, {
            "trigger": "hover"
          }, {
            default: function _default() {
              return 'Autoconectar';
            },
            trigger: function trigger() {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                "text": true,
                "size": "large",
                "onClick": conectRelations
              }, {
                icon: function icon() {
                  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Link16Filled, null, null)];
                    }
                  });
                }
              });
            }
          })]);
        }
      })]);
    };
  }
});

// CONCATENATED MODULE: ./node_modules/vooks/es/use-clicked.js



const clickedTimeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
let usedCount = 0;
function use_clicked_handleClick() {
    clickedTimeRef.value = Date.now();
}
let managable = true;
function useClicked(timeout) {
    if (!isBrowser)
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false));
    const clickedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    let timerId = null;
    function clearTimer() {
        if (timerId !== null)
            window.clearTimeout(timerId);
    }
    function clickedHandler() {
        clearTimer();
        clickedRef.value = true;
        timerId = window.setTimeout(() => {
            clickedRef.value = false;
        }, timeout);
    }
    if (usedCount === 0) {
        delegate_on('click', window, use_clicked_handleClick, true);
    }
    const setup = () => {
        usedCount += 1;
        delegate_on('click', window, clickedHandler, true);
    };
    if (managable && (managable = hasInstance())) {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(setup);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            usedCount -= 1;
            if (usedCount === 0) {
                delegate_off('click', window, use_clicked_handleClick, true);
            }
            delegate_off('click', window, clickedHandler, true);
            clearTimer();
        });
    }
    else {
        setup();
    }
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(clickedRef);
}

// CONCATENATED MODULE: ./node_modules/vooks/es/use-click-position.js



const mousePositionRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
function clickHandler(e) {
    mousePositionRef.value = {
        x: e.clientX,
        y: e.clientY
    };
}
let use_click_position_usedCount = 0;
let use_click_position_managable = true;
function useClickPosition() {
    if (!isBrowser)
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null));
    if (use_click_position_usedCount === 0)
        delegate_on('click', window, clickHandler, true);
    const setup = () => {
        use_click_position_usedCount += 1;
    };
    if (use_click_position_managable && (use_click_position_managable = hasInstance())) {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(setup);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            use_click_position_usedCount -= 1;
            if (use_click_position_usedCount === 0)
                delegate_off('click', window, clickHandler, true);
        });
    }
    else {
        setup();
    }
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["readonly"])(mousePositionRef);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/omit.js
function omit(object, keys = [], rest) {
    const omitedObject = {};
    const originalKeys = Object.getOwnPropertyNames(object);
    originalKeys.forEach((originalKey) => {
        if (!keys.includes(originalKey)) {
            omitedObject[originalKey] = object[originalKey];
        }
    });
    return Object.assign(omitedObject, rest);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/vue/render.js

const vue_render_render = (r, ...args) => {
    if (typeof r === 'function') {
        return r(...args);
    }
    else if (typeof r === 'string') {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(r);
    }
    else if (typeof r === 'number') {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(String(r));
    }
    else {
        return null;
    }
};

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Info.js


/* harmony default export */ var Info = (replaceable('info', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { "fill-rule": "nonzero" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z" }))))));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Success.js


/* harmony default export */ var Success = (replaceable('success', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { "fill-rule": "nonzero" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z" }))))));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Warning.js


/* harmony default export */ var Warning = (replaceable('warning', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { "fill-rule": "nonzero" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z" }))))));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Error.js


/* harmony default export */ var icons_Error = (replaceable('error', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { "fill-rule": "nonzero" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z" }))))));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dialog/styles/_common.js
/* harmony default export */ var dialog_styles_common = ({
    titleFontSize: '18px',
    padding: '16px 28px 20px 28px',
    iconSize: '28px',
    actionSpace: '12px',
    contentMargin: '8px 0 16px 0',
    iconMargin: '0 4px 0 0',
    iconMarginIconTop: '4px 0 8px 0',
    closeSize: '18px',
    closeMargin: '22px 28px 0 0',
    closeMarginIconTop: '12px 18px 0 0'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dialog/styles/light.js




const dialog_styles_light_self = (vars) => {
    const { textColor1, textColor2, modalColor, closeColor, closeColorHover, closeColorPressed, infoColor, successColor, warningColor, errorColor, primaryColor, dividerColor, borderRadius, fontWeightStrong, lineHeight, fontSize } = vars;
    return Object.assign(Object.assign({}, dialog_styles_common), { fontSize,
        lineHeight, border: `1px solid ${dividerColor}`, titleTextColor: textColor1, textColor: textColor2, color: modalColor, closeColor: closeColor, closeColorHover: closeColorHover, closeColorPressed: closeColorPressed, iconColor: primaryColor, iconColorInfo: infoColor, iconColorSuccess: successColor, iconColorWarning: warningColor, iconColorError: errorColor, borderRadius, titleFontWeight: fontWeightStrong });
};
const dialogLight = createTheme({
    name: 'Dialog',
    common: light,
    peers: {
        Button: button_styles_light
    },
    self: dialog_styles_light_self
});
/* harmony default export */ var dialog_styles_light = (dialogLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dialog/src/styles/index.cssr.js
 // vars:
// --icon-color
// --bezier
// --close-margin
// --icon-margin
// --icon-size
// --close-size
// --close-color
// --close-color-hover
// --close-color-pressed
// --color
// --text-color
// --border-radius
// --padding
// --line-height
// --border
// --content-margin
// --title-font-size
// --title-font-weight
// --title-text-color
// --action-space

/* harmony default export */ var dialog_src_styles_index_cssr = (cssr_c([cB('dialog', `
 line-height: var(--line-height);
 position: relative;
 background: var(--color);
 color: var(--text-color);
 box-sizing: border-box;
 margin: auto;
 border-radius: var(--border-radius);
 padding: var(--padding);
 transition: 
 border-color .3s var(--bezier),
 background-color .3s var(--bezier),
 color .3s var(--bezier);
 `, [cE('icon', {
  color: 'var(--icon-color)'
}), cM('bordered', {
  border: 'var(--border)'
}), cM('icon-top', [cE('close', {
  margin: 'var(--close-margin)'
}), cE('icon', {
  margin: 'var(--icon-margin)'
}), cE('content', {
  textAlign: 'center'
}), cE('title', {
  justifyContent: 'center'
}), cE('action', {
  justifyContent: 'center'
})]), cM('icon-left', [cE('icon', {
  margin: 'var(--icon-margin)'
})]), cE('close', `
 font-size: var(--close-size);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--close-margin);
 transition: .3s color var(--bezier);
 z-index: 1;
 `), cE('content', `
 font-size: var(--font-size);
 margin: var(--content-margin);
 position: relative;
 `, [cssr_c('&:last-child', 'margin-bottom: 0;')]), cE('action', `
 display: flex;
 justify-content: flex-end;
 `, [cssr_c('> *:not(:last-child)', {
  marginRight: 'var(--action-space)'
})]), cE('icon', {
  fontSize: 'var(--icon-size)',
  transition: 'color .3s var(--bezier)'
}), cE('title', `
 transition: color .3s var(--bezier);
 display: flex;
 align-items: center;
 font-size: var(--title-font-size);
 font-weight: var(--title-font-weight);
 color: var(--title-text-color);
 `), cB('dialog-icon-container', {
  display: 'flex',
  justifyContent: 'center'
})]), insideModal(cB('dialog', `
 width: 446px;
 max-width: calc(100vw - 32px);
 `)), cB('dialog', [asModal(`
 width: 446px;
 max-width: calc(100vw - 32px);
 `)])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/dialog/src/Dialog.js








const infoIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Info, null);
const iconMap = {
    default: infoIcon,
    info: infoIcon,
    success: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Success, null),
    warning: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Warning, null),
    error: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(icons_Error, null)
};
const dialogProps = {
    icon: Function,
    type: {
        type: String,
        default: 'default'
    },
    title: [String, Function],
    closable: {
        type: Boolean,
        default: true
    },
    negativeText: String,
    positiveText: String,
    content: [String, Function],
    action: Function,
    showIcon: {
        type: Boolean,
        default: true
    },
    loading: Boolean,
    bordered: Boolean,
    iconPlacement: String,
    onPositiveClick: Function,
    onNegativeClick: Function,
    onClose: Function
};

const dialogPropKeys = keysOf(dialogProps);
/* harmony default export */ var Dialog = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Dialog',
    alias: [
        'NimbusConfirmCard',
        'Confirm' // deprecated
    ],
    props: Object.assign(Object.assign({}, use_theme.props), dialogProps),
    setup(props) {
        const { NConfigProvider, mergedClsPrefixRef } = useConfig(props);
        const mergedIconPlacementRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            var _a, _b, _c;
            const { iconPlacement } = props;
            return ((_c = iconPlacement !== null && iconPlacement !== void 0 ? iconPlacement : (_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Dialog) === null || _b === void 0 ? void 0 : _b.iconPlacement) !== null && _c !== void 0 ? _c : 'left');
        });
        function handlePositiveClick(e) {
            const { onPositiveClick } = props;
            if (onPositiveClick)
                onPositiveClick(e);
        }
        function handleNegativeClick(e) {
            const { onNegativeClick } = props;
            if (onNegativeClick)
                onNegativeClick(e);
        }
        function handleCloseClick() {
            const { onClose } = props;
            if (onClose)
                onClose();
        }
        const themeRef = use_theme('Dialog', 'Dialog', dialog_src_styles_index_cssr, dialog_styles_light, props, mergedClsPrefixRef);
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedIconPlacement: mergedIconPlacementRef,
            mergedTheme: themeRef,
            handlePositiveClick,
            handleNegativeClick,
            handleCloseClick,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { type, iconPlacement } = props;
                const { common: { cubicBezierEaseInOut }, self: { fontSize, lineHeight, border, titleTextColor, textColor, color, closeColor, closeColorHover, closeColorPressed, borderRadius, titleFontWeight, titleFontSize, padding, iconSize, actionSpace, contentMargin, closeSize, [iconPlacement === 'top' ? 'iconMarginIconTop' : 'iconMargin']: iconMargin, [iconPlacement === 'top' ? 'closeMarginIconTop' : 'closeMargin']: closeMargin, [createKey('iconColor', type)]: iconColor } } = themeRef.value;
                return {
                    '--font-size': fontSize,
                    '--icon-color': iconColor,
                    '--bezier': cubicBezierEaseInOut,
                    '--close-margin': closeMargin,
                    '--icon-margin': iconMargin,
                    '--icon-size': iconSize,
                    '--close-size': closeSize,
                    '--close-color': closeColor,
                    '--close-color-hover': closeColorHover,
                    '--close-color-pressed': closeColorPressed,
                    '--color': color,
                    '--text-color': textColor,
                    '--border-radius': borderRadius,
                    '--padding': padding,
                    '--line-height': lineHeight,
                    '--border': border,
                    '--content-margin': contentMargin,
                    '--title-font-size': titleFontSize,
                    '--title-font-weight': titleFontWeight,
                    '--title-text-color': titleTextColor,
                    '--action-space': actionSpace
                };
            })
        };
    },
    render() {
        const { $slots, bordered, mergedIconPlacement, cssVars, closable, showIcon, title, content, action, negativeText, positiveText, handlePositiveClick, handleNegativeClick, mergedTheme, loading, type, mergedClsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                `${mergedClsPrefix}-dialog`,
                `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`,
                bordered && `${mergedClsPrefix}-dialog--bordered`
            ], style: cssVars },
            closable ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Close, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__close`, onClick: this.handleCloseClick })) : null,
            showIcon && mergedIconPlacement === 'top' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-dialog-icon-container` },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__icon` }, {
                    default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'icon', undefined, () => [
                        this.icon ? vue_render_render(this.icon) : iconMap[this.type]
                    ])
                }))) : null,
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-dialog__title` },
                showIcon && mergedIconPlacement === 'left' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__icon` }, {
                    default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'icon', undefined, () => [
                        this.icon ? vue_render_render(this.icon) : iconMap[this.type]
                    ])
                })) : null,
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'header', undefined, () => [vue_render_render(title)])),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-dialog__content` }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'default', undefined, () => [vue_render_render(content)])),
            $slots.action || positiveText || negativeText || action ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-dialog__action` }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'action', undefined, action
                ? () => [vue_render_render(action)]
                : () => [
                    this.negativeText && (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Button, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, ghost: true, size: "small", onClick: handleNegativeClick }, {
                        default: () => vue_render_render(this.negativeText)
                    })),
                    this.positiveText && (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Button, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, disabled: loading, loading: loading, size: "small", type: type === 'default' ? 'primary' : type, onClick: handlePositiveClick }, {
                        default: () => vue_render_render(this.positiveText)
                    }))
                ]))) : null));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dialog/src/DialogEnvironment.js
// use absolute path to make sure no circular ref of style
// this -> modal-index -> modal-style




const exposedDialogEnvProps = Object.assign(Object.assign({}, dialogProps), { internalStyle: [String, Object], maskClosable: {
        type: Boolean,
        default: true
    }, onPositiveClick: Function, onNegativeClick: Function, onClose: Function, onMaskClick: Function });
/* harmony default export */ var DialogEnvironment = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'DialogEnvironment',
    props: Object.assign(Object.assign({}, exposedDialogEnvProps), { internalKey: {
            type: String,
            required: true
        }, to: [String, Object], 
        // private
        onInternalAfterLeave: {
            type: Function,
            required: true
        } }),
    setup(props) {
        const showRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(true);
        function handleAfterLeave() {
            props.onInternalAfterLeave(props.internalKey);
        }
        function handlePositiveClick(e) {
            const { onPositiveClick } = props;
            if (onPositiveClick) {
                void Promise.resolve(onPositiveClick(e)).then((result) => {
                    if (result === false)
                        return;
                    hide();
                });
            }
            else {
                hide();
            }
        }
        function handleNegativeClick(e) {
            const { onNegativeClick } = props;
            if (onNegativeClick) {
                void Promise.resolve(onNegativeClick(e)).then((result) => {
                    if (result === false)
                        return;
                    hide();
                });
            }
            else {
                hide();
            }
        }
        function handleCloseClick() {
            const { onClose } = props;
            if (onClose) {
                void Promise.resolve(onClose()).then((result) => {
                    if (result === false)
                        return;
                    hide();
                });
            }
            else {
                hide();
            }
        }
        function handleMaskClick(e) {
            const { onMaskClick, maskClosable } = props;
            if (onMaskClick) {
                onMaskClick(e);
                maskClosable && hide();
            }
        }
        function hide() {
            showRef.value = false;
        }
        function handleUpdateShow(value) {
            showRef.value = value;
        }
        return {
            show: showRef,
            hide,
            handleUpdateShow,
            handleAfterLeave,
            handleCloseClick,
            handleNegativeClick,
            handlePositiveClick,
            handleMaskClick
        };
    },
    render() {
        const { handlePositiveClick, handleUpdateShow, handleNegativeClick, handleCloseClick, handleAfterLeave, handleMaskClick, to, maskClosable, show } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Modal, { show: show, onUpdateShow: handleUpdateShow, onMaskClick: handleMaskClick, appear: true, dialog: true, to: to, maskClosable: maskClosable, onAfterLeave: handleAfterLeave }, {
            default: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Dialog, Object.assign({}, keep(this.$props, dialogPropKeys), { style: this.internalStyle, onClose: handleCloseClick, onNegativeClick: handleNegativeClick, onPositiveClick: handlePositiveClick })))
        }));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dialog/src/DialogProvider.js





const dialogApiInjectionKey = Symbol('dialogApi');
const dialogProviderInjectionKey = Symbol('dialogProvider');
const dialogProviderProps = {
    injectionKey: String,
    to: [String, Object]
};
/* harmony default export */ var DialogProvider = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'DialogProvider',
    props: dialogProviderProps,
    setup() {
        const dialogListRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
        const dialogInstRefs = {};
        function create(options = {}) {
            const key = createId();
            const dialogReactive = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])(Object.assign(Object.assign({}, options), { key, destroy: () => {
                    dialogInstRefs[`n-dialog-${key}`].hide();
                } }));
            dialogListRef.value.push(dialogReactive);
            return dialogReactive;
        }
        const typedApi = ['info', 'success', 'warning', 'error'].map((type) => (options) => {
            return create(Object.assign(Object.assign({}, options), { type }));
        });
        function handleAfterLeave(key) {
            const { value: dialogList } = dialogListRef;
            dialogList.splice(dialogList.findIndex((dialog) => dialog.key === key), 1);
        }
        function destroyAll() {
            Object.values(dialogInstRefs).forEach((dialogInstRef) => dialogInstRef.hide());
        }
        const api = {
            create,
            destroyAll,
            info: typedApi[0],
            success: typedApi[1],
            warning: typedApi[2],
            error: typedApi[3]
        };
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(dialogApiInjectionKey, api);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(dialogProviderInjectionKey, {
            clickedRef: useClicked(64),
            clickPositionRef: useClickPosition()
        });
        return Object.assign(Object.assign({}, api), { dialogList: dialogListRef, dialogInstRefs,
            handleAfterLeave });
    },
    render() {
        var _a, _b;
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, [
            this.dialogList.map((dialog) => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(DialogEnvironment, omit(dialog, ['destroy', 'style'], {
                internalStyle: dialog.style,
                to: this.to,
                ref: ((inst) => {
                    if (inst === null) {
                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                        delete this.dialogInstRefs[`n-dialog-${dialog.key}`];
                    }
                    else {
                        this.dialogInstRefs[`n-dialog-${dialog.key}`] = inst;
                    }
                }),
                internalKey: dialog.key,
                onInternalAfterLeave: this.handleAfterLeave
            }))),
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)
        ]);
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/scrollbar/styles/light.js

const scrollbar_styles_light_self = (vars) => {
    const { scrollbarColor, scrollbarColorHover } = vars;
    return {
        color: scrollbarColor,
        colorHover: scrollbarColorHover
    };
};
const scrollbarLight = {
    name: 'Scrollbar',
    common: light,
    self: scrollbar_styles_light_self
};
/* harmony default export */ var scrollbar_styles_light = (scrollbarLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/modal/styles/light.js





const modal_styles_light_self = (vars) => {
    const { modalColor, textColor2, boxShadow3 } = vars;
    return {
        color: modalColor,
        textColor: textColor2,
        boxShadow: boxShadow3
    };
};
const modalLight = createTheme({
    name: 'Modal',
    common: light,
    peers: {
        Scrollbar: scrollbar_styles_light,
        Dialog: dialog_styles_light,
        Card: styles_light
    },
    self: modal_styles_light_self
});
/* harmony default export */ var modal_styles_light = (modalLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/modal/src/presetProps.js



const presetProps = Object.assign(Object.assign({}, cardBaseProps), dialogProps);
const presetPropsKeys = keysOf(presetProps);


// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__("6dd8");

// CONCATENATED MODULE: ./node_modules/vueuc/es/resize-observer/src/delegate.js

class delegate_ResizeObserverDelegate {
    constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new ResizeObserver_es["a" /* default */](this.handleResize);
        this.elHandlersMap = new Map();
    }
    handleResize(entries) {
        for (const entry of entries) {
            const handler = this.elHandlersMap.get(entry.target);
            if (handler !== undefined) {
                handler(entry);
            }
        }
    }
    registerHandler(el, handler) {
        this.elHandlersMap.set(el, handler);
        this.observer.observe(el);
    }
    unregisterHandler(el) {
        if (!this.elHandlersMap.has(el)) {
            return;
        }
        this.elHandlersMap.delete(el);
        this.observer.unobserve(el);
    }
}
/* harmony default export */ var delegate = (new delegate_ResizeObserverDelegate());

// CONCATENATED MODULE: ./node_modules/vueuc/es/shared/warn.js
function warn_warn(location, message) {
    console.error(`[vueuc/${location}]: ${message}`);
}

// CONCATENATED MODULE: ./node_modules/vueuc/es/resize-observer/src/VResizeObserver.js



/* harmony default export */ var VResizeObserver = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'ResizeObserver',
    props: {
        onResize: Function
    },
    setup(props) {
        return {
            registered: false,
            handleResize(entry) {
                const { onResize } = props;
                if (onResize !== undefined)
                    onResize(entry);
            }
        };
    },
    mounted() {
        const el = this.$el;
        if (el === undefined) {
            warn_warn('resize-observer', '$el does not exist.');
        }
        else if (el.nextElementSibling !== el.nextSibling) {
            warn_warn('resize-observer', '$el can not be observed (it may be a text node).');
        }
        else if (el.nextElementSibling !== null) {
            delegate.registerHandler(el.nextElementSibling, this.handleResize);
            this.registered = true;
        }
    },
    beforeUnmount() {
        if (this.registered) {
            delegate.unregisterHandler(this.$el.nextElementSibling);
        }
    },
    render() {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'default');
    }
}));

// CONCATENATED MODULE: ./node_modules/vooks/es/use-is-ios.js
const use_is_ios_isIos = (typeof window === 'undefined'
    ? false
    : /iPad|iPhone|iPod/.test(navigator.platform) ||
        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
function useIsIos() {
    return use_is_ios_isIos;
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/transitions/fade-in.cssr.js


const {
  cubicBezierEaseInOut: fade_in_cssr_cubicBezierEaseInOut
} = _common;
/* harmony default export */ var fade_in_cssr = (function ({
  name = 'fade-in',
  enterDuration = '0.2s',
  leaveDuration = '0.2s',
  enterCubicBezier = fade_in_cssr_cubicBezierEaseInOut,
  leaveCubicBezier = fade_in_cssr_cubicBezierEaseInOut
} = {}) {
  return [cssr_c(`&.${name}-transition-enter-active`, {
    transition: `all ${enterDuration} ${enterCubicBezier}!important`
  }), cssr_c(`&.${name}-transition-leave-active`, {
    transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
  }), cssr_c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
    opacity: 0
  }), cssr_c(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
    opacity: 1
  })];
});
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/scrollbar/src/styles/index.cssr.js

 // vars:
// --scrollbar-bezier
// --scrollbar-color
// --scrollbar-color-hover
// --scrollbar-width
// --scrollbar-height
// --scrollbar-border-radius

/* harmony default export */ var scrollbar_src_styles_index_cssr = (cB('scrollbar', `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [cssr_c('>', [cB('scrollbar-container', `
 width: 100%;
 overflow: scroll;
 height: 100%;
 max-height: inherit;
 scrollbar-width: none;
 `, [cssr_c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', `
 width: 0;
 height: 0;
 display: none;
 `), cssr_c('>', [cB('scrollbar-content', `
 box-sizing: border-box;
 min-width: 100%;
 `)])]), cB('scrollbar-rail', `
 position: absolute;
 pointer-events: none;
 user-select: none;
 `, [cM('horizontal', `
 left: 2px;
 right: 2px;
 bottom: 4px;
 height: var(--scrollbar-height);
 `, [cssr_c('>', [cE('scrollbar', `
 height: var(--scrollbar-height);
 border-radius: var(--scrollbar-border-radius);
 right: 0;
 `)])]), cM('vertical', `
 right: 4px;
 top: 2px;
 bottom: 2px;
 width: var(--scrollbar-width);
 `, [cssr_c('>', [cE('scrollbar', `
 width: var(--scrollbar-width);
 border-radius: var(--scrollbar-border-radius);
 bottom: 0;
 `)])]), cM('disabled', [cssr_c('>', [cE('scrollbar', {
  pointerEvents: 'none'
})])]), cssr_c('>', [cE('scrollbar', `
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--scrollbar-color);
 transition: background-color .2s var(--scrollbar-bezier);
 `, [fade_in_cssr(), cssr_c('&:hover', {
  backgroundColor: 'var(--scrollbar-color-hover)'
})])])])])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/scrollbar/src/ScrollBar.js







const scrollbarProps = Object.assign(Object.assign({}, use_theme.props), { size: {
        type: Number,
        default: 5
    }, duration: {
        type: Number,
        default: 0
    }, scrollable: {
        type: Boolean,
        default: true
    }, xScrollable: {
        type: Boolean,
        default: false
    }, 
    // If container is set, resize observer won't not attached
    container: Function, content: Function, containerStyle: [String, Object], contentClass: String, contentStyle: [String, Object], horizontalRailStyle: [String, Object], verticalRailStyle: [String, Object], onScroll: Function, onWheel: Function, onResize: Function, internalOnUpdateScrollLeft: Function });
const Scrollbar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Scrollbar',
    props: scrollbarProps,
    inheritAttrs: false,
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        // dom ref
        const containerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const contentRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const yRailRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const xRailRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        // data ref
        const contentHeightRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const contentWidthRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const containerHeightRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const containerWidthRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const yRailSizeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const xRailSizeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const containerScrollTopRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
        const containerScrollLeftRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
        const isShowXBarRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        const isShowYBarRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos = useIsIos();
        const yBarSizeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: containerHeight } = containerHeightRef;
            const { value: contentHeight } = contentHeightRef;
            const { value: yRailSize } = yRailSizeRef;
            if (containerHeight === null ||
                contentHeight === null ||
                yRailSize === null) {
                return 0;
            }
            else {
                return Math.min(containerHeight, (yRailSize * containerHeight) / contentHeight + props.size * 1.5);
            }
        });
        const yBarSizePxRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: containerWidth } = containerWidthRef;
            const { value: contentWidth } = contentWidthRef;
            const { value: xRailSize } = xRailSizeRef;
            if (containerWidth === null ||
                contentWidth === null ||
                xRailSize === null) {
                return 0;
            }
            else {
                return (xRailSize * containerWidth) / contentWidth + props.size * 1.5;
            }
        });
        const xBarSizePxRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: containerHeight } = containerHeightRef;
            const { value: containerScrollTop } = containerScrollTopRef;
            const { value: contentHeight } = contentHeightRef;
            const { value: yRailSize } = yRailSizeRef;
            if (containerHeight === null ||
                contentHeight === null ||
                yRailSize === null) {
                return 0;
            }
            else {
                return ((containerScrollTop / (contentHeight - containerHeight)) *
                    (yRailSize - yBarSizeRef.value));
            }
        });
        const yBarTopPxRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: containerWidth } = containerWidthRef;
            const { value: containerScrollLeft } = containerScrollLeftRef;
            const { value: contentWidth } = contentWidthRef;
            const { value: xRailSize } = xRailSizeRef;
            if (containerWidth === null ||
                contentWidth === null ||
                xRailSize === null) {
                return 0;
            }
            else {
                return ((containerScrollLeft / (contentWidth - containerWidth)) *
                    (xRailSize - xBarSizeRef.value));
            }
        });
        const xBarLeftPxRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: containerHeight } = containerHeightRef;
            const { value: contentHeight } = contentHeightRef;
            return (containerHeight !== null &&
                contentHeight !== null &&
                contentHeight > containerHeight);
        });
        const needXBarRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: containerWidth } = containerWidthRef;
            const { value: contentWidth } = contentWidthRef;
            return (containerWidth !== null &&
                contentWidth !== null &&
                contentWidth > containerWidth);
        });
        const mergedContainerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { container } = props;
            if (container)
                return container();
            return containerRef.value;
        });
        const mergedContentRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { content } = props;
            if (content)
                return content();
            return contentRef.value;
        });
        // methods
        const handleContentResize = sync;
        const handleContainerResize = (e) => {
            const { onResize } = props;
            if (onResize)
                onResize(e);
            sync();
        };
        const scrollTo = (options, y) => {
            if (!props.scrollable)
                return;
            if (typeof options === 'number') {
                scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, 'auto');
                return;
            }
            const { left, top, index, elSize, position, behavior, el, debounce = true } = options;
            if (left !== undefined || top !== undefined) {
                scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
            }
            if (el !== undefined) {
                scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce, behavior);
            }
            else if (index !== undefined && elSize !== undefined) {
                scrollToPosition(0, index * elSize, elSize, debounce, behavior);
            }
            else if (position === 'bottom') {
                scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
            }
            else if (position === 'top') {
                scrollToPosition(0, 0, 0, false, behavior);
            }
        };
        function scrollToPosition(left, top, elSize, debounce, behavior) {
            const { value: container } = mergedContainerRef;
            if (!container)
                return;
            if (debounce) {
                const { scrollTop, offsetHeight } = container;
                if (top > scrollTop) {
                    if (top + elSize <= scrollTop + offsetHeight) {
                        // do nothing
                    }
                    else {
                        container.scrollTo({
                            left,
                            top: top + elSize - offsetHeight,
                            behavior
                        });
                    }
                    return;
                }
            }
            container.scrollTo({
                left,
                top,
                behavior
            });
        }
        function handleMouseEnterWrapper() {
            showXBar();
            showYBar();
            sync();
        }
        function handleMouseLeaveWrapper() {
            hideBar();
        }
        function hideBar() {
            hideYBar();
            hideXBar();
        }
        function hideYBar() {
            if (yBarVanishTimerId !== undefined) {
                window.clearTimeout(yBarVanishTimerId);
            }
            yBarVanishTimerId = window.setTimeout(() => {
                isShowYBarRef.value = false;
            }, props.duration);
        }
        function hideXBar() {
            if (xBarVanishTimerId !== undefined) {
                window.clearTimeout(xBarVanishTimerId);
            }
            xBarVanishTimerId = window.setTimeout(() => {
                isShowXBarRef.value = false;
            }, props.duration);
        }
        function showXBar() {
            if (xBarVanishTimerId !== undefined) {
                window.clearTimeout(xBarVanishTimerId);
            }
            isShowXBarRef.value = true;
        }
        function showYBar() {
            if (yBarVanishTimerId !== undefined) {
                window.clearTimeout(yBarVanishTimerId);
            }
            isShowYBarRef.value = true;
        }
        function handleScroll(e) {
            const { onScroll } = props;
            if (onScroll)
                onScroll(e);
            syncScrollState();
        }
        function syncScrollState() {
            // only collect scroll state, do not trigger any dom event
            const { value: container } = mergedContainerRef;
            if (container) {
                containerScrollTopRef.value = container.scrollTop;
                containerScrollLeftRef.value = container.scrollLeft;
            }
        }
        function syncPositionState() {
            // only collect position state, do not trigger any dom event
            // Don't use getClientBoundingRect because element may be scale transformed
            const { value: content } = mergedContentRef;
            if (content) {
                contentHeightRef.value = content.offsetHeight;
                contentWidthRef.value = content.offsetWidth;
            }
            const { value: container } = mergedContainerRef;
            if (container) {
                containerHeightRef.value = container.offsetHeight;
                containerWidthRef.value = container.offsetWidth;
            }
            const { value: xRailEl } = xRailRef;
            const { value: yRailEl } = yRailRef;
            if (xRailEl) {
                xRailSizeRef.value = xRailEl.offsetWidth;
            }
            if (yRailEl) {
                yRailSizeRef.value = yRailEl.offsetHeight;
            }
        }
        function sync() {
            if (!props.scrollable)
                return;
            syncPositionState();
            syncScrollState();
        }
        function handleXScrollMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            xBarPressed = true;
            delegate_on('mousemove', window, handleXScrollMouseMove, true);
            delegate_on('mouseup', window, handleXScrollMouseUp, true);
            memoXLeft = containerScrollLeftRef.value;
            memoMouseX = e.clientX;
        }
        function handleXScrollMouseMove(e) {
            if (!xBarPressed)
                return;
            if (xBarVanishTimerId !== undefined) {
                window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== undefined) {
                window.clearTimeout(yBarVanishTimerId);
            }
            const { value: containerWidth } = containerWidthRef;
            const { value: contentWidth } = contentWidthRef;
            const { value: xBarSize } = xBarSizeRef;
            if (containerWidth === null || contentWidth === null)
                return;
            const dX = e.clientX - memoMouseX;
            const dScrollLeft = (dX * (contentWidth - containerWidth)) / (containerWidth - xBarSize);
            const toScrollLeftUpperBound = contentWidth - containerWidth;
            let toScrollLeft = memoXLeft + dScrollLeft;
            toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
            toScrollLeft = Math.max(toScrollLeft, 0);
            const { value: container } = mergedContainerRef;
            if (container) {
                container.scrollLeft = toScrollLeft;
                const { internalOnUpdateScrollLeft } = props;
                if (internalOnUpdateScrollLeft)
                    internalOnUpdateScrollLeft(toScrollLeft);
            }
        }
        function handleXScrollMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            delegate_off('mousemove', window, handleXScrollMouseMove, true);
            delegate_off('mouseup', window, handleXScrollMouseUp, true);
            xBarPressed = false;
            sync();
            const { value: container } = mergedContainerRef;
            if (!(container === null || container === void 0 ? void 0 : container.contains(e.target))) {
                hideBar();
            }
        }
        function handleYScrollMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            yBarPressed = true;
            delegate_on('mousemove', window, handleYScrollMouseMove, true);
            delegate_on('mouseup', window, handleYScrollMouseUp, true);
            memoYTop = containerScrollTopRef.value;
            memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
            if (!yBarPressed)
                return;
            if (xBarVanishTimerId !== undefined) {
                window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== undefined) {
                window.clearTimeout(yBarVanishTimerId);
            }
            const { value: containerHeight } = containerHeightRef;
            const { value: contentHeight } = contentHeightRef;
            const { value: yBarSize } = yBarSizeRef;
            if (containerHeight === null || contentHeight === null)
                return;
            const dY = e.clientY - memoMouseY;
            const dScrollTop = (dY * (contentHeight - containerHeight)) / (containerHeight - yBarSize);
            const toScrollTopUpperBound = contentHeight - containerHeight;
            let toScrollTop = memoYTop + dScrollTop;
            toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
            toScrollTop = Math.max(toScrollTop, 0);
            const { value: container } = mergedContainerRef;
            if (container) {
                container.scrollTop = toScrollTop;
            }
        }
        function handleYScrollMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            delegate_off('mousemove', window, handleYScrollMouseMove, true);
            delegate_off('mouseup', window, handleYScrollMouseUp, true);
            yBarPressed = false;
            sync();
            const { value: container } = mergedContainerRef;
            if (!(container === null || container === void 0 ? void 0 : container.contains(e.target))) {
                hideBar();
            }
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(() => {
            const { value: needXBar } = needXBarRef;
            const { value: needYBar } = needYBarRef;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            const { value: xRailEl } = xRailRef;
            const { value: yRailEl } = yRailRef;
            if (xRailEl) {
                if (!needXBar) {
                    xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                }
                else {
                    xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                }
            }
            if (yRailEl) {
                if (!needYBar) {
                    yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                }
                else {
                    yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                }
            }
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
            // if container exist, it always can't be resolved when scrollbar is mounted
            // for example:
            // - component
            //   - scrollbar
            //     - inner
            // if you pass inner to scrollbar, you may use a ref inside component
            // however, when scrollbar is mounted, ref is not ready at component
            // you need to init by yourself
            if (props.container)
                return;
            sync();
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            if (xBarVanishTimerId !== undefined) {
                window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== undefined) {
                window.clearTimeout(yBarVanishTimerId);
            }
            delegate_off('mousemove', window, handleYScrollMouseMove, true);
            delegate_off('mouseup', window, handleYScrollMouseUp, true);
        });
        const themeRef = use_theme('Scrollbar', 'Scrollbar', scrollbar_src_styles_index_cssr, scrollbar_styles_light, props, mergedClsPrefixRef);
        return {
            sync,
            scrollTo,
            mergedClsPrefix: mergedClsPrefixRef,
            containerScrollTop: containerScrollTopRef,
            containerRef,
            contentRef,
            yRailRef,
            xRailRef,
            needYBar: needYBarRef,
            needXBar: needXBarRef,
            yBarSizePx: yBarSizePxRef,
            xBarSizePx: xBarSizePxRef,
            yBarTopPx: yBarTopPxRef,
            xBarLeftPx: xBarLeftPxRef,
            isShowXBar: isShowXBarRef,
            isShowYBar: isShowYBarRef,
            isIos,
            handleScroll,
            handleContentResize,
            handleContainerResize,
            handleMouseEnterWrapper,
            handleMouseLeaveWrapper,
            handleYScrollMouseDown,
            handleXScrollMouseDown,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { common: { cubicBezierEaseInOut, scrollbarBorderRadius, scrollbarHeight, scrollbarWidth }, self: { color, colorHover } } = themeRef.value;
                return {
                    '--scrollbar-bezier': cubicBezierEaseInOut,
                    '--scrollbar-color': color,
                    '--scrollbar-color-hover': colorHover,
                    '--scrollbar-border-radius': scrollbarBorderRadius,
                    '--scrollbar-width': scrollbarWidth,
                    '--scrollbar-height': scrollbarHeight
                };
            })
        };
    },
    render() {
        const { $slots, mergedClsPrefix } = this;
        if (!this.scrollable)
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'default');
        const createChildren = () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])('div', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["mergeProps"])(this.$attrs, {
            class: `${mergedClsPrefix}-scrollbar`,
            style: this.cssVars,
            onMouseenter: this.handleMouseEnterWrapper,
            onMouseleave: this.handleMouseLeaveWrapper
        }), [
            this.container ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'default')) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "containerRef", class: `${mergedClsPrefix}-scrollbar-container`, style: this.containerStyle, onScroll: this.handleScroll, onWheel: this.onWheel },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(VResizeObserver, { onResize: this.handleContentResize }, {
                    default: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "contentRef", style: [
                            {
                                width: this.xScrollable ? 'fit-content' : null
                            },
                            this.contentStyle
                        ], class: [
                            `${mergedClsPrefix}-scrollbar-content`,
                            this.contentClass
                        ] }, $slots))
                }))),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "yRailRef", class: `${mergedClsPrefix}-scrollbar-rail ${mergedClsPrefix}-scrollbar-rail--vertical`, style: [this.horizontalRailStyle] },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "fade-in-transition" }, {
                    default: () => this.needYBar && this.isShowYBar && !this.isIos ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                            height: this.yBarSizePx,
                            top: this.yBarTopPx
                        }, onMousedown: this.handleYScrollMouseDown })) : null
                })),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "xRailRef", class: `${mergedClsPrefix}-scrollbar-rail ${mergedClsPrefix}-scrollbar-rail--horizontal`, style: [this.verticalRailStyle] },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "fade-in-transition" }, {
                    default: () => this.needXBar && this.isShowXBar && !this.isIos ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                            width: this.xBarSizePx,
                            left: this.xBarLeftPx
                        }, onMousedown: this.handleXScrollMouseDown })) : null
                }))
        ]);
        return this.container ? (createChildren()) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(VResizeObserver, { onResize: this.handleContainerResize }, {
            default: createChildren
        }));
    }
});
/* harmony default export */ var ScrollBar = (Scrollbar);
const XScrollbar = Scrollbar;

// CONCATENATED MODULE: ./node_modules/naive-ui/es/modal/src/BodyWrapper.js












/* harmony default export */ var BodyWrapper = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'ModalBody',
    inheritAttrs: false,
    props: Object.assign(Object.assign({ show: {
            type: Boolean,
            required: true
        }, preset: String, displayDirective: {
            type: String,
            required: true
        } }, presetProps), { 
        // events
        onClickoutside: {
            type: Function,
            required: true
        }, onBeforeLeave: {
            type: Function,
            required: true
        }, onAfterLeave: {
            type: Function,
            required: true
        }, onPositiveClick: {
            type: Function,
            required: true
        }, onNegativeClick: {
            type: Function,
            required: true
        }, onClose: {
            type: Function,
            required: true
        }, onAfterEnter: Function }),
    setup(props) {
        const bodyRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const scrollbarRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const displayedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.show);
        const transformOriginXRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const transformOriginYRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'show'), (value) => {
            if (value)
                displayedRef.value = true;
        });
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const NModal = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(modalInjectionKey);
        function styleTransformOrigin() {
            if (NModal.transformOriginRef.value === 'center') {
                return '';
            }
            const { value: transformOriginX } = transformOriginXRef;
            const { value: transformOriginY } = transformOriginYRef;
            if (transformOriginX === null || transformOriginY === null) {
                return '';
            }
            else if (scrollbarRef.value) {
                const scrollTop = scrollbarRef.value.containerScrollTop;
                return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
            }
            return '';
        }
        function syncTransformOrigin(el) {
            if (NModal.transformOriginRef.value === 'center') {
                return;
            }
            const mousePosition = NModal.getMousePosition();
            if (!mousePosition) {
                return;
            }
            if (!scrollbarRef.value)
                return;
            const scrollTop = scrollbarRef.value.containerScrollTop;
            const { offsetLeft, offsetTop } = el;
            if (mousePosition) {
                const top = mousePosition.y;
                const left = mousePosition.x;
                transformOriginXRef.value = -(offsetLeft - left);
                transformOriginYRef.value = -(offsetTop - top - scrollTop);
            }
            el.style.transformOrigin = styleTransformOrigin();
        }
        function handleEnter(el) {
            void Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(() => {
                syncTransformOrigin(el);
            });
        }
        function handleBeforeLeave(el) {
            el.style.transformOrigin = styleTransformOrigin();
            props.onBeforeLeave();
        }
        function handleAfterLeave() {
            displayedRef.value = false;
            transformOriginXRef.value = null;
            transformOriginYRef.value = null;
            props.onAfterLeave();
        }
        function handleCloseClick() {
            const { onClose } = props;
            if (onClose) {
                onClose();
            }
        }
        function handleNegativeClick() {
            props.onNegativeClick();
        }
        function handlePositiveClick() {
            props.onPositiveClick();
        }
        function handleClickOutside(e) {
            props.onClickoutside(e);
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(modalBodyInjectionKey, bodyRef);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(drawerBodyInjectionKey, null);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(popoverBodyInjectionKey, null);
        return {
            mergedTheme: NModal.mergedThemeRef,
            appear: NModal.appearRef,
            isMounted: NModal.isMountedRef,
            mergedClsPrefix: NModal.mergedClsPrefixRef,
            bodyRef,
            scrollbarRef,
            displayed: displayedRef,
            handleClickOutside,
            handlePositiveClick,
            handleNegativeClick,
            handleCloseClick,
            handleAfterLeave,
            handleBeforeLeave,
            handleEnter
        };
    },
    render() {
        const { $slots, $attrs, handleEnter, handleAfterLeave, handleBeforeLeave, handleClickOutside, preset, mergedClsPrefix } = this;
        let childNode = null;
        if (!preset) {
            childNode = getFirstSlotVNode($slots);
            if (!childNode) {
                warn('modal', 'default slot is empty');
                return;
            }
            childNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(childNode);
            childNode.props = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["mergeProps"])({
                class: `${mergedClsPrefix}-modal`
            }, $attrs, childNode.props || {});
        }
        return this.displayDirective === 'show' || this.displayed || this.show
            ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-modal-body-wrapper` },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ScrollBar, { ref: "scrollbarRef", theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, contentClass: `${mergedClsPrefix}-modal-scroll-content` }, {
                    default: () => {
                        var _a;
                        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "fade-in-scale-up-transition", appear: (_a = this.appear) !== null && _a !== void 0 ? _a : this.isMounted, onEnter: handleEnter, onAfterEnter: this.onAfterEnter, onAfterLeave: handleAfterLeave, onBeforeLeave: handleBeforeLeave }, {
                            default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((this.preset === 'confirm' ||
                                this.preset === 'dialog' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Dialog, Object.assign({}, this.$attrs, { class: [
                                    `${mergedClsPrefix}-modal`,
                                    this.$attrs.class
                                ], ref: "bodyRef", theme: this.mergedTheme.peers.Dialog, themeOverrides: this.mergedTheme.peerOverrides.Dialog }, keep(this.$props, dialogPropKeys)), $slots)) : this.preset === 'card' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Card, Object.assign({}, this.$attrs, { ref: "bodyRef", class: [
                                    `${mergedClsPrefix}-modal`,
                                    this.$attrs.class
                                ], theme: this.mergedTheme.peers.Card, themeOverrides: this.mergedTheme.peerOverrides.Card }, keep(this.$props, cardBasePropKeys)), $slots)) : (childNode)), [
                                [external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], this.show],
                                [es_clickoutside, handleClickOutside]
                            ])
                        }));
                    }
                })), [
                [
                    external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"],
                    this.displayDirective === 'if' || this.displayed || this.show
                ]
            ])
            : null;
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/transitions/fade-in-scale-up.cssr.js


const {
  cubicBezierEaseIn,
  cubicBezierEaseOut: fade_in_scale_up_cssr_cubicBezierEaseOut,
  transformDebounceScale: fade_in_scale_up_cssr_transformDebounceScale
} = _common;
/* harmony default export */ var fade_in_scale_up_cssr = (function ({
  transformOrigin = 'inherit',
  duration = '.2s',
  enterScale = '.9',
  originalTransform = '',
  originalTransition = ''
} = {}) {
  return [cssr_c('&.fade-in-scale-up-transition-leave-active', {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseIn}, transform ${duration} ${cubicBezierEaseIn} ${originalTransition && ',' + originalTransition}`
  }), cssr_c('&.fade-in-scale-up-transition-enter-active', {
    transformOrigin,
    transition: `opacity ${duration} ${fade_in_scale_up_cssr_cubicBezierEaseOut}, transform ${duration} ${fade_in_scale_up_cssr_cubicBezierEaseOut} ${originalTransition && ',' + originalTransition}`
  }), cssr_c('&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to', {
    opacity: 0,
    transform: `${originalTransform} scale(${enterScale})`
  }), cssr_c('&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to', {
    opacity: 1,
    transform: `${originalTransform} scale(${fade_in_scale_up_cssr_transformDebounceScale})`
  })];
});
// CONCATENATED MODULE: ./node_modules/naive-ui/es/modal/src/styles/index.cssr.js


 // vars:
// --bezier-ease-out
// --box-shadow
// --color
// --text-color

/* harmony default export */ var modal_src_styles_index_cssr = (cssr_c([cB('modal-container', `
 position: fixed;
 left: 0;
 top: 0;
 height: 0;
 width: 0;
 display: flex;
 `), cB('modal-mask', `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background-color: rgba(0, 0, 0, .4);
 `, [fade_in_cssr({
  enterDuration: '.25s',
  leaveDuration: '.25s',
  enterCubicBezier: 'var(--bezier-ease-out)',
  leaveCubicBezier: 'var(--bezier-ease-out)'
})]), cB('modal-body-wrapper', `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: visible;
 `, [cB('modal-scroll-content', `
 min-height: 100%;
 display: flex;
 position: relative;
 `)]), cB('modal', `
 align-self: center;
 color: var(--text-color);
 margin: auto;
 box-shadow: var(--box-shadow);
 `, [fade_in_scale_up_cssr({
  duration: '.25s',
  enterScale: '.5'
})])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/modal/src/Modal.js












const modalProps = Object.assign(Object.assign(Object.assign(Object.assign({}, use_theme.props), { show: Boolean, unstableShowMask: {
        type: Boolean,
        default: true
    }, maskClosable: {
        type: Boolean,
        default: true
    }, preset: String, to: [String, Object], displayDirective: {
        type: String,
        default: 'if'
    }, transformOrigin: {
        type: String,
        default: 'mouse'
    } }), presetProps), { 
    // events
    'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onBeforeLeave: Function, onAfterLeave: Function, onClose: Function, onPositiveClick: Function, onNegativeClick: Function, onMaskClick: Function, 
    // private
    dialog: Boolean, appear: {
        type: Boolean,
        default: undefined
    }, 
    // deprecated
    overlayStyle: [String, Object], onBeforeHide: Function, onAfterHide: Function, onHide: Function });
/* harmony default export */ var Modal = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Modal',
    inheritAttrs: false,
    props: modalProps,
    setup(props) {
        if (false) {}
        const containerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const { mergedClsPrefixRef, namespaceRef } = useConfig(props);
        const themeRef = use_theme('Modal', 'Modal', modal_src_styles_index_cssr, modal_styles_light, props, mergedClsPrefixRef);
        const clickedRef = useClicked(64);
        const clickedPositionRef = useClickPosition();
        const isMountedRef = use_is_mounted_isMounted();
        const NDialogProvider = props.dialog
            ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(dialogProviderInjectionKey, null)
            : null;
        function doUpdateShow(show) {
            const { onUpdateShow, 'onUpdate:show': _onUpdateShow, onHide } = props;
            if (onUpdateShow)
                call(onUpdateShow, show);
            if (_onUpdateShow)
                call(_onUpdateShow, show);
            // deprecated
            if (onHide && !show)
                onHide(show);
        }
        function handleCloseClick() {
            const { onClose } = props;
            if (onClose) {
                void Promise.resolve(onClose()).then((value) => {
                    if (value === false)
                        return;
                    doUpdateShow(false);
                });
            }
            else {
                doUpdateShow(false);
            }
        }
        function handlePositiveClick() {
            const { onPositiveClick } = props;
            if (onPositiveClick) {
                void Promise.resolve(onPositiveClick()).then((value) => {
                    if (value === false)
                        return;
                    doUpdateShow(false);
                });
            }
            else {
                doUpdateShow(false);
            }
        }
        function handleNegativeClick() {
            const { onNegativeClick } = props;
            if (onNegativeClick) {
                void Promise.resolve(onNegativeClick()).then((value) => {
                    if (value === false)
                        return;
                    doUpdateShow(false);
                });
            }
            else {
                doUpdateShow(false);
            }
        }
        function handleBeforeLeave() {
            const { onBeforeLeave, onBeforeHide } = props;
            if (onBeforeLeave)
                call(onBeforeLeave);
            // deprecated
            if (onBeforeHide)
                onBeforeHide();
        }
        function handleAfterLeave() {
            const { onAfterLeave, onAfterHide } = props;
            if (onAfterLeave)
                call(onAfterLeave);
            // deprecated
            if (onAfterHide)
                onAfterHide();
        }
        function handleClickoutside(e) {
            var _a;
            const { onMaskClick } = props;
            if (onMaskClick) {
                onMaskClick(e);
            }
            if (props.maskClosable) {
                if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
                    doUpdateShow(false);
                }
            }
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(modalInjectionKey, {
            getMousePosition: () => {
                if (NDialogProvider) {
                    const { clickedRef, clickPositionRef } = NDialogProvider;
                    if (clickedRef.value && clickPositionRef.value) {
                        return clickPositionRef.value;
                    }
                }
                if (clickedRef.value) {
                    return clickedPositionRef.value;
                }
                return null;
            },
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            isMountedRef,
            appearRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'appear'),
            transformOriginRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'transformOrigin')
        });
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            isMounted: isMountedRef,
            containerRef,
            presetProps: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const pickedProps = keep(props, presetPropsKeys);
                return pickedProps;
            }),
            handleAfterLeave,
            handleClickoutside,
            handleBeforeLeave,
            doUpdateShow,
            handleNegativeClick,
            handlePositiveClick,
            handleCloseClick,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { common: { cubicBezierEaseOut }, self: { boxShadow, color, textColor } } = themeRef.value;
                return {
                    '--bezier-ease-out': cubicBezierEaseOut,
                    '--box-shadow': boxShadow,
                    '--color': color,
                    '--text-color': textColor
                };
            })
        };
    },
    render() {
        const { mergedClsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(lazy_teleport_src, { to: this.to, show: this.show }, {
            default: () => {
                var _a;
                return [
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "containerRef", class: [`${mergedClsPrefix}-modal-container`, this.namespace], style: this.cssVars },
                        this.unstableShowMask ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "fade-in-transition", key: "mask", appear: (_a = this.appear) !== null && _a !== void 0 ? _a : this.isMounted }, {
                            default: () => {
                                return this.show ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "containerRef", class: `${mergedClsPrefix}-modal-mask` })) : null;
                            }
                        })) : null,
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(BodyWrapper, Object.assign({ style: this.overlayStyle }, this.$attrs, { ref: 'bodyWrapper', displayDirective: this.displayDirective, show: this.show, preset: this.preset }, this.presetProps, { onClose: this.handleCloseClick, onNegativeClick: this.handleNegativeClick, onPositiveClick: this.handlePositiveClick, onBeforeLeave: this.handleBeforeLeave, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave, onClickoutside: this.handleClickoutside }), this.$slots)), [
                        [
                            es_zindexable,
                            {
                                enabled: this.show
                            }
                        ]
                    ])
                ];
            }
        }));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/styles/_common.js
/* harmony default export */ var form_styles_common = ({
    blankHeightSmall: '28px',
    blankHeightMedium: '34px',
    blankHeightLarge: '40px',
    feedbackPadding: '4px 0 0 2px',
    feedbackHeightSmall: '24px',
    feedbackHeightMedium: '24px',
    feedbackHeightLarge: '26px',
    feedbackFontSizeSmall: '13px',
    feedbackFontSizeMedium: '14px',
    feedbackFontSizeLarge: '14px',
    labelFontSizeLeftSmall: '14px',
    labelFontSizeLeftMedium: '14px',
    labelFontSizeLeftLarge: '15px',
    labelFontSizeTopSmall: '13px',
    labelFontSizeTopMedium: '14px',
    labelFontSizeTopLarge: '14px',
    labelHeightSmall: '24px',
    labelHeightMedium: '26px',
    labelHeightLarge: '28px',
    labelPaddingVertical: '0 0 8px 2px',
    labelPaddingHorizontal: '0 12px 0 0',
    labelTextAlignVertical: 'left',
    labelTextAlignHorizontal: 'right'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/styles/light.js


const form_styles_light_self = (vars) => {
    const { textColor1, errorColor, warningColor, lineHeight, textColor3 } = vars;
    return Object.assign(Object.assign({}, form_styles_common), { lineHeight, labelTextColor: textColor1, asteriskColor: errorColor, feedbackTextColorError: errorColor, feedbackTextColorWarning: warningColor, feedbackTextColor: textColor3 });
};
const formLight = {
    name: 'Form',
    common: light,
    self: form_styles_light_self
};
/* harmony default export */ var form_styles_light = (formLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/styles/form.cssr.js

/* harmony default export */ var form_cssr = (cB('form', [cM('inline', `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB('form-item', {
  width: 'auto',
  marginRight: '18px'
}, [cssr_c('&:last-child', {
  marginRight: 0
})])])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/interface.js
const formInjectionKey = Symbol('form');
const formItemInstsInjectionKey = Symbol('formItemInsts');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/Form.js
var Form_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const formProps = Object.assign(Object.assign({}, use_theme.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: {
        type: String,
        default: 'top'
    }, model: {
        type: Object,
        default: () => { }
    }, rules: Object, disabled: Boolean, size: String, showRequireMark: {
        type: Boolean,
        default: undefined
    }, requireMarkPlacement: String, showFeedback: {
        type: Boolean,
        default: true
    }, onSubmit: {
        type: Function,
        default: (e) => e.preventDefault()
    }, showLabel: {
        type: Boolean,
        default: undefined
    } });
/* harmony default export */ var Form = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Form',
    props: formProps,
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        use_theme('Form', 'Form', form_cssr, form_styles_light, props, mergedClsPrefixRef);
        // from path to form-item
        const formItems = {};
        function validate(validateCallback, shouldRuleBeApplied = () => true) {
            return Form_awaiter(this, void 0, void 0, function* () {
                return yield new Promise((resolve, reject) => {
                    const formItemValidationPromises = [];
                    for (const key of keysOf(formItems)) {
                        const formItemInstances = formItems[key];
                        for (const formItemInstance of formItemInstances) {
                            if (formItemInstance.path) {
                                formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                            }
                        }
                    }
                    void Promise.all(formItemValidationPromises).then((results) => {
                        if (results.some((result) => !result.valid)) {
                            const errors = results
                                .filter((result) => result.errors)
                                .map((result) => result.errors);
                            if (validateCallback) {
                                validateCallback(errors);
                            }
                            else {
                                reject(errors);
                            }
                        }
                        else {
                            if (validateCallback)
                                validateCallback();
                            else {
                                resolve();
                            }
                        }
                    });
                });
            });
        }
        function restoreValidation() {
            for (const key of keysOf(formItems)) {
                const formItemInstances = formItems[key];
                for (const formItemInstance of formItemInstances) {
                    formItemInstance.restoreValidation();
                }
            }
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(formInjectionKey, props);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(formItemInstsInjectionKey, { formItems });
        const formExposedMethod = {
            validate,
            restoreValidation
        };
        return Object.assign(formExposedMethod, {
            mergedClsPrefix: mergedClsPrefixRef
        });
    },
    render() {
        const { mergedClsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("form", { class: [
                `${mergedClsPrefix}-form`,
                this.inline && `${mergedClsPrefix}-form--inline`
            ], onSubmit: this.onSubmit }, this.$slots));
    }
}));

// EXTERNAL MODULE: ./node_modules/async-validator/dist-web/index.js
var dist_web = __webpack_require__("2a95");

// CONCATENATED MODULE: ./node_modules/lodash-es/_isKey.js



/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (lodash_es_isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || lodash_es_isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* harmony default export */ var _isKey = (isKey);

// CONCATENATED MODULE: ./node_modules/lodash-es/memoize.js


/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

/* harmony default export */ var lodash_es_memoize = (memoize);

// CONCATENATED MODULE: ./node_modules/lodash-es/_memoizeCapped.js


/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = lodash_es_memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/* harmony default export */ var _memoizeCapped = (memoizeCapped);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToPath.js


/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/* harmony default export */ var _stringToPath = (stringToPath);

// CONCATENATED MODULE: ./node_modules/lodash-es/_castPath.js





/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (lodash_es_isArray(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(lodash_es_toString(value));
}

/* harmony default export */ var _castPath = (castPath);

// CONCATENATED MODULE: ./node_modules/lodash-es/_toKey.js


/** Used as references for various `Number` constants. */
var _toKey_INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || lodash_es_isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -_toKey_INFINITY) ? '-0' : result;
}

/* harmony default export */ var _toKey = (toKey);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGet.js



/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/* harmony default export */ var _baseGet = (baseGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/get.js


/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ var lodash_es_get = (get);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_utils/composable/index.js

// injection.collection {
//   key1: [insta, instb]
//   key2: [instc]
// }
function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
    var _a;
    const injection = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(injectionName, null);
    if (injection === null)
        return;
    const vm = (_a = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])()) === null || _a === void 0 ? void 0 : _a.proxy;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(registerKeyRef, registerInstance);
    registerInstance(registerKeyRef.value);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
        registerInstance(undefined, registerKeyRef.value);
    });
    function registerInstance(key, oldKey) {
        const collection = injection[collectionKey];
        if (oldKey !== undefined)
            removeInstance(collection, oldKey);
        if (key !== undefined)
            addInstance(collection, key);
    }
    function removeInstance(collection, key) {
        if (!collection[key])
            collection[key] = [];
        collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);
    }
    function addInstance(collection, key) {
        if (!collection[key])
            collection[key] = [];
        if (!~collection[key].findIndex((instance) => instance === vm)) {
            collection[key].push(vm);
        }
    }
}
// injection.collection {
//   key1: [insta.value, instb.value]
//   key2: [instc.value]
// }
function useInjectionCollection(injectionName, collectionKey, valueRef) {
    const injection = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(injectionName, null);
    if (injection === null)
        return;
    if (!(collectionKey in injection)) {
        injection[collectionKey] = [];
    }
    injection[collectionKey].push(valueRef.value);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(valueRef, (value, prevValue) => {
        const collectionArray = injection[collectionKey];
        const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);
        if (~index)
            collectionArray.splice(index, 1);
        collectionArray.push(value);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
        const collectionArray = injection[collectionKey];
        const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);
        if (~index)
            collectionArray.splice(index, 1);
    });
}
// injection.collection {
//   key1: [insta.$el, instb.$el]
//   key2: [instc.$el]
// }
function useInjectionElementCollection(injectionName, collectionKey, getElement) {
    const injection = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(injectionName, null);
    if (injection === null)
        return;
    if (!(collectionKey in injection)) {
        injection[collectionKey] = [];
    }
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
        const el = getElement();
        if (!el)
            return;
        injection[collectionKey].push(el);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
        const collectionArray = injection[collectionKey];
        const element = getElement();
        const index = collectionArray.findIndex((collectionElement) => collectionElement === element);
        if (~index)
            collectionArray.splice(index, 1);
    });
}
function useDeferredTrue(valueRef, delay, shouldDelayRef) {
    if (!delay)
        return valueRef;
    const delayedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(valueRef.value);
    let timerId = null;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(valueRef, (value) => {
        if (timerId !== null)
            window.clearTimeout(timerId);
        if (value === true) {
            if (shouldDelayRef && !shouldDelayRef.value) {
                delayedRef.value = true;
            }
            else {
                timerId = window.setTimeout(() => {
                    delayedRef.value = true;
                }, delay);
            }
        }
        else {
            delayedRef.value = false;
        }
    });
    return delayedRef;
}



// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/utils.js




function formItemSize(props) {
    const NForm = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(formInjectionKey, null);
    return {
        mergedSize: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            if (props.size !== undefined)
                return props.size;
            if ((NForm === null || NForm === void 0 ? void 0 : NForm.size) !== undefined)
                return NForm.size;
            return 'medium';
        })
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function formItemMisc(props) {
    const NForm = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(formInjectionKey, null);
    const mergedLabelWidthRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        if (mergedLabelPlacementRef.value === 'top')
            return;
        const { labelWidth } = props;
        if (labelWidth !== undefined) {
            return format_length(labelWidth);
        }
        if ((NForm === null || NForm === void 0 ? void 0 : NForm.labelWidth) !== undefined) {
            return format_length(NForm.labelWidth);
        }
        return undefined;
    });
    const mergedLabelPlacementRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { labelPlacement } = props;
        if (labelPlacement !== undefined)
            return labelPlacement;
        if (NForm === null || NForm === void 0 ? void 0 : NForm.labelPlacement)
            return NForm.labelPlacement;
        return 'top';
    });
    const mergedLabelAlignRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { labelAlign } = props;
        if (labelAlign)
            return labelAlign;
        if (NForm === null || NForm === void 0 ? void 0 : NForm.labelAlign)
            return NForm.labelAlign;
        return undefined;
    });
    const mergedLabelStyleRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        return [
            {
                width: mergedLabelWidthRef.value
            },
            props.labelStyle
        ];
    });
    const mergedShowRequireMarkRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { showRequireMark } = props;
        if (showRequireMark !== undefined)
            return showRequireMark;
        return NForm === null || NForm === void 0 ? void 0 : NForm.showRequireMark;
    });
    const mergedRequireMarkPlacementRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { requireMarkPlacement } = props;
        if (requireMarkPlacement !== undefined)
            return requireMarkPlacement;
        return NForm === null || NForm === void 0 ? void 0 : NForm.requireMarkPlacement;
    });
    const validationErroredRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    const mergedValidationStatusRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { validationStatus } = props;
        if (validationStatus !== undefined)
            return validationStatus;
        if (validationErroredRef.value)
            return 'error';
        return undefined;
    });
    const mergedShowFeedbackRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { showFeedback } = props;
        if (showFeedback !== undefined)
            return showFeedback;
        if ((NForm === null || NForm === void 0 ? void 0 : NForm.showFeedback) !== undefined)
            return NForm.showFeedback;
        return true;
    });
    const mergedShowLabelRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { showLabel } = props;
        if (showLabel !== undefined)
            return showLabel;
        if ((NForm === null || NForm === void 0 ? void 0 : NForm.showLabel) !== undefined)
            return NForm.showLabel;
        return true;
    });
    return {
        validationErrored: validationErroredRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function formItemRule(props) {
    const NForm = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(formInjectionKey, null);
    const compatibleRulePathRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const { rulePath } = props;
        if (rulePath !== undefined)
            return rulePath;
        const { path } = props;
        if (path !== undefined)
            return path;
        return undefined;
    });
    const mergedRulesRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        const rules = [];
        const { rule } = props;
        if (rule !== undefined) {
            if (Array.isArray(rule))
                rules.push(...rule);
            else
                rules.push(rule);
        }
        if (NForm) {
            const { rules: formRules } = NForm;
            const { value: rulePath } = compatibleRulePathRef;
            if (formRules !== undefined && rulePath !== undefined) {
                const formRule = lodash_es_get(formRules, rulePath);
                if (formRule !== undefined) {
                    if (Array.isArray(formRule)) {
                        rules.push(...formRule);
                    }
                    else {
                        // terminate object must be a form item rule
                        rules.push(formRule);
                    }
                }
            }
        }
        return rules;
    });
    const hasRequiredRuleRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        return mergedRulesRef.value.some((rule) => rule.required);
    });
    // deprecated
    const mergedRequiredRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        return hasRequiredRuleRef.value || props.required;
    });
    return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
    };
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/Feedbacks.js

/* harmony default export */ var Feedbacks = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'FormItemFeedback',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        explains: Array,
        feedback: String
    },
    render() {
        var _a;
        const { feedback, clsPrefix } = this;
        return feedback ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: feedback, class: `${clsPrefix}-form-item-feedback__line` }, feedback)) : ((_a = this.explains) === null || _a === void 0 ? void 0 : _a.map((explain) => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: explain, class: `${clsPrefix}-form-item-feedback__line` }, explain))));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_styles/transitions/fade-down.cssr.js


const {
  cubicBezierEaseInOut: fade_down_cssr_cubicBezierEaseInOut
} = _common;
/* harmony default export */ var fade_down_cssr = (function ({
  name = 'fade-down',
  fromOffset = '-4px',
  enterDuration = '.3s',
  leaveDuration = '.3s',
  enterCubicBezier = fade_down_cssr_cubicBezierEaseInOut,
  leaveCubicBezier = fade_down_cssr_cubicBezierEaseInOut
} = {}) {
  return [cssr_c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
    opacity: 0,
    transform: `translateY(${fromOffset})`
  }), cssr_c(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
    opacity: 1,
    transform: 'translateY(0)'
  }), cssr_c(`&.${name}-transition-leave-active`, {
    transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
  }), cssr_c(`&.${name}-transition-enter-active`, {
    transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
  })];
});
// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/styles/form-item.cssr.js

 // vars:
// --line-height
// --blank-height
// --feedback-padding
// --feedback-font-size
// --label-font-size-left
// --label-font-size-top
// --label-height
// --label-padding
// --asterisk-color
// --label-text-color
// --bezier
// --feedback-text-color
// --feedback-text-color-warning
// --feedback-text-color-error
// --label-text-align
// --label-padding

/* harmony default export */ var form_item_cssr = (cB('form-item', {
  display: 'grid',
  lineHeight: 'var(--line-height)'
}, [cB('form-item-label', `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--label-text-align);
 font-size: var(--label-font-size);
 height: var(--label-height);
 padding: var(--label-padding);
 color: var(--label-text-color);
 transition: color .3s var(--bezier);
 box-sizing: border-box;
 `, [cE('asterisk', `
 color: var(--asterisk-color);
 transition: color .3s var(--bezier);
 `)]), cB('form-item-blank', {
  gridArea: 'blank',
  minHeight: 'var(--blank-height)'
}), cM('left-labelled', `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 `, [cB('form-item-label', `
 height: var(--blank-height);
 line-height: var(--blank-height);
 box-sizing: border-box;
 white-space: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `)]), cM('top-labelled', `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: var(--label-height) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM('no-label', `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB('form-item-label', {
  display: 'flex',
  alignItems: 'flex-end',
  justifyContent: 'var(--label-text-align)'
})]), cB('form-item-blank', `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB('form-item-feedback-wrapper', `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--feedback-height);
 font-size: var(--feedback-font-size);
 padding: var(--feedback-padding);
 line-height: 1.25;
 transform-origin: top left;
 `, [cB('form-item-feedback', {
  transition: 'color .3s var(--bezier)',
  color: 'var(--feedback-text-color)'
}, [cM('warning', {
  color: 'var(--feedback-text-color-warning)'
}), cM('error', {
  color: 'var(--feedback-text-color-error)'
}), fade_down_cssr({
  fromOffset: '-3px',
  enterDuration: '.3s',
  leaveDuration: '.2s'
})])])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/form/src/FormItem.js
var FormItem_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};












const formItemProps = Object.assign(Object.assign({}, use_theme.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: {
        type: Boolean,
        default: undefined
    }, requireMarkPlacement: String, showFeedback: {
        type: Boolean,
        default: undefined
    }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, showLabel: {
        type: Boolean,
        default: undefined
    } });
const formItemPropKeys = keysOf(formItemProps);
// wrap sync validator
function wrapValidator(validator, async) {
    return (...args) => {
        var _a;
        try {
            const validateResult = validator(...args);
            if ((!async &&
                (typeof validateResult === 'boolean' ||
                    validateResult instanceof Error ||
                    Array.isArray(validateResult))) || // Error[]
                ((_a = validateResult) === null || _a === void 0 ? void 0 : _a.then)) {
                return validateResult;
            }
            else if (validateResult === undefined) {
                return true;
            }
            else {
                warn('form-item/validate', `You return a ${typeof validateResult} ` +
                    'typed value in the validator method, which is not recommended. Please use ' +
                    (async ? '`Promise`' : '`boolean`, `Error` or `Promise`') +
                    ' typed value instead.');
                return true;
            }
        }
        catch (err) {
            warn('form-item/validate', 'An error is catched in the validation, ' +
                "so the validation won't be done. Your callback in `validate` method of " +
                "`n-form` or `n-form-item` won't be called in this validation.");
            console.error(err);
            // If returns undefined, async-validator won't trigger callback
            // so the result will be abandoned, which means not true and not false
            return undefined;
        }
    };
}
/* harmony default export */ var FormItem = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'FormItem',
    props: formItemProps,
    setup(props) {
        useInjectionInstanceCollection(formItemInstsInjectionKey, 'formItems', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'path'));
        const { mergedClsPrefixRef } = useConfig(props);
        const NForm = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const { validationErrored: validationErroredRef } = formItemMiscRefs;
        const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = formItemRule(props);
        const { mergedSize: mergedSizeRef } = formItemSizeRefs;
        const { mergedLabelPlacement: labelPlacementRef, mergedLabelAlign: labelTextAlignRef } = formItemMiscRefs;
        const explainsRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
        const feedbackIdRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(createId());
        const hasFeedbackRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { feedback } = props;
            if (feedback !== undefined && feedback !== null)
                return true;
            return explainsRef.value.length;
        });
        const mergedDisabledRef = NForm ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(NForm, 'disabled') : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        const themeRef = use_theme('Form', 'FormItem', form_item_cssr, form_styles_light, props, mergedClsPrefixRef);
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'path'), () => {
            if (props.ignorePathChange)
                return;
            restoreValidation();
        });
        function restoreValidation() {
            explainsRef.value = [];
            validationErroredRef.value = false;
            if (props.feedback) {
                feedbackIdRef.value = createId();
            }
        }
        function handleContentBlur() {
            void internalValidate('blur');
        }
        function handleContentChange() {
            void internalValidate('change');
        }
        function handleContentFocus() {
            void internalValidate('focus');
        }
        function handleContentInput() {
            void internalValidate('input');
        }
        function validate(options, callback) {
            return FormItem_awaiter(this, void 0, void 0, function* () {
                /** the following code is for compatibility */
                let trigger;
                let validateCallback;
                let shouldRuleBeApplied;
                let asyncValidatorOptions;
                if (typeof options === 'string') {
                    trigger = options;
                    validateCallback = callback;
                }
                else if (options !== null && typeof options === 'object') {
                    trigger = options.trigger;
                    validateCallback = options.callback;
                    shouldRuleBeApplied = options.shouldRuleBeApplied;
                    asyncValidatorOptions = options.options;
                }
                return yield new Promise((resolve, reject) => {
                    void internalValidate(trigger, shouldRuleBeApplied, asyncValidatorOptions).then(({ valid, errors }) => {
                        if (valid) {
                            if (validateCallback) {
                                validateCallback();
                            }
                            resolve();
                        }
                        else {
                            if (validateCallback) {
                                validateCallback(errors);
                            }
                            // eslint-disable-next-line prefer-promise-reject-errors
                            reject(errors);
                        }
                    });
                });
            });
        }
        const internalValidate = (trigger = null, shouldRuleBeApplied = () => true, options = {
            suppressWarning: true
        }) => FormItem_awaiter(this, void 0, void 0, function* () {
            const { path } = props;
            if (!options) {
                options = {};
            }
            else {
                if (!options.first)
                    options.first = props.first;
            }
            const { value: rules } = mergedRulesRef;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const value = NForm ? lodash_es_get(NForm.model, path, null) : undefined;
            const activeRules = (!trigger
                ? rules
                : rules.filter((rule) => {
                    // if (rule.trigger === undefined) return true
                    if (Array.isArray(rule.trigger)) {
                        return rule.trigger.includes(trigger);
                    }
                    else {
                        return rule.trigger === trigger;
                    }
                }))
                .filter(shouldRuleBeApplied)
                .map((rule) => {
                const shallowClonedRule = Object.assign({}, rule);
                if (shallowClonedRule.validator) {
                    shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
                }
                if (shallowClonedRule.asyncValidator) {
                    shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
                }
                return shallowClonedRule;
            });
            if (!activeRules.length) {
                return yield Promise.resolve({
                    valid: true
                });
            }
            const mergedPath = path !== null && path !== void 0 ? path : '__n_no_path__';
            const validator = new dist_web["a" /* default */]({ [mergedPath]: activeRules });
            return yield new Promise((resolve) => {
                void validator.validate({ [mergedPath]: value }, options, (errors, fields) => {
                    if (errors === null || errors === void 0 ? void 0 : errors.length) {
                        explainsRef.value = errors.map((error) => (error === null || error === void 0 ? void 0 : error.message) || '');
                        validationErroredRef.value = true;
                        resolve({
                            valid: false,
                            errors
                        });
                    }
                    else {
                        restoreValidation();
                        resolve({
                            valid: true
                        });
                    }
                });
            });
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(formItemInjectionKey, {
            path: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'path'),
            disabled: mergedDisabledRef,
            mergedSize: formItemSizeRefs.mergedSize,
            restoreValidation,
            handleContentBlur,
            handleContentChange,
            handleContentFocus,
            handleContentInput
        });
        const exposedRef = {
            validate,
            restoreValidation,
            internalValidate
        };
        return Object.assign(Object.assign(Object.assign(Object.assign({ mergedClsPrefix: mergedClsPrefixRef, mergedRequired: mergedRequiredRef, hasFeedback: hasFeedbackRef, feedbackId: feedbackIdRef, explains: explainsRef }, formItemMiscRefs), formItemSizeRefs), exposedRef), { cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                var _a;
                const { value: size } = mergedSizeRef;
                const { value: labelPlacement } = labelPlacementRef;
                const direction = labelPlacement === 'top' ? 'vertical' : 'horizontal';
                const { common: { cubicBezierEaseInOut }, self: { labelTextColor, asteriskColor, lineHeight, feedbackTextColor, feedbackTextColorWarning, feedbackTextColorError, feedbackPadding, [createKey('labelHeight', size)]: labelHeight, [createKey('blankHeight', size)]: blankHeight, [createKey('feedbackFontSize', size)]: feedbackFontSize, [createKey('feedbackHeight', size)]: feedbackHeight, [createKey('labelPadding', direction)]: labelPadding, [createKey('labelTextAlign', direction)]: labelTextAlign, [createKey(createKey('labelFontSize', labelPlacement), size)]: labelFontSize } } = themeRef.value;
                let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
                if (labelPlacement === 'top') {
                    mergedLabelTextAlign =
                        mergedLabelTextAlign === 'right' ? 'flex-end' : 'flex-start';
                }
                const cssVars = {
                    '--bezier': cubicBezierEaseInOut,
                    '--line-height': lineHeight,
                    '--blank-height': blankHeight,
                    '--label-font-size': labelFontSize,
                    '--label-text-align': mergedLabelTextAlign,
                    '--label-height': labelHeight,
                    '--label-padding': labelPadding,
                    '--asterisk-color': asteriskColor,
                    '--label-text-color': labelTextColor,
                    '--feedback-padding': feedbackPadding,
                    '--feedback-font-size': feedbackFontSize,
                    '--feedback-height': feedbackHeight,
                    '--feedback-text-color': feedbackTextColor,
                    '--feedback-text-color-warning': feedbackTextColorWarning,
                    '--feedback-text-color-error': feedbackTextColorError
                };
                return cssVars;
            }) });
    },
    render() {
        const { $slots, mergedClsPrefix, mergedShowLabel, mergedShowRequireMark, mergedRequireMarkPlacement } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                `${mergedClsPrefix}-form-item`,
                `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
                `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
                !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`
            ], style: this.cssVars },
            mergedShowLabel && (this.label || $slots.label) ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("label", { class: `${mergedClsPrefix}-form-item-label`, style: this.mergedLabelStyle },
                mergedRequireMarkPlacement !== 'left'
                    ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'label', undefined, () => [this.label])
                    : null,
                (mergedShowRequireMark !== undefined
                    ? mergedShowRequireMark
                    : this.mergedRequired) ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", { class: `${mergedClsPrefix}-form-item-label__asterisk` }, mergedRequireMarkPlacement !== 'left' ? '\u00A0*' : '*\u00A0')) : null,
                mergedRequireMarkPlacement === 'left'
                    ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'label', undefined, () => [this.label])
                    : null)) : null,
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                    `${mergedClsPrefix}-form-item-blank`,
                    this.mergedValidationStatus &&
                        `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
                ] }, $slots),
            this.mergedShowFeedback ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: this.feedbackId, class: `${mergedClsPrefix}-form-item-feedback-wrapper` },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "fade-down-transition", mode: "out-in" }, {
                    default: () => {
                        const feedbacks = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Feedbacks, { clsPrefix: mergedClsPrefix, explains: this.explains, feedback: this.feedback }));
                        const { hasFeedback, mergedValidationStatus } = this;
                        return hasFeedback ? (mergedValidationStatus === 'warning' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "controlled-warning", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning` }, feedbacks)) : mergedValidationStatus === 'error' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "controlled-error", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error` }, feedbacks)) : mergedValidationStatus === 'success' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "controlled-success", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success` }, feedbacks)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "controlled-default", class: `${mergedClsPrefix}-form-item-feedback` }, feedbacks))) : null;
                    }
                }))) : null));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Clear.js


/* harmony default export */ var Clear = (replaceable('clear', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", { fill: "currentColor", "fill-rule": "nonzero" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/clear/src/styles/index.cssr.js

 // vars:
// --bezier
// --clear-color
// --clear-size
// --clear-color-hover
// --clear-color-pressed

/* harmony default export */ var clear_src_styles_index_cssr = (cB('base-clear', `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [cssr_c('>', [cE('clear', `
 font-size: var(--clear-size);
 cursor: pointer;
 color: var(--clear-color);
 transition: color .3s var(--bezier);
 `, [cssr_c('&:hover', `
 color: var(--clear-color-hover)!important;
 `), cssr_c('&:active', `
 color: var(--clear-color-pressed)!important;
 `)]), cE('placeholder', `
 display: flex;
 `), cE('clear, placeholder', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [icon_switch_cssr({
  originalTransform: 'translateX(-50%) translateY(-50%)',
  left: '50%',
  top: '50%'
})])])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/clear/src/Clear.js






/* harmony default export */ var src_Clear = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'BaseClear',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        show: Boolean,
        onClear: Function
    },
    setup(props) {
        useStyle('BaseClear', clear_src_styles_index_cssr, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'clsPrefix'));
        const { NConfigProvider } = useConfig();
        return {
            NConfigProvider,
            handleMouseDown(e) {
                e.preventDefault();
            }
        };
    },
    render() {
        const { clsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${clsPrefix}-base-clear` },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(IconSwitchTransition, null, {
                default: () => {
                    return this.show ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: clsPrefix, key: "dismiss", class: `${clsPrefix}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, {
                        default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Clear, null)
                    })) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "icon", class: `${clsPrefix}-base-clear__placeholder` }, this.$slots));
                }
            })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/ChevronDown.js

/* harmony default export */ var ChevronDown = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'ChevronDown',
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/suffix/src/Suffix.js





/* harmony default export */ var Suffix = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'InternalSelectionSuffix',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        showArrow: {
            type: Boolean,
            default: undefined
        },
        showClear: {
            type: Boolean,
            default: undefined
        },
        loading: {
            type: Boolean,
            default: false
        },
        onClear: Function
    },
    setup(props) {
        return () => {
            const { clsPrefix } = props;
            return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Loading, { clsPrefix: clsPrefix, class: `${clsPrefix}-base-suffix`, strokeWidth: 24, scale: 0.85, show: props.loading }, {
                default: () => props.showArrow ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Clear, { clsPrefix: clsPrefix, show: props.showClear, onClear: props.onClear }, {
                    default: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: clsPrefix, class: `${clsPrefix}-base-suffix__arrow` }, { default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ChevronDown, null) }))
                })) : null
            }));
        };
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Eye.js

/* harmony default export */ var Eye = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Eye',
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/EyeOff.js

/* harmony default export */ var EyeOff = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'EyeOff',
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/locales/common/enUS.js
const enUS = {
    name: 'en-US',
    global: {
        undo: 'Undo',
        redo: 'Redo',
        confirm: 'Confirm'
    },
    Popconfirm: {
        positiveText: 'Confirm',
        negativeText: 'Cancel'
    },
    Cascader: {
        placeholder: 'Please Select',
        loading: 'Loading',
        loadingRequiredMessage: (label) => `Please load all ${label}'s descedants before checking it.`
    },
    Time: {
        dateFormat: 'yyyy-MM-dd',
        dateTimeFormat: 'yyyy-MM-dd HH:mm:ss'
    },
    DatePicker: {
        yearFormat: 'yyyy',
        monthFormat: 'MMM',
        dayFormat: 'eeeeee',
        clear: 'Clear',
        now: 'Now',
        confirm: 'Confirm',
        selectTime: 'Select Time',
        selectDate: 'Select Date',
        datePlaceholder: 'Select Date',
        datetimePlaceholder: 'Select Date and Time',
        monthPlaceholder: 'Select Month',
        startDatePlaceholder: 'Start Date',
        endDatePlaceholder: 'End Date',
        startDatetimePlaceholder: 'Start Date and Time',
        endDatetimePlaceholder: 'End Date and Time',
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: 'Today'
    },
    DataTable: {
        checkTableAll: 'Select all in the table',
        uncheckTableAll: 'Unselect all in the table',
        confirm: 'Confirm',
        clear: 'Clear'
    },
    Transfer: {
        sourceTitle: 'Source',
        targetTitle: 'Target'
    },
    Empty: {
        description: 'No Data'
    },
    Select: {
        placeholder: 'Please Select'
    },
    TimePicker: {
        placeholder: 'Select Time',
        positiveText: 'OK',
        negativeText: 'Cancel',
        now: 'Now'
    },
    Pagination: {
        goto: 'Goto',
        selectionSuffix: 'page'
    },
    DynamicTags: {
        add: 'Add'
    },
    Log: {
        loading: 'Loading'
    },
    Input: {
        placeholder: 'Please Input'
    },
    InputNumber: {
        placeholder: 'Please Input'
    },
    DynamicInput: {
        create: 'Create'
    },
    ThemeEditor: {
        title: 'Theme Editor',
        clearAllVars: 'Clear All Variables',
        clearSearch: 'Clear Search',
        filterCompName: 'Filter Component Name',
        filterVarName: 'Filter Variable Name',
        import: 'Import',
        export: 'Export',
        restore: 'Reset to Default'
    }
};
/* harmony default export */ var common_enUS = (enUS);

// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function (token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ var _lib_formatDistance = (formatDistance);
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ var _lib_formatLong = (formatLong);
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ var _lib_formatRelative = (formatRelative);
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challange you to try to remove it!

    return valuesArray[index];
  };
}
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function (dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ var _lib_localize = (localize);
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js


var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ var _lib_match = (match);
// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/index.js






/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var en_US_locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance,
  formatLong: _lib_formatLong,
  formatRelative: _lib_formatRelative,
  localize: _lib_localize,
  match: _lib_match,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ var en_US = (en_US_locale);
// CONCATENATED MODULE: ./node_modules/naive-ui/es/locales/date/enUS.js

const dateEnUs = {
    name: 'en-US',
    locale: en_US
};
/* harmony default export */ var date_enUS = (dateEnUs);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_mixins/use-locale.js



function createLocaleMixin(ns) {
    const { mergedLocaleRef, mergedDateLocaleRef } = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(configProviderInjectionKey, null) || {};
    const localeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        var _a, _b;
        return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : common_enUS[ns];
    });
    const dateLocaleRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
        var _a;
        return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : date_enUS;
    });
    return {
        dateLocaleRef,
        localeRef
    };
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/styles/_common.js
/* harmony default export */ var input_styles_common = ({
    paddingTiny: '0 8px',
    paddingSmall: '0 10px',
    paddingMedium: '0 12px',
    paddingLarge: '0 14px',
    clearSize: '16px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/styles/light.js



const input_styles_light_self = (vars) => {
    const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, borderColor, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, actionColor, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
    return Object.assign(Object.assign({}, input_styles_common), { countTextColor: textColor3, heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight, lineHeightTextarea: lineHeight, borderRadius, iconSize: '16px', groupLabelColor: actionColor, groupLabelTextColor: textColor2, textColor: textColor2, textColorDisabled, textDecorationColor: textColor2, caretColor: primaryColor, placeholderColor,
        placeholderColorDisabled, color: inputColor, colorDisabled: inputColorDisabled, colorFocus: inputColor, groupLabelBorder: `1px solid ${borderColor}`, border: `1px solid ${borderColor}`, borderHover: `1px solid ${primaryColorHover}`, borderDisabled: `1px solid ${borderColor}`, borderFocus: `1px solid ${primaryColorHover}`, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`, loadingColor: primaryColor, 
        // warning
        loadingColorWarning: warningColor, borderWarning: `1px solid ${warningColor}`, borderHoverWarning: `1px solid ${warningColorHover}`, colorFocusWarning: inputColor, borderFocusWarning: `1px solid ${warningColorHover}`, boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
            alpha: 0.2
        })}`, caretColorWarning: warningColor, 
        // error
        loadingColorError: errorColor, borderError: `1px solid ${errorColor}`, borderHoverError: `1px solid ${errorColorHover}`, colorFocusError: inputColor, borderFocusError: `1px solid ${errorColorHover}`, boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
            alpha: 0.2
        })}`, caretColorError: errorColor, clearColor,
        clearColorHover,
        clearColorPressed,
        iconColor,
        iconColorDisabled,
        iconColorHover,
        iconColorPressed, suffixTextColor: textColor2 });
};
const inputLight = {
    name: 'Input',
    common: light,
    self: input_styles_light_self
};
/* harmony default export */ var input_styles_light = (inputLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/src/interface.js
const inputInjectionKey = Symbol('input');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/src/utils.js
function len(s) {
    let count = 0;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const _ of s) {
        count++;
    }
    return count;
}
function isEmptyValue(value) {
    return ['', undefined, null].includes(value);
}

// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/src/WordCount.js



/* harmony default export */ var WordCount = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'InputWordCount',
    setup(_, { slots }) {
        const { mergedValueRef, maxlengthRef, mergedClsPrefixRef } = 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(inputInjectionKey);
        const wordCountRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: mergedValue } = mergedValueRef;
            if (mergedValue === null || Array.isArray(mergedValue))
                return 0;
            return len(mergedValue);
        });
        return () => {
            const { value: maxlength } = maxlengthRef;
            const { value: mergedValue } = mergedValueRef;
            return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", { class: `${mergedClsPrefixRef.value}-input-word-count` }, slots.default
                ? slots.default({
                    value: mergedValue === null || Array.isArray(mergedValue)
                        ? ''
                        : mergedValue
                })
                : maxlength === undefined
                    ? wordCountRef.value
                    : `${wordCountRef.value} / ${maxlength}`));
        };
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/src/styles/input.cssr.js
 // vars:
// --bezier
// --color
// --font-size
// --border-radius
// --height
// --padding-left
// --padding-right
// --text-color
// --text-color-disabled
// --caret-color
// --text-decoration-color
// --border
// --border-disabled
// --border-hover
// --border-focus
// --placeholder-color
// --placeholder-color-disabled
// --line-height-textarea
// --color-disabled
// --color-focus
// --box-shadow-focus
// --clear-color
// --clear-size
// --clear-color-hover
// --clear-color-pressed
// --suffix-text-color
// --icon-color
// --icon-color-hover
// --icon-color-pressed
// --icon-color-disabled
// --count-text-color
// --loading-color
// ...form item vars

/* harmony default export */ var input_cssr = (cssr_c([cB('input', `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--border-radius);
 background-color: var(--color);
 transition: background-color .3s var(--bezier);
 font-size: var(--font-size);
 --padding-vertical: calc((var(--height) - 1.5 * var(--font-size)) / 2);
 `, [// common
cE('input, textarea', `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), cE('input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder', `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 caret-color .3s var(--bezier),
 color .3s var(--bezier),
 text-decoration-color .3s var(--bezier);
 `), cE('input-el, textarea-el', `
 -webkit-appearance: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--text-decoration-color);
 color: var(--text-color);
 caret-color: var(--caret-color);
 `, [cssr_c('&::placeholder', {
  color: '#0000'
})]), cM('round', [cNotM('textarea', {
  borderRadius: 'calc(var(--height) / 2)'
})]), cE('placeholder', `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--placeholder-color);
 `, [cssr_c('span', {
  width: '100%',
  display: 'inline-block'
})]), cNotM('autosize', {
  width: '100%'
}), cM('autosize', [cE('textarea-el, input-el', `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), // input
cB('input-wrapper', `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--padding-left);
 padding-right: var(--padding-right);
 `), cE('input-mirror', `
 padding: 0;
 height: var(--height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: nowrap;
 pointer-events: none;
 `), cE('input-el', `
 padding: 0;
 height: var(--height);
 line-height: var(--height);
 `, [cssr_c('+', [cE('placeholder', `
 display: flex;
 align-items: center; 
 `)])]), cNotM('textarea', [cE('placeholder', {
  whiteSpace: 'nowrap'
})]), cE('eye', `
 transition: color .3s var(--bezier);
 `), // textarea
cM('textarea', {
  width: '100%'
}, [cB('input-word-count', `
 position: absolute;
 right: var(--padding-right);
 bottom: var(--padding-vertical);
 `), cM('resizable', [cB('input-wrapper', `
 resize: vertical;
 overflow: auto;
 min-height: var(--height);
 `)]), cE('textarea-el, textarea-mirror, placeholder', `
 width: 100%;
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--padding-vertical);
 padding-bottom: var(--padding-vertical);
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--line-height-textarea);
 margin: 0;
 resize: none;
 `), cE('textarea-mirror', `
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), // pair
cM('pair', [cE('input-el, placeholder', {
  textAlign: 'center'
}), cE('separator', `
 display: flex;
 align-items: center;
 transition: color .3s var(--bezier);
 color: var(--text-color);
 `, [cB('icon', `
 color: var(--icon-color);
 `), cB('base-icon', `
 color: var(--icon-color);
 `)])]), cM('disabled', {
  cursor: 'not-allowed',
  backgroundColor: 'var(--color-disabled)'
}, [cE('border', {
  border: 'var(--border-disabled)'
}), cE('input-el, textarea-el', {
  cursor: 'not-allowed',
  color: 'var(--text-color-disabled)',
  textDecorationColor: 'var(--text-color-disabled)'
}), cE('placeholder', {
  color: 'var(--placeholder-color-disabled)'
}), cE('separator', {
  color: 'var(--text-color-disabled)'
}, [cB('icon', `
 color: var(--icon-color-disabled);
 `), cB('base-icon', `
 color: var(--icon-color-disabled);
 `)]), cE('suffix, prefix', {
  color: 'var(--text-color-disabled)'
}, [cB('icon', `
 color: var(--icon-color-disabled);
 `), cB('internal-icon', `
 color: var(--icon-color-disabled);
 `)])]), cNotM('disabled', [cE('eye', `
 color: var(--icon-color);
 cursor: pointer;
 `, [cssr_c('&:hover', `
 color: var(--icon-color-hover);
 `), cssr_c('&:active', `
 color: var(--icon-color-pressed);
 `)]), cM('focus', {
  backgroundColor: 'var(--color-focus)'
}, [cE('state-border', {
  border: 'var(--border-focus)',
  boxShadow: 'var(--box-shadow-focus)'
})]), cssr_c('&:hover', [cE('state-border', {
  border: 'var(--border-focus)'
})])]), cE('border, state-border', `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--border);
 transition:
 box-shadow .3s var(--bezier),
 border-color .3s var(--bezier);
 `), cE('state-border', `
 border-color: #0000;
 z-index: 1;
 `), cE('prefix', {
  marginRight: '4px'
}), cE('suffix', `
 margin-left: 4px;
 `), cE('suffix, prefix', `
 transition: color .3s var(--bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--suffix-text-color);
 `, [cB('base-loading', `
 font-size: var(--icon-size);
 margin-left: 4px;
 color: var(--loading-color);
 `), cB('base-clear', `
 font-size: var(--icon-size);
 margin-left: 4px;
 `, [cE('placeholder', [cB('base-icon', `
 transition: color .3s var(--bezier);
 color: var(--icon-color);
 font-size: var(--icon-size);
 `)])]), cB('icon', `
 transition: color .3s var(--bezier);
 color: var(--icon-color);
 font-size: var(--icon-size);
 `), cB('base-icon', `
 font-size: var(--icon-size);
 `)]), cB('input-word-count', `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--count-text-color);
 transition: color .3s var(--bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `)]), ['warning', 'error'].map(status => insideFormItem(status, cB('input', [cNotM('disabled', [cB('base-loading', `
 color: var(--loading-color-${status})
 `), cE('input-el, textarea-el', {
  caretColor: `var(--caret-color-${status})`
}), cE('state-border', {
  border: `var(--border-${status})`
}), cssr_c('&:hover', [cE('state-border', `
 border: var(--border-hover-${status});
 `)]), cssr_c('&:focus', {
  backgroundColor: `var(--color-focus-${status})`
}, [cE('state-border', `
 box-shadow: var(--box-shadow-focus-${status});
 border: var(--border-focus-${status});
 `)]), cM('focus', {
  backgroundColor: `var(--color-focus-${status})`
}, [cE('state-border', `
 box-shadow: var(--box-shadow-focus-${status});
 border: var(--border-focus-${status});
 `)])])])))]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/input/src/Input.js














const inputProps = Object.assign(Object.assign({}, use_theme.props), { bordered: {
        type: Boolean,
        default: undefined
    }, type: {
        type: String,
        default: 'text'
    }, placeholder: [Array, String], defaultValue: {
        type: [String, Array],
        default: null
    }, value: [String, Array], disabled: {
        type: Boolean,
        default: undefined
    }, size: String, rows: {
        type: [Number, String],
        default: 3
    }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: {
        type: [Boolean, Object],
        default: false
    }, pair: Boolean, separator: String, readonly: {
        type: [String, Boolean],
        default: false
    }, passivelyActivated: Boolean, showPasswordOn: String, stateful: {
        type: Boolean,
        default: true
    }, autofocus: Boolean, inputProps: Object, resizable: {
        type: Boolean,
        default: true
    }, showCount: Boolean, loading: {
        type: Boolean,
        default: undefined
    }, onMousedown: Function, onKeydown: Function, onKeyup: Function, onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 
    /** private */
    textDecoration: [String, Array], attrSize: {
        type: Number,
        default: 20
    }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, 
    /** deprecated */
    showPasswordToggle: Boolean });
/* harmony default export */ var Input = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Input',
    props: inputProps,
    setup(props) {
        if (false) {}
        const { mergedClsPrefixRef, mergedBorderedRef } = useConfig(props);
        const themeRef = use_theme('Input', 'Input', input_cssr, input_styles_light, props, mergedClsPrefixRef);
        // dom refs
        const wrapperElRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const textareaElRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const textareaMirrorElRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const inputMirrorElRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const inputElRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const inputEl2Ref = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        // local
        const { localeRef } = createLocaleMixin('Input');
        // value
        const uncontrolledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultValue);
        const controlledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'value');
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        // form-item
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        // states
        const focusedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        const hoverRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        const isComposingRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        const activatedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        let syncSource = null;
        // placeholder
        const mergedPlaceholderRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { placeholder, pair } = props;
            if (pair) {
                if (Array.isArray(placeholder)) {
                    return placeholder;
                }
                else if (placeholder === undefined) {
                    return ['', ''];
                }
                return [placeholder, placeholder];
            }
            else if (placeholder === undefined) {
                return [localeRef.value.placeholder];
            }
            else {
                return [placeholder];
            }
        });
        const showPlaceholder1Ref = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: isComposing } = isComposingRef;
            const { value: mergedValue } = mergedValueRef;
            const { value: mergedPlaceholder } = mergedPlaceholderRef;
            return (!isComposing &&
                (isEmptyValue(mergedValue) ||
                    (Array.isArray(mergedValue) && isEmptyValue(mergedValue[0]))) &&
                mergedPlaceholder[0]);
        });
        const showPlaceholder2Ref = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: isComposing } = isComposingRef;
            const { value: mergedValue } = mergedValueRef;
            const { value: mergedPlaceholder } = mergedPlaceholderRef;
            return (!isComposing &&
                mergedPlaceholder[1] &&
                (isEmptyValue(mergedValue) ||
                    (Array.isArray(mergedValue) && isEmptyValue(mergedValue[1]))));
        });
        // focus
        const mergedFocusRef = use_memo(() => {
            return props.internalForceFocus || focusedRef.value;
        });
        // clear
        const showClearButton = use_memo(() => {
            if (mergedDisabledRef.value ||
                props.readonly ||
                !props.clearable ||
                (!mergedFocusRef.value && !hoverRef.value)) {
                return false;
            }
            const { value: mergedValue } = mergedValueRef;
            const { value: mergedFocus } = mergedFocusRef;
            if (props.pair) {
                return (!!(Array.isArray(mergedValue) &&
                    (mergedValue[0] || mergedValue[1])) &&
                    (hoverRef.value || mergedFocus));
            }
            else {
                return !!mergedValue && (hoverRef.value || mergedFocus);
            }
        });
        // passwordVisible
        const mergedShowPasswordOnRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { showPasswordOn } = props;
            if (showPasswordOn) {
                return showPasswordOn;
            }
            if (props.showPasswordToggle)
                return 'click';
            return undefined;
        });
        const passwordVisibleRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        // text-decoration
        const textDecorationStyleRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { textDecoration } = props;
            if (!textDecoration)
                return ['', ''];
            if (Array.isArray(textDecoration)) {
                return textDecoration.map((v) => ({
                    textDecoration: v
                }));
            }
            return [
                {
                    textDecoration
                }
            ];
        });
        // textarea autosize
        const updateTextAreaStyle = () => {
            if (props.type === 'textarea') {
                const { autosize } = props;
                if (typeof autosize === 'boolean')
                    return;
                if (!textareaElRef.value)
                    return;
                const { paddingTop: stylePaddingTop, paddingBottom: stylePaddingBottom, lineHeight: styleLineHeight } = window.getComputedStyle(textareaElRef.value);
                const paddingTop = Number(stylePaddingTop.slice(0, -2));
                const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
                const lineHeight = Number(styleLineHeight.slice(0, -2));
                const { value: textareaMirrorEl } = textareaMirrorElRef;
                if (!textareaMirrorEl)
                    return;
                if (autosize.minRows) {
                    const minRows = Math.max(autosize.minRows, 1);
                    const styleMinHeight = `${paddingTop + paddingBottom + lineHeight * minRows}px`;
                    textareaMirrorEl.style.minHeight = styleMinHeight;
                }
                if (autosize.maxRows) {
                    const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight * autosize.maxRows}px`;
                    textareaMirrorEl.style.maxHeight = styleMaxHeight;
                }
            }
        };
        // word count
        const maxlengthRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { maxlength } = props;
            return maxlength === undefined ? undefined : Number(maxlength);
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
            // sync mirror if is not pair
            const { value } = mergedValueRef;
            if (!Array.isArray(value)) {
                syncMirror(value);
            }
        });
        // other methods
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vm = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])().proxy;
        function doUpdateValue(value) {
            const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onInput } = props;
            const { nTriggerFormInput } = formItem;
            if (onUpdateValue)
                call(onUpdateValue, value);
            if (_onUpdateValue)
                call(_onUpdateValue, value);
            if (onInput)
                call(onInput, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
        }
        function doChange(value) {
            const { onChange } = props;
            const { nTriggerFormChange } = formItem;
            if (onChange)
                call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
        }
        function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
                call(onBlur, e);
            nTriggerFormBlur();
        }
        function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
                call(onFocus, e);
            nTriggerFormFocus();
        }
        function doClear(e) {
            const { onClear } = props;
            if (onClear)
                call(onClear, e);
        }
        function doUpdateValueBlur(e) {
            const { onInputBlur } = props;
            if (onInputBlur)
                call(onInputBlur, e);
        }
        function doUpdateValueFocus(e) {
            const { onInputFocus } = props;
            if (onInputFocus)
                call(onInputFocus, e);
        }
        function doDeactivate() {
            const { onDeactivate } = props;
            if (onDeactivate)
                call(onDeactivate);
        }
        function doActivate() {
            const { onActivate } = props;
            if (onActivate)
                call(onActivate);
        }
        function doClick(e) {
            const { onClick } = props;
            if (onClick)
                call(onClick, e);
        }
        function doWrapperFocus(e) {
            const { onWrapperFocus } = props;
            if (onWrapperFocus)
                call(onWrapperFocus, e);
        }
        function doWrapperBlur(e) {
            const { onWrapperBlur } = props;
            if (onWrapperBlur)
                call(onWrapperBlur, e);
        }
        // methods
        function handleCompositionStart() {
            isComposingRef.value = true;
        }
        function handleCompositionEnd(e) {
            isComposingRef.value = false;
            if (e.target === inputEl2Ref.value) {
                handleInput(e, 1);
            }
            else {
                handleInput(e, 0);
            }
        }
        function handleInput(e, index = 0, event = 'input') {
            const targetValue = e.target.value;
            syncMirror(targetValue);
            syncSource = targetValue;
            if (isComposingRef.value)
                return;
            const changedValue = targetValue;
            if (!props.pair) {
                event === 'input' ? doUpdateValue(changedValue) : doChange(changedValue);
            }
            else {
                let { value } = mergedValueRef;
                if (!Array.isArray(value)) {
                    value = ['', ''];
                }
                else {
                    value = [...value];
                }
                value[index] = changedValue;
                event === 'input' ? doUpdateValue(value) : doChange(value);
            }
            // force update to sync input's view with value
            // if not set, after input, input value won't sync with dom input value
            ;
            vm.$forceUpdate();
        }
        function handleInputBlur(e) {
            doUpdateValueBlur(e);
            if (e.relatedTarget === wrapperElRef.value) {
                doDeactivate();
            }
            if (!(e.relatedTarget !== null &&
                (e.relatedTarget === inputElRef.value ||
                    e.relatedTarget === inputEl2Ref.value ||
                    e.relatedTarget === textareaElRef.value))) {
                activatedRef.value = false;
            }
            dealWithEvent(e, 'blur');
        }
        function handleInputFocus(e) {
            doUpdateValueFocus(e);
            focusedRef.value = true;
            activatedRef.value = true;
            doActivate();
            dealWithEvent(e, 'focus');
        }
        function handleWrapperBlur(e) {
            if (props.passivelyActivated) {
                doWrapperBlur(e);
                dealWithEvent(e, 'blur');
            }
        }
        function handleWrapperFocus(e) {
            if (props.passivelyActivated) {
                focusedRef.value = true;
                doWrapperFocus(e);
                dealWithEvent(e, 'focus');
            }
        }
        function dealWithEvent(e, type) {
            if (e.relatedTarget !== null &&
                (e.relatedTarget === inputElRef.value ||
                    e.relatedTarget === inputEl2Ref.value ||
                    e.relatedTarget === textareaElRef.value ||
                    e.relatedTarget === wrapperElRef.value)) {
                /**
                 * activeElement transfer inside the input, do nothing
                 */
            }
            else {
                if (type === 'focus') {
                    doFocus(e);
                    focusedRef.value = true;
                }
                else if (type === 'blur') {
                    doBlur(e);
                    focusedRef.value = false;
                }
            }
        }
        function handleChange(e, index) {
            handleInput(e, index, 'change');
        }
        function handleClick(e) {
            doClick(e);
        }
        function handleClear(e) {
            doClear(e);
            if (props.pair) {
                doUpdateValue(['', '']);
            }
            else {
                doUpdateValue('');
            }
        }
        function handleMouseDown(e) {
            const { onMousedown } = props;
            if (onMousedown)
                onMousedown(e);
            const { tagName } = e.target;
            if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
                if (props.resizable) {
                    const { value: wrapperEl } = wrapperElRef;
                    if (wrapperEl) {
                        const { left, top, width, height } = wrapperEl.getBoundingClientRect();
                        const resizeHandleSize = 14;
                        if (left + width - resizeHandleSize < e.clientX &&
                            e.clientY < left + width &&
                            top + height - resizeHandleSize < e.clientY &&
                            e.clientY < top + height) {
                            // touching resize handle, just let it go.
                            // resize won't take focus, maybe there is a better way to do this.
                            // hope someone can figure out a better solution
                            return;
                        }
                    }
                }
                e.preventDefault();
                if (!focusedRef.value) {
                    focus();
                }
            }
        }
        function handleMouseEnter() {
            hoverRef.value = true;
        }
        function handleMouseLeave() {
            hoverRef.value = false;
        }
        function handlePasswordToggleClick() {
            if (mergedDisabledRef.value)
                return;
            if (mergedShowPasswordOnRef.value !== 'click')
                return;
            passwordVisibleRef.value = !passwordVisibleRef.value;
        }
        function handlePasswordToggleMousedown(e) {
            if (mergedDisabledRef.value)
                return;
            e.preventDefault();
            const preventDefaultOnce = (e) => {
                e.preventDefault();
                delegate_off('mouseup', document, preventDefaultOnce);
            };
            delegate_on('mouseup', document, preventDefaultOnce);
            if (mergedShowPasswordOnRef.value !== 'mousedown')
                return;
            passwordVisibleRef.value = true;
            const hidePassword = () => {
                passwordVisibleRef.value = false;
                delegate_off('mouseup', document, hidePassword);
            };
            delegate_on('mouseup', document, hidePassword);
        }
        function handleWrapperKeyDown(e) {
            var _a;
            (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            switch (e.code) {
                case 'Escape':
                    handleWrapperKeyDownEsc();
                    break;
                case 'Enter':
                case 'NumpadEnter':
                    handleWrapperKeyDownEnter(e);
                    break;
            }
        }
        function handleWrapperKeyDownEnter(e) {
            var _a, _b;
            if (props.passivelyActivated) {
                const { value: focused } = activatedRef;
                if (focused) {
                    if (props.internalDeactivateOnEnter) {
                        handleWrapperKeyDownEsc();
                    }
                    return;
                }
                e.preventDefault();
                if (props.type === 'textarea') {
                    (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                }
                else {
                    (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
                }
            }
        }
        function handleWrapperKeyDownEsc() {
            if (props.passivelyActivated) {
                activatedRef.value = false;
                void Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(() => {
                    var _a;
                    (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                });
            }
        }
        function focus() {
            var _a, _b, _c;
            if (mergedDisabledRef.value)
                return;
            if (props.passivelyActivated) {
                (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            }
            else {
                (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
                (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
            }
        }
        function blur() {
            var _a;
            if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
                ;
                document.activeElement.blur();
            }
        }
        function select() {
            var _a, _b;
            (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
            (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
        }
        function activate() {
            if (mergedDisabledRef.value)
                return;
            if (textareaElRef.value)
                textareaElRef.value.focus();
            else if (inputElRef.value)
                inputElRef.value.focus();
        }
        function deactivate() {
            const { value: wrapperEl } = wrapperElRef;
            if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) &&
                wrapperEl !== document.activeElement) {
                handleWrapperKeyDownEsc();
            }
        }
        function syncMirror(value) {
            const { type, pair, autosize } = props;
            if (!pair && autosize) {
                if (type === 'textarea') {
                    const { value: textareaMirrorEl } = textareaMirrorElRef;
                    if (textareaMirrorEl) {
                        textareaMirrorEl.textContent = (value !== null && value !== void 0 ? value : '') + '\r\n';
                    }
                }
                else {
                    const { value: inputMirrorEl } = inputMirrorElRef;
                    if (inputMirrorEl) {
                        if (value) {
                            inputMirrorEl.textContent = value;
                        }
                        else {
                            inputMirrorEl.innerHTML = '&nbsp;';
                        }
                    }
                }
            }
        }
        function handleTextAreaMirrorResize() {
            updateTextAreaStyle();
        }
        let stopWatchMergedValue = null;
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(() => {
            const { autosize, type } = props;
            if (autosize && type === 'textarea') {
                stopWatchMergedValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(mergedValueRef, (value) => {
                    if (!Array.isArray(value) && value !== syncSource) {
                        syncMirror(value);
                    }
                });
            }
            else {
                stopWatchMergedValue === null || stopWatchMergedValue === void 0 ? void 0 : stopWatchMergedValue();
            }
        });
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(inputInjectionKey, {
            mergedValueRef,
            maxlengthRef,
            mergedClsPrefixRef
        });
        const exposedProps = {
            wrapperElRef,
            inputElRef,
            textareaElRef,
            isCompositing: isComposingRef,
            focus,
            blur,
            select,
            deactivate,
            activate
        };
        return Object.assign(Object.assign({}, exposedProps), { 
            // DOM ref
            wrapperElRef,
            inputElRef,
            inputMirrorElRef,
            inputEl2Ref,
            textareaElRef,
            textareaMirrorElRef, 
            // value
            uncontrolledValue: uncontrolledValueRef, mergedValue: mergedValueRef, passwordVisible: passwordVisibleRef, mergedPlaceholder: mergedPlaceholderRef, showPlaceholder1: showPlaceholder1Ref, showPlaceholder2: showPlaceholder2Ref, mergedFocus: mergedFocusRef, isComposing: isComposingRef, activated: activatedRef, showClearButton, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, textDecorationStyle: textDecorationStyleRef, mergedClsPrefix: mergedClsPrefixRef, mergedBordered: mergedBorderedRef, mergedShowPasswordOn: mergedShowPasswordOnRef, 
            // methods
            handleCompositionStart,
            handleCompositionEnd,
            handleInput,
            handleInputBlur,
            handleInputFocus,
            handleWrapperBlur,
            handleWrapperFocus,
            handleMouseEnter,
            handleMouseLeave,
            handleMouseDown,
            handleChange,
            handleClick,
            handleClear,
            handlePasswordToggleClick,
            handlePasswordToggleMousedown,
            handleWrapperKeyDown,
            handleTextAreaMirrorResize, mergedTheme: themeRef, cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { value: size } = mergedSizeRef;
                const { common: { cubicBezierEaseInOut }, self: { color, borderRadius, textColor, caretColor, caretColorError, caretColorWarning, textDecorationColor, border, borderDisabled, borderHover, borderFocus, placeholderColor, placeholderColorDisabled, lineHeightTextarea, colorDisabled, colorFocus, textColorDisabled, boxShadowFocus, iconSize, colorFocusWarning, boxShadowFocusWarning, borderWarning, borderFocusWarning, borderHoverWarning, colorFocusError, boxShadowFocusError, borderError, borderFocusError, borderHoverError, clearSize, clearColor, clearColorHover, clearColorPressed, iconColor, iconColorDisabled, suffixTextColor, countTextColor, iconColorHover, iconColorPressed, loadingColor, loadingColorError, loadingColorWarning, [createKey('padding', size)]: padding, [createKey('fontSize', size)]: fontSize, [createKey('height', size)]: height } } = themeRef.value;
                const { left: paddingLeft, right: paddingRight } = getMargin(padding);
                return {
                    '--bezier': cubicBezierEaseInOut,
                    '--count-text-color': countTextColor,
                    '--color': color,
                    '--font-size': fontSize,
                    '--border-radius': borderRadius,
                    '--height': height,
                    '--padding-left': paddingLeft,
                    '--padding-right': paddingRight,
                    '--text-color': textColor,
                    '--caret-color': caretColor,
                    '--text-decoration-color': textDecorationColor,
                    '--border': border,
                    '--border-disabled': borderDisabled,
                    '--border-hover': borderHover,
                    '--border-focus': borderFocus,
                    '--placeholder-color': placeholderColor,
                    '--placeholder-color-disabled': placeholderColorDisabled,
                    '--icon-size': iconSize,
                    '--line-height-textarea': lineHeightTextarea,
                    '--color-disabled': colorDisabled,
                    '--color-focus': colorFocus,
                    '--text-color-disabled': textColorDisabled,
                    '--box-shadow-focus': boxShadowFocus,
                    '--loading-color': loadingColor,
                    // form warning
                    '--caret-color-warning': caretColorWarning,
                    '--color-focus-warning': colorFocusWarning,
                    '--box-shadow-focus-warning': boxShadowFocusWarning,
                    '--border-warning': borderWarning,
                    '--border-focus-warning': borderFocusWarning,
                    '--border-hover-warning': borderHoverWarning,
                    '--loading-color-warning': loadingColorWarning,
                    // form error
                    '--caret-color-error': caretColorError,
                    '--color-focus-error': colorFocusError,
                    '--box-shadow-focus-error': boxShadowFocusError,
                    '--border-error': borderError,
                    '--border-focus-error': borderFocusError,
                    '--border-hover-error': borderHoverError,
                    '--loading-color-error': loadingColorError,
                    // clear-button
                    '--clear-color': clearColor,
                    '--clear-size': clearSize,
                    '--clear-color-hover': clearColorHover,
                    '--clear-color-pressed': clearColorPressed,
                    '--icon-color': iconColor,
                    '--icon-color-hover': iconColorHover,
                    '--icon-color-pressed': iconColorPressed,
                    '--icon-color-disabled': iconColorDisabled,
                    '--suffix-text-color': suffixTextColor
                };
            }) });
    },
    render() {
        const { mergedClsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "wrapperElRef", class: [
                `${mergedClsPrefix}-input`,
                {
                    [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
                    [`${mergedClsPrefix}-input--textarea`]: this.type === 'textarea',
                    [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
                    [`${mergedClsPrefix}-input--autosize`]: this.autosize,
                    [`${mergedClsPrefix}-input--round`]: this.round && !(this.type === 'textarea'),
                    [`${mergedClsPrefix}-input--pair`]: this.pair,
                    [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
                    [`${mergedClsPrefix}-input--stateful`]: this.stateful
                }
            ], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated
                ? 0
                : undefined, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.onKeyup, onKeydown: this.handleWrapperKeyDown },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input-wrapper` },
                this.$slots.affix || this.$slots.prefix ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__prefix` }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'affix', undefined, () => {
                    return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'prefix')];
                }))) : null,
                this.type === 'textarea' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__textarea` },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: `${mergedClsPrefix}-input__textarea-el`, autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: this.maxlength, minlength: this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : undefined, style: this.textDecorationStyle[0], onBlur: this.handleInputBlur, onFocus: this.handleInputFocus, onInput: this.handleInput, onChange: this.handleChange })),
                    this.showPlaceholder1 ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__placeholder`, key: "placeholder" }, this.mergedPlaceholder[0])) : null,
                    this.autosize ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(VResizeObserver, { onResize: this.handleTextAreaMirrorResize }, {
                        default: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "textareaMirrorElRef", class: `${mergedClsPrefix}-input__textarea-mirror`, key: "mirror" }))
                    })) : null)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__input` },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", Object.assign({ type: this.type === 'password' &&
                            this.mergedShowPasswordOn &&
                            this.passwordVisible
                            ? 'text'
                            : this.type }, this.inputProps, { ref: "inputElRef", class: `${mergedClsPrefix}-input__input-el`, style: this.textDecorationStyle[0], tabindex: this.passivelyActivated && !this.activated ? -1 : undefined, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: this.maxlength, minlength: this.minlength, value: Array.isArray(this.mergedValue)
                            ? this.mergedValue[0]
                            : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: this.handleInputFocus, onInput: (e) => this.handleInput(e, 0), onChange: (e) => this.handleChange(e, 0) })),
                    this.showPlaceholder1 ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__placeholder` },
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", null, this.mergedPlaceholder[0]))) : null,
                    this.autosize ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\u00A0")) : null)),
                !this.pair &&
                    (this.$slots.suffix ||
                        this.clearable ||
                        this.showCount ||
                        this.mergedShowPasswordOn ||
                        this.loading !== undefined) ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                    this.clearable || this.$slots.clear ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Clear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, { default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'clear') })) : null,
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'suffix'),
                    this.loading !== undefined ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Suffix, { clsPrefix: mergedClsPrefix, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars })) : null,
                    this.showCount && this.type !== 'textarea' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(WordCount, null, { default: this.$slots.count })) : null,
                    this.mergedShowPasswordOn && this.type === 'password' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, {
                        default: () => this.passwordVisible ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Eye, null) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(EyeOff, null)
                    })) : null
                ])) : null),
            this.pair ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", { class: `${mergedClsPrefix}-input__separator` }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'separator', undefined, () => [
                this.separator
            ]))) : null,
            this.pair ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input-wrapper` },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__input` },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", { ref: "inputEl2Ref", type: this.type, class: `${mergedClsPrefix}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : undefined, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: this.maxlength, minlength: this.minlength, value: Array.isArray(this.mergedValue)
                            ? this.mergedValue[1]
                            : undefined, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: this.handleInputFocus, onInput: (e) => this.handleInput(e, 1), onChange: (e) => this.handleChange(e, 1) }),
                    this.showPlaceholder2 ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__placeholder` },
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", null, this.mergedPlaceholder[1]))) : null),
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                    this.clearable || this.$slots.clear ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Clear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, { default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'clear') })) : null,
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(this.$slots, 'suffix')
                ]))) : null,
            this.mergedBordered ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__border` })) : null,
            this.mergedBordered ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-input__state-border` })) : null,
            this.showCount && this.type === 'textarea' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(WordCount, null, { default: this.$slots.count })) : null));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/switch/styles/_common.js
/* harmony default export */ var switch_styles_common = ({
    buttonHeightSmall: '14px',
    buttonHeightMedium: '18px',
    buttonHeightLarge: '22px',
    buttonWidthSmall: '14px',
    buttonWidthMedium: '18px',
    buttonWidthLarge: '22px',
    buttonWidthPressedSmall: '20px',
    buttonWidthPressedMedium: '24px',
    buttonWidthPressedLarge: '28px',
    railHeightSmall: '18px',
    railHeightMedium: '22px',
    railHeightLarge: '26px',
    railWidthSmall: '32px',
    railWidthMedium: '40px',
    railWidthLarge: '48px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/switch/styles/light.js



const switch_styles_light_self = (vars) => {
    const { primaryColor, opacityDisabled, borderRadius } = vars;
    const railOverlayColor = 'rgba(0, 0, 0, .14)';
    return Object.assign(Object.assign({}, switch_styles_common), { textColor: 'white', loadingColor: primaryColor, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColor, buttonBoxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)', buttonColor: '#FFF', railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}` });
};
const switchLight = {
    name: 'Switch',
    common: light,
    self: switch_styles_light_self
};
/* harmony default export */ var switch_styles_light = (switchLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/switch/src/styles/index.cssr.js

 // vars:
// --bezier
// --button-border-radius
// --button-box-shadow
// --button-color
// --button-width
// --button-width-pressed
// --height
// --offset
// --rail-border-radius
// --rail-color
// --rail-color-active
// --rail-height
// --rail-width
// --width
// --box-shadow-focus
// --loading-color
// --text-color

/* harmony default export */ var switch_src_styles_index_cssr = (cB('switch', `
 height: var(--height);
 min-width: var(--width);
 vertical-align: middle;
 user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE('children-placeholder', `
 height: var(--rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE('rail-placeholder', `
 display: flex;
 flex-wrap: none;
 `), cE('button-placeholder', `
 width: calc(1.75 * var(--rail-height));
 height: var(--rail-height);
 `), cB('base-loading', `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--button-width) - 4px);
 color: var(--loading-color);
 transition: color .3s var(--bezier);
 `, [fade_in_scale_up_cssr({
  originalTransform: 'translateX(-50%) translateY(-50%)'
})]), cE('checked, unchecked', `
 transition: color .3s var(--bezier);
 color: var(--text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE('checked', `
 right: 0;
 padding-right: calc(1.25 * var(--rail-height) - var(--offset));
 `), cE('unchecked', `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--rail-height) - var(--offset));
 `), cssr_c('&:focus', [cE('rail', `
 box-shadow: var(--box-shadow-focus);
 `)]), cM('round', [cE('rail', {
  borderRadius: 'calc(var(--rail-height) / 2)'
}, [cE('button', {
  borderRadius: 'calc(var(--button-height) / 2)'
})])]), cNotM('disabled', [cM('pressed', [cE('rail', [cE('button', {
  maxWidth: 'var(--button-width-pressed)'
})])]), cE('rail', [cssr_c('&:active', [cE('button', {
  maxWidth: 'var(--button-width-pressed)'
})])]), cM('active', [cM('pressed', [cE('rail', [cE('button', {
  left: 'calc(100% - var(--offset) - var(--button-width-pressed))'
})])]), cE('rail', [cssr_c('&:active', [cE('button', {
  left: 'calc(100% - var(--offset) - var(--button-width-pressed))'
})])])])]), cM('active', [cE('rail', [cE('button', {
  left: 'calc(100% - (var(--rail-height) + var(--button-width)) / 2)'
})])]), cE('rail', `
 overflow: hidden;
 height: var(--rail-height);
 min-width: var(--rail-width);
 border-radius: var(--rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 background-color .3s var(--bezier),
 box-shadow .3s var(--bezier);
 background-color: var(--rail-color);
 `, [cE('button', `
 top: var(--offset);
 left: var(--offset);
 height: var(--button-width);
 width: var(--button-width-pressed);
 max-width: var(--button-width);
 border-radius: var(--button-border-radius);
 background-color: var(--button-color);
 box-shadow: var(--button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--bezier),
 left .3s var(--bezier),
 opacity .3s var(--bezier),
 max-width .3s var(--bezier),
 box-shadow .3s var(--bezier);
 `)]), cM('active', [cE('rail', {
  backgroundColor: 'var(--rail-color-active)'
})]), cM('disabled', [cE('rail', `
 cursor: not-allowed;
 opacity: .5;
 `)])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/switch/src/Switch.js








const switchProps = Object.assign(Object.assign({}, use_theme.props), { size: {
        type: String,
        default: 'medium'
    }, value: {
        type: [String, Number, Boolean],
        default: undefined
    }, loading: Boolean, defaultValue: {
        type: [String, Number, Boolean],
        default: false
    }, disabled: {
        type: Boolean,
        default: undefined
    }, round: {
        type: Boolean,
        default: true
    }, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], checkedValue: {
        type: [String, Number, Boolean],
        default: true
    }, uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
    }, 
    /** @deprecated */
    onChange: [Function, Array] });
/* harmony default export */ var Switch = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Switch',
    props: switchProps,
    setup(props) {
        if (false) {}
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = use_theme('Switch', 'Switch', switch_src_styles_index_cssr, switch_styles_light, props, mergedClsPrefixRef);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const uncontrolledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultValue);
        const controlledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'value');
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const pressedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
        function doUpdateValue(value) {
            const { 'onUpdate:value': _onUpdateValue, onChange, onUpdateValue } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (_onUpdateValue)
                call(_onUpdateValue, value);
            if (onUpdateValue)
                call(onUpdateValue, value);
            if (onChange)
                call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
        }
        function doFocus() {
            const { nTriggerFormFocus } = formItem;
            nTriggerFormFocus();
        }
        function doBlur() {
            const { nTriggerFormBlur } = formItem;
            nTriggerFormBlur();
        }
        function handleClick() {
            if (!mergedDisabledRef.value) {
                if (mergedValueRef.value !== props.checkedValue) {
                    doUpdateValue(props.checkedValue);
                }
                else {
                    doUpdateValue(props.uncheckedValue);
                }
            }
        }
        function handleFocus() {
            doFocus();
        }
        function handleBlur() {
            doBlur();
            pressedRef.value = false;
        }
        function handleKeyup(e) {
            if (e.code === 'Space') {
                doUpdateValue(!mergedValueRef.value);
                pressedRef.value = false;
            }
        }
        function handleKeydown(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                pressedRef.value = true;
            }
        }
        return {
            handleClick,
            handleBlur,
            handleFocus,
            handleKeyup,
            handleKeydown,
            pressed: pressedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            mergedDisabled: mergedDisabledRef,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { value: size } = mergedSizeRef;
                const { self: { opacityDisabled, railColor, railColorActive, buttonBoxShadow, buttonColor, boxShadowFocus, loadingColor, textColor, [createKey('buttonHeight', size)]: buttonHeight, [createKey('buttonWidth', size)]: buttonWidth, [createKey('buttonWidthPressed', size)]: buttonWidthPressed, [createKey('railHeight', size)]: railHeight, [createKey('railWidth', size)]: railWidth, [createKey('railBorderRadius', size)]: railBorderRadius, [createKey('buttonBorderRadius', size)]: buttonBorderRadius }, common: { cubicBezierEaseInOut } } = themeRef.value;
                const offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
                const height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
                const width = depx(railHeight) > depx(buttonHeight)
                    ? railWidth
                    : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
                return {
                    '--bezier': cubicBezierEaseInOut,
                    '--button-border-radius': buttonBorderRadius,
                    '--button-box-shadow': buttonBoxShadow,
                    '--button-color': buttonColor,
                    '--button-width': buttonWidth,
                    '--button-width-pressed': buttonWidthPressed,
                    '--button-height': buttonHeight,
                    '--height': height,
                    '--offset': offset,
                    '--opacity-disabled': opacityDisabled,
                    '--rail-border-radius': railBorderRadius,
                    '--rail-color': railColor,
                    '--rail-color-active': railColorActive,
                    '--rail-height': railHeight,
                    '--rail-width': railWidth,
                    '--width': width,
                    '--box-shadow-focus': boxShadowFocus,
                    '--loading-color': loadingColor,
                    '--text-color': textColor
                };
            })
        };
    },
    render() {
        const { mergedClsPrefix, mergedValue, mergedDisabled, checkedValue, $slots } = this;
        const checked = mergedValue === checkedValue;
        const { checked: checkedSlot, unchecked: uncheckedSlot } = $slots;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { role: "switch", "aria-checked": checked, class: [
                `${mergedClsPrefix}-switch`,
                checked && `${mergedClsPrefix}-switch--active`,
                mergedDisabled && `${mergedClsPrefix}-switch--disabled`,
                this.round && `${mergedClsPrefix}-switch--round`,
                this.pressed && `${mergedClsPrefix}-switch--pressed`
            ], tabindex: !this.mergedDisabled ? 0 : undefined, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-switch__rail`, "aria-hidden": "true" },
                (checkedSlot || uncheckedSlot) && (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { "aria-hidden": true, class: `${mergedClsPrefix}-switch__children-placeholder` },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }), checkedSlot === null || checkedSlot === void 0 ? void 0 :
                        checkedSlot()),
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }), uncheckedSlot === null || uncheckedSlot === void 0 ? void 0 :
                        uncheckedSlot()))),
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-switch__button` },
                    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], { name: "fade-in-scale-up-transition" }, {
                        default: () => this.loading ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Loading, { key: "loading", clsPrefix: mergedClsPrefix, strokeWidth: 20 })) : null
                    }),
                    checkedSlot && (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "checked", class: `${mergedClsPrefix}-switch__checked` }, checkedSlot())),
                    uncheckedSlot && (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: "unchecked", class: `${mergedClsPrefix}-switch__unchecked` }, uncheckedSlot()))))));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/styles/_common.js
/* harmony default export */ var radio_styles_common = ({
    radioSizeSmall: '14px',
    radioSizeMedium: '16px',
    radioSizeLarge: '18px',
    labelPadding: '0 8px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/styles/light.js



const radio_styles_light_self = (vars) => {
    const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge } = vars;
    return Object.assign(Object.assign({}, radio_styles_common), { buttonHeightSmall: heightSmall, buttonHeightMedium: heightMedium, buttonHeightLarge: heightLarge, fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge, boxShadow: `inset 0 0 0 1px ${borderColor}`, boxShadowActive: `inset 0 0 0 1px ${primaryColor}`, boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`, boxShadowHover: `inset 0 0 0 1px ${primaryColor}`, boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`, color: baseColor, colorDisabled: inputColorDisabled, textColor: textColor2, textColorDisabled: textColorDisabled, dotColorActive: primaryColor, dotColorDisabled: borderColor, buttonBorderColor: borderColor, buttonBorderColorActive: primaryColor, buttonBorderColorHover: borderColor, buttonColor: baseColor, buttonColorActive: baseColor, buttonTextColor: textColor2, buttonTextColorActive: primaryColor, buttonTextColorHover: primaryColor, opacityDisabled: opacityDisabled, buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`, buttonBoxShadowHover: 'inset 0 0 0 1px #0000', buttonBoxShadow: 'inset 0 0 0 1px #0000', buttonBorderRadius: borderRadius });
};
const radioLight = {
    name: 'Radio',
    common: light,
    self: radio_styles_light_self
};
/* harmony default export */ var radio_styles_light = (radioLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/src/use-radio.js




const radioProps = {
    name: String,
    value: {
        type: [String, Number],
        default: 'on'
    },
    checked: {
        type: Boolean,
        default: undefined
    },
    defaultChecked: Boolean,
    disabled: {
        type: Boolean,
        default: undefined
    },
    size: String,
    onUpdateChecked: [Function, Array],
    'onUpdate:checked': [Function, Array],
    // deprecated
    checkedValue: {
        type: Boolean,
        validator: () => {
            warn('radio', '`checked-value` is deprecated, please use `checked` instead.');
            return true;
        },
        default: undefined
    }
};
const radioGroupInjectionKey = Symbol('radioGroup');
function use_radio_setup(props) {
    const formItem = useFormItem(props, {
        mergedSize(NFormItem) {
            const { size } = props;
            if (size !== undefined)
                return size;
            if (NRadioGroup) {
                const { mergedSizeRef: { value: mergedSize } } = NRadioGroup;
                if (mergedSize !== undefined) {
                    return mergedSize;
                }
            }
            if (NFormItem) {
                return NFormItem.mergedSize.value;
            }
            return 'medium';
        },
        mergedDisabled(NFormItem) {
            if (props.disabled)
                return true;
            if (NRadioGroup === null || NRadioGroup === void 0 ? void 0 : NRadioGroup.disabledRef.value)
                return true;
            if (NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.disabled.value)
                return true;
            return false;
        }
    });
    const { mergedSizeRef, mergedDisabledRef } = formItem;
    const inputRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    const labelRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    const NRadioGroup = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(radioGroupInjectionKey, null);
    const uncontrolledCheckedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultChecked);
    const controlledCheckedRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'checked');
    const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
    const renderSafeCheckedRef = use_memo(() => {
        if (NRadioGroup)
            return NRadioGroup.valueRef.value === props.value;
        return mergedCheckedRef.value;
    });
    const mergedNameRef = use_memo(() => {
        const { name } = props;
        if (name !== undefined)
            return name;
        if (NRadioGroup)
            return NRadioGroup.nameRef.value;
    });
    const focusRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    function doUpdateChecked() {
        if (NRadioGroup) {
            const { doUpdateValue } = NRadioGroup;
            const { value } = props;
            call(doUpdateValue, value);
        }
        else {
            const { onUpdateChecked, 'onUpdate:checked': _onUpdateChecked } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateChecked)
                call(onUpdateChecked, true);
            if (_onUpdateChecked)
                call(_onUpdateChecked, true);
            nTriggerFormInput();
            nTriggerFormChange();
            uncontrolledCheckedRef.value = true;
        }
    }
    function toggle() {
        if (mergedDisabledRef.value)
            return;
        if (!renderSafeCheckedRef.value) {
            doUpdateChecked();
        }
    }
    function handleRadioInputChange() {
        toggle();
    }
    function handleRadioInputBlur() {
        focusRef.value = false;
    }
    function handleRadioInputFocus() {
        focusRef.value = true;
    }
    function handleKeyUp(e) {
        var _a;
        switch (e.code) {
            case 'Enter':
            case 'NumpadEnter':
                (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.click();
        }
    }
    function handleMouseDown() {
        if (mergedDisabledRef.value)
            return;
        setTimeout(() => {
            var _a, _b;
            if (!((_a = labelRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement))) {
                (_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.focus();
            }
        }, 0);
    }
    function handleClick() {
        var _a;
        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.click();
    }
    return {
        mergedClsPrefix: NRadioGroup
            ? NRadioGroup.mergedClsPrefixRef
            : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        uncontrolledChecked: uncontrolledCheckedRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus,
        handleKeyUp,
        handleMouseDown,
        handleClick
    };
}
use_radio_setup.props = radioProps;
/* harmony default export */ var use_radio = (use_radio_setup);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/src/styles/radio-group.cssr.js
 // vars:
// --bezier
// --button-border-color
// --height
// --opacity-disabled
// --font-size

/* harmony default export */ var radio_group_cssr = (cB('radio-group', `
 display: inline-block;
 font-size: var(--font-size);
`, [cE('splitor', `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--bezier),
 opacity .3s var(--bezier);
 background: var(--button-border-color);
 `, [cM('checked', {
  backgroundColor: 'var(--button-border-color-active)'
}), cM('disabled', {
  opacity: 'var(--opacity-disabled)'
})]), cM('button-group', `
 white-space: nowrap;
 height: var(--height);
 line-height: var(--height);
 `, [cB('radio-button', {
  height: 'var(--height)',
  lineHeight: 'var(--height)'
}), cE('splitor', {
  height: 'var(--height)'
})]), cB('radio-button', `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--bezier),
 opacity .3s var(--bezier),
 border-color .3s var(--bezier),
 color .3s var(--bezier);
 color: var(--button-text-color);
 border-top: 1px solid var(--button-border-color);
 border-bottom: 1px solid var(--button-border-color);
 `, [cE('radio-input', `
 border: 0;
 width: 0;
 height: 0;
 opacity: 0;
 margin: 0;
 `), cE('state-border', `
 pointer-events: none;
 position: absolute;
 box-shadow: var(--button-box-shadow);
 transition: box-shadow .3s var(--bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), cssr_c('&:first-child', `
 border-top-left-radius: var(--button-border-radius);
 border-bottom-left-radius: var(--button-border-radius);
 border-left: 1px solid var(--button-border-color);
 `, [cE('state-border', `
 border-top-left-radius: var(--button-border-radius);
 border-bottom-left-radius: var(--button-border-radius);
 `)]), cssr_c('&:last-child', `
 border-top-right-radius: var(--button-border-radius);
 border-bottom-right-radius: var(--button-border-radius);
 border-right: 1px solid var(--button-border-color);
 `, [cE('state-border', `
 border-top-right-radius: var(--button-border-radius);
 border-bottom-right-radius: var(--button-border-radius);
 `)]), cNotM('disabled', `
 cursor: pointer;
 `, [cssr_c('&:hover', [cE('state-border', `
 transition: box-shadow .3s var(--bezier);
 box-shadow: var(--button-box-shadow-hover);
 `), cNotM('checked', {
  color: 'var(--button-text-color-hover)'
})]), cM('focus', [cssr_c('&:not(:active)', [cE('state-border', {
  boxShadow: 'var(--button-box-shadow-focus)'
})])])]), cM('checked', `
 background: var(--button-color-active);
 color: var(--button-text-color-active);
 border-color: var(--button-border-color-active);
 `), cM('disabled', `
 cursor: not-allowed;
 opacity: var(--opacity-disabled);
 `)])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/src/RadioGroup.js







function mapSlot(defaultSlot, value, clsPrefix) {
    var _a;
    const children = [];
    let isButtonGroup = false;
    for (let i = 0; i < defaultSlot.length; ++i) {
        const wrappedInstance = defaultSlot[i];
        const name = (_a = wrappedInstance.type) === null || _a === void 0 ? void 0 : _a.name;
        if (name === 'RadioButton') {
            isButtonGroup = true;
        }
        if (false) {}
        const instanceProps = wrappedInstance.props;
        if (name !== 'RadioButton') {
            children.push(wrappedInstance);
            continue;
        }
        if (i === 0) {
            children.push(wrappedInstance);
        }
        else {
            const lastInstanceProps = children[children.length - 1]
                .props;
            const lastInstanceChecked = value === lastInstanceProps.value;
            const lastInstanceDisabled = lastInstanceProps.disabled;
            const currentInstanceChecked = value === instanceProps.value;
            const currentInstanceDisabled = instanceProps.disabled;
            /**
             * Priority of button splitor:
             * !disabled  checked >
             *  disabled  checked >
             * !disabled !checked >
             *  disabled !checked
             */
            const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
            const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
            const lastInstanceClass = {
                [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
                [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
            };
            const currentInstanceClass = {
                [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
                [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
            };
            const splitorClass = lastInstancePriority < currentInstancePriority
                ? currentInstanceClass
                : lastInstanceClass;
            children.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [`${clsPrefix}-radio-group__splitor`, splitorClass] }), wrappedInstance);
        }
    }
    return {
        children,
        isButtonGroup
    };
}
const radioGroupProps = Object.assign(Object.assign({}, use_theme.props), { name: String, value: [String, Number], defaultValue: {
        type: [String, Number],
        default: null
    }, size: String, disabled: {
        type: Boolean,
        default: undefined
    }, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array] });
/* harmony default export */ var RadioGroup = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'RadioGroup',
    props: radioGroupProps,
    setup(props) {
        const selfElRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
        const { mergedSizeRef, mergedDisabledRef, nTriggerFormChange, nTriggerFormInput, nTriggerFormBlur, nTriggerFormFocus } = useFormItem(props);
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = use_theme('Radio', 'RadioGroup', radio_group_cssr, radio_styles_light, props, mergedClsPrefixRef);
        const uncontrolledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultValue);
        const controlledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'value');
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        function doUpdateValue(value) {
            const { onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
            if (onUpdateValue) {
                call(onUpdateValue, value);
            }
            if (_onUpdateValue) {
                call(_onUpdateValue, value);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
        }
        function handleFocusin(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
                return;
            if (selfEl.contains(e.relatedTarget))
                return;
            nTriggerFormFocus();
        }
        function handleFocusout(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
                return;
            if (selfEl.contains(e.relatedTarget))
                return;
            nTriggerFormBlur();
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(radioGroupInjectionKey, {
            mergedClsPrefixRef,
            nameRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'name'),
            valueRef: mergedValueRef,
            disabledRef: mergedDisabledRef,
            mergedSizeRef,
            doUpdateValue
        });
        return {
            selfElRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            handleFocusout,
            handleFocusin,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { value: size } = mergedSizeRef;
                const { common: { cubicBezierEaseInOut }, self: { buttonBorderColor, buttonBorderColorActive, buttonBorderRadius, buttonBoxShadow, buttonBoxShadowFocus, buttonBoxShadowHover, buttonColorActive, buttonTextColor, buttonTextColorActive, buttonTextColorHover, opacityDisabled, [createKey('buttonHeight', size)]: height, [createKey('fontSize', size)]: fontSize } } = themeRef.value;
                return {
                    '--font-size': fontSize,
                    '--bezier': cubicBezierEaseInOut,
                    '--button-border-color': buttonBorderColor,
                    '--button-border-color-active': buttonBorderColorActive,
                    '--button-border-radius': buttonBorderRadius,
                    '--button-box-shadow': buttonBoxShadow,
                    '--button-box-shadow-focus': buttonBoxShadowFocus,
                    '--button-box-shadow-hover': buttonBoxShadowHover,
                    '--button-color-active': buttonColorActive,
                    '--button-text-color': buttonTextColor,
                    '--button-text-color-hover': buttonTextColorHover,
                    '--button-text-color-active': buttonTextColorActive,
                    '--height': height,
                    '--opacity-disabled': opacityDisabled
                };
            })
        };
    },
    render() {
        const { mergedValue, mergedClsPrefix, handleFocusin, handleFocusout } = this;
        const { children, isButtonGroup } = mapSlot(flatten(getSlot(this)), mergedValue, mergedClsPrefix);
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { onFocusin: handleFocusin, onFocusout: handleFocusout, ref: "selfElRef", class: [
                `${mergedClsPrefix}-radio-group`,
                isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`
            ], style: this.cssVars }, children));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/src/styles/radio.cssr.js
 // vars:
// --bezier
// --box-shadow
// --box-shadow-active
// --box-shadow-disabled
// --box-shadow-focus
// --box-shadow-hover
// --color
// --color-disabled
// --dot-color-active
// --dot-color-disabled
// --font-size
// --radio-size
// --text-color
// --text-color-disabled
// --label-padding

/* harmony default export */ var radio_cssr = (cB('radio', `
 line-height: 1;
 outline: none;
 position: relative;
 user-select: none;
 display: inline-flex;
 vertical-align: middle;
 align-items: center;
 font-size: var(--font-size);
`, [cE('dot', `
 height: var(--radio-size);
 width: var(--radio-size);
 `), cE('radio-input', `
 border: 0;
 width: 0;
 height: 0;
 opacity: 0;
 margin: 0;
 `), cE('dot', `
 background: var(--color);
 box-shadow: var(--box-shadow);
 transition:
 background-color .3s var(--bezier),
 box-shadow .3s var(--bezier);
 position: relative;
 border-radius: 50%;
 `, [cssr_c('&::before', `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--dot-color-active);
 transition: 
 opacity .3s var(--bezier),
 background-color .3s var(--bezier),
 transform .3s var(--bezier);
 `), cM('checked', {
  boxShadow: 'var(--box-shadow-active)'
}, [cssr_c('&::before', `
 opacity: 1;
 transform: scale(1);
 `)])]), cE('label', `
 color: var(--text-color);
 padding: var(--label-padding);
 display: inline-block;
 white-space: nowrap;
 transition: color .3s var(--bezier);
 `), cNotM('disabled', `
 cursor: pointer;
 `, [cssr_c('&:hover', [cE('dot', {
  boxShadow: 'var(--box-shadow-hover)'
})]), cM('focus', [cssr_c('&:not(:active)', [cE('dot', {
  boxShadow: 'var(--box-shadow-focus)'
})])])]), cM('disabled', `
 cursor: not-allowed;
 `, [cE('dot', {
  boxShadow: 'var(--box-shadow-disabled)',
  backgroundColor: 'var(--color-disabled)'
}, [cssr_c('&::before', {
  backgroundColor: 'var(--dot-color-disabled)'
}), cM('checked', `
 transform: scale(1);
 opacity: 1;
 `)]), cE('label', {
  color: 'var(--text-color-disabled)'
})])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/radio/src/Radio.js






/* harmony default export */ var Radio = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Radio',
    props: Object.assign(Object.assign({}, use_theme.props), use_radio.props),
    setup(props) {
        const radio = use_radio(props);
        const themeRef = use_theme('Radio', 'Radio', radio_cssr, radio_styles_light, props, radio.mergedClsPrefix);
        return Object.assign(radio, {
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { mergedSize: { value: size } } = radio;
                const { common: { cubicBezierEaseInOut }, self: { boxShadow, boxShadowActive, boxShadowDisabled, boxShadowFocus, boxShadowHover, color, colorDisabled, textColor, textColorDisabled, dotColorActive, dotColorDisabled, labelPadding, [createKey('fontSize', size)]: fontSize, [createKey('radioSize', size)]: radioSize } } = themeRef.value;
                return {
                    '--bezier': cubicBezierEaseInOut,
                    '--box-shadow': boxShadow,
                    '--box-shadow-active': boxShadowActive,
                    '--box-shadow-disabled': boxShadowDisabled,
                    '--box-shadow-focus': boxShadowFocus,
                    '--box-shadow-hover': boxShadowHover,
                    '--color': color,
                    '--color-disabled': colorDisabled,
                    '--dot-color-active': dotColorActive,
                    '--dot-color-disabled': dotColorDisabled,
                    '--font-size': fontSize,
                    '--radio-size': radioSize,
                    '--text-color': textColor,
                    '--text-color-disabled': textColorDisabled,
                    '--label-padding': labelPadding
                };
            })
        });
    },
    render() {
        const { $slots, mergedClsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                `${mergedClsPrefix}-radio`,
                {
                    [`${mergedClsPrefix}-radio--disabled`]: this.mergedDisabled,
                    [`${mergedClsPrefix}-radio--checked`]: this.renderSafeChecked,
                    [`${mergedClsPrefix}-radio--focus`]: this.focus
                }
            ], style: this.cssVars, onKeyup: this.handleKeyUp, onClick: this.handleClick, onMousedown: this.handleMouseDown },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio__radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: [
                    `${mergedClsPrefix}-radio__dot`,
                    this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`
                ] }),
            $slots.default ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, $slots.default())) : null));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Add.js

/* harmony default export */ var Add = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Add',
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/_internal/icons/Remove.js

/* harmony default export */ var Remove = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'Remove',
    render() {
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      " })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/styles/_common.js
/* harmony default export */ var dynamic_input_styles_common = ({
    actionMargin: '0 0 0 20px'
});

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/styles/light.js





const dynamic_input_styles_light_self = () => {
    return dynamic_input_styles_common;
};
const dynamicInputLight = createTheme({
    name: 'DynamicInput',
    common: light,
    peers: {
        Input: input_styles_light,
        Button: button_styles_light
    },
    self: dynamic_input_styles_light_self
});
/* harmony default export */ var dynamic_input_styles_light = (dynamicInputLight);

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/src/interface.js
const dynamicInputInjectionKey = Symbol('dynamic-input');

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/src/InputPreset.js



/* harmony default export */ var InputPreset = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'DynamicInputInputPreset',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        value: {
            type: String,
            default: ''
        },
        parentPath: String,
        path: String,
        onUpdateValue: {
            type: Function,
            required: true
        }
    },
    setup() {
        const { mergedThemeRef, placeholderRef
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
         } = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(dynamicInputInjectionKey);
        return {
            mergedTheme: mergedThemeRef,
            placeholder: placeholderRef
        };
    },
    render() {
        const { mergedTheme, placeholder, value, clsPrefix, onUpdateValue } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${clsPrefix}-dynamic-input-preset-input` },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Input, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value, placeholder: placeholder, onUpdateValue: onUpdateValue })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/src/PairPreset.js



/* harmony default export */ var PairPreset = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'DynamicInputPairPreset',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        value: {
            type: Object,
            default: () => ({
                key: '',
                value: ''
            })
        },
        parentPath: String,
        path: String,
        onUpdateValue: {
            type: Function,
            required: true
        }
    },
    setup(props) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { mergedThemeRef, keyPlaceholderRef, valuePlaceholderRef } = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(dynamicInputInjectionKey);
        return {
            mergedTheme: mergedThemeRef,
            keyPlaceholder: keyPlaceholderRef,
            valuePlaceholder: valuePlaceholderRef,
            handleKeyInput(key) {
                props.onUpdateValue({
                    key,
                    value: props.value.value
                });
            },
            handleValueInput(value) {
                props.onUpdateValue({
                    key: props.value.key,
                    value
                });
            }
        };
    },
    render() {
        const { mergedTheme, keyPlaceholder, valuePlaceholder, value, clsPrefix } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${clsPrefix}-dynamic-input-preset-pair` },
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Input, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.key, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: keyPlaceholder, onUpdateValue: this.handleKeyInput }),
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Input, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.value, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: valuePlaceholder, onUpdateValue: this.handleValueInput })));
    }
}));

// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/src/styles/index.cssr.js
 // vars:
// --action-margin

/* harmony default export */ var dynamic_input_src_styles_index_cssr = (cB('dynamic-input', {
  width: '100%'
}, [cB('dynamic-input-item', `
 margin-bottom: 10px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB('dynamic-input-preset-input', {
  flex: 1,
  alignItems: 'center'
}), cB('dynamic-input-preset-pair', `
 flex: 1;
 display: flex;
 align-items: center;
 `, [cB('dynamic-input-pair-input', [cssr_c('&:first-child', {
  'margin-right': '12px'
})])]), cE('action', `
 align-self: flex-start;
 display: flex;
 justify-content: flex-end;
 flex-shrink: 0;
 flex-grow: 0;
 margin: var(--action-margin);
 `, [cM('icon', {
  cursor: 'pointer'
})]), cssr_c('&:last-child', {
  marginBottom: 0
})]), cB('form-item', `
 padding-top: 0 !important;
 margin-right: 0 !important;
 `, [cB('form-item-blank', {
  paddingTop: '0 !important'
})])]));
// CONCATENATED MODULE: ./node_modules/naive-ui/es/dynamic-input/src/DynamicInput.js














const globalDataKeyMap = new WeakMap();
const dynamicInputProps = Object.assign(Object.assign({}, use_theme.props), { max: Number, min: {
        type: Number,
        default: 0
    }, value: Array, 
    // TODO: make it robust for different types
    defaultValue: {
        type: Array,
        default: () => []
    }, preset: {
        type: String,
        default: 'input'
    }, keyField: String, itemStyle: [String, Object], 
    // for preset pair
    keyPlaceholder: {
        type: String,
        default: ''
    }, valuePlaceholder: {
        type: String,
        default: ''
    }, 
    // for preset input
    placeholder: {
        type: String,
        default: ''
    }, onCreate: Function, onRemove: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 
    // deprecated
    onClear: {
        type: Function,
        validator: () => {
            warn('dynamic-input', '`on-clear` is deprecated, it is out of usage anymore.');
            return true;
        },
        default: undefined
    }, onInput: {
        type: [Function, Array],
        validator: () => {
            if (false) {}
            return true;
        },
        default: undefined
    } });
/* harmony default export */ var DynamicInput = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'DynamicInput',
    props: dynamicInputProps,
    setup(props, { slots }) {
        const { NConfigProvider, mergedClsPrefixRef } = useConfig();
        const NFormItem = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(formItemInjectionKey, null);
        const uncontrolledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.defaultValue);
        const controlledValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'value');
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const themeRef = use_theme('DynamicInput', 'DynamicInput', dynamic_input_src_styles_index_cssr, dynamic_input_styles_light, props, mergedClsPrefixRef);
        const insertionDisabledRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue)) {
                const { max } = props;
                return max !== undefined && mergedValue.length >= max;
            }
            return false;
        });
        const removeDisabledRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue))
                return mergedValue.length <= props.min;
            return true;
        });
        const buttonSizeRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
            var _a, _b;
            return (_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DynamicInput) === null || _b === void 0 ? void 0 : _b.buttonSize;
        });
        function doUpdateValue(value) {
            const { onInput, 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
            if (onInput)
                call(onInput, value);
            if (_onUpdateValue)
                call(_onUpdateValue, value);
            if (onUpdateValue)
                call(onUpdateValue, value);
            uncontrolledValueRef.value = value;
        }
        function ensureKey(value, index) {
            if (value === undefined || value === null)
                return index;
            if (typeof value !== 'object')
                return index;
            const rawValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isProxy"])(value) ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRaw"])(value) : value;
            let key = globalDataKeyMap.get(rawValue);
            if (key === undefined) {
                globalDataKeyMap.set(rawValue, (key = createId()));
            }
            return key;
        }
        function handleValueChange(index, value) {
            const { value: mergedValue } = mergedValueRef;
            const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
            const originalItem = newValue[index];
            newValue[index] = value;
            // update dataKeyMap
            if (originalItem &&
                value &&
                typeof originalItem === 'object' &&
                typeof value === 'object') {
                const rawOriginal = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isProxy"])(originalItem)
                    ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRaw"])(originalItem)
                    : originalItem;
                const rawNew = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isProxy"])(value) ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRaw"])(value) : value;
                // inherit key is value position is not change
                const originalKey = globalDataKeyMap.get(rawOriginal);
                if (originalKey !== undefined) {
                    globalDataKeyMap.set(rawNew, originalKey);
                }
            }
            doUpdateValue(newValue);
        }
        function handleCreateClick() {
            createItem(0);
        }
        function createItem(index) {
            const { value: mergedValue } = mergedValueRef;
            const { onCreate } = props;
            const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
            if (onCreate) {
                newValue.splice(index + 1, 0, onCreate(index + 1));
                doUpdateValue(newValue);
            }
            else if (slots.default) {
                newValue.splice(index + 1, 0, null);
                doUpdateValue(newValue);
            }
            else {
                switch (props.preset) {
                    case 'input':
                        newValue.splice(index + 1, 0, '');
                        doUpdateValue(newValue);
                        break;
                    case 'pair':
                        newValue.splice(index + 1, 0, { key: '', value: '' });
                        doUpdateValue(newValue);
                        break;
                }
            }
        }
        function remove(index) {
            const { value: mergedValue } = mergedValueRef;
            if (!Array.isArray(mergedValue))
                return;
            const { min } = props;
            if (mergedValue.length <= min)
                return;
            const newValue = Array.from(mergedValue);
            newValue.splice(index, 1);
            doUpdateValue(newValue);
            const { onRemove } = props;
            if (onRemove)
                onRemove(index);
        }
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(dynamicInputInjectionKey, {
            mergedThemeRef: themeRef,
            keyPlaceholderRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'keyPlaceholder'),
            valuePlaceholderRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'valuePlaceholder'),
            placeholderRef: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRef"])(props, 'placeholder')
        });
        return {
            locale: createLocaleMixin('DynamicInput').localeRef,
            buttonSize: buttonSizeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            NFormItem,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            insertionDisabled: insertionDisabledRef,
            removeDisabled: removeDisabledRef,
            handleCreateClick,
            ensureKey,
            handleValueChange,
            remove,
            createItem,
            mergedTheme: themeRef,
            cssVars: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                const { self: { actionMargin } } = themeRef.value;
                return {
                    '--action-margin': actionMargin
                };
            })
        };
    },
    render() {
        const { buttonSize, mergedClsPrefix, mergedValue, locale, mergedTheme, keyField, $slots, preset, itemStyle, NFormItem, ensureKey, handleValueChange, remove, createItem } = this;
        return (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-dynamic-input`, style: this.cssVars }, !Array.isArray(mergedValue) || mergedValue.length === 0 ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Button, { block: true, ghost: true, dashed: true, size: buttonSize, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleCreateClick }, {
            default: () => locale.create,
            icon: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: mergedClsPrefix }, { default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Add, null) }))
        })) : (mergedValue.map((_, index) => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { key: keyField ? _[keyField] : ensureKey(_, index), "data-key": keyField ? _[keyField] : ensureKey(_, index), class: `${mergedClsPrefix}-dynamic-input-item`, style: itemStyle },
            $slots.default ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])($slots, 'default', {
                value: mergedValue[index],
                index
            })) : preset === 'input' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(InputPreset, { clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem ? NFormItem.path.value : undefined, path: (NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.path.value)
                    ? `${NFormItem.path.value}[${index}]`
                    : undefined, onUpdateValue: (v) => handleValueChange(index, v) })) : preset === 'pair' ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(PairPreset, { clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem ? NFormItem.path.value : undefined, path: (NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.path.value)
                    ? `${NFormItem.path.value}[${index}]`
                    : undefined, onUpdateValue: (v) => handleValueChange(index, v) })) : null,
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", { class: `${mergedClsPrefix}-dynamic-input-item__action` },
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ButtonGroup, { size: buttonSize }, {
                    default: () => [
                        !this.removeDisabled ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Button, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, circle: true, onClick: () => remove(index) }, {
                            icon: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: mergedClsPrefix }, { default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Remove, null) }))
                        })) : null,
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(src_Button, { disabled: this.insertionDisabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => createItem(index) }, {
                            icon: () => (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Icon, { clsPrefix: mergedClsPrefix }, { default: () => Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Add, null) }))
                        })
                    ]
                }))))))));
    }
}));

// CONCATENATED MODULE: ./src/components/FilterModal.tsx






var FilterModal = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'FilterModal',
  emits: ['closeModal'],
  props: {
    filter: {
      type: Object,
      required: true
    },
    show: {
      type: Boolean,
      required: true
    }
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props),
        show = _toRefs.show,
        filter = _toRefs.filter;

    return function () {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Modal, {
        "show": show.value
      }, {
        default: function _default() {
          return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Card, {
            "title": "Metodo",
            "bordered": false
          }, {
            default: function _default() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Form, {
                "model": filter.value
              }, {
                default: function _default() {
                  return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FormItem, {
                    "label": "Nombre",
                    "path": "name"
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Input, {
                        'value': filter.value.name,
                        "onUpdate:value": function onUpdateValue($event) {
                          return filter.value.name = $event;
                        },
                        "placeholder": "Nombre Metodo"
                      }, null)];
                    }
                  }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FormItem, {
                    "label": "Personalizado",
                    "path": "xtreme"
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Switch, {
                        'value': filter.value.xtreme,
                        "onUpdate:value": function onUpdateValue($event) {
                          return filter.value.xtreme = $event;
                        }
                      }, null)];
                    }
                  }), filter.value.xtreme && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FormItem, {
                    "label": "Funcion",
                    "path": "xtremeData"
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Input, {
                        'value': filter.value.xtremeData,
                        "onUpdate:value": function onUpdateValue($event) {
                          return filter.value.xtremeData = $event;
                        },
                        "placeholder": "Funcion personalizada"
                      }, null)];
                    }
                  }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FormItem, {
                    "label": "Tipo de Parametro",
                    "path": "xtremeType"
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(RadioGroup, {
                        'value': filter.value.paramType,
                        "onUpdate:value": function onUpdateValue($event) {
                          return filter.value.paramType = $event;
                        },
                        "name": "radiogroup1"
                      }, {
                        default: function _default() {
                          return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Space, null, {
                            default: function _default() {
                              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Radio, {
                                "value": "pair"
                              }, {
                                default: function _default() {
                                  return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])("Objecto")];
                                }
                              }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Radio, {
                                "value": "input"
                              }, {
                                default: function _default() {
                                  return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])("Array")];
                                }
                              })];
                            }
                          })];
                        }
                      })];
                    }
                  }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FormItem, {
                    "label": "Parametros",
                    "path": "params"
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(DynamicInput, {
                        'value': filter.value.params,
                        "onUpdate:value": function onUpdateValue($event) {
                          return filter.value.params = $event;
                        },
                        "placeholder": "Please type here",
                        "preset": filter.value.paramType,
                        "key-placeholder": "Ingrese el nombre de la llave",
                        "value-placeholder": "Ingrese el valor de la llave"
                      }, null)];
                    }
                  })];
                }
              }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Space, {
                "justify": "end",
                "style": "gap: 10px;"
              }, {
                default: function _default() {
                  return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                    "text": true,
                    "size": "large",
                    "onClick": function onClick() {
                      return emit('closeModal', true, filter.value);
                    }
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(" Guardar ")];
                    }
                  }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                    "text": true,
                    "size": "large",
                    "onClick": function onClick() {
                      return emit('closeModal', false);
                    }
                  }, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(" Cancelar ")];
                    }
                  })];
                }
              })];
            }
          })];
        }
      });
    };
  }
});

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/EyeShow20Filled.js

const EyeShow20Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 20 20'
}
const EyeShow20Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M3.26 11.602C3.942 8.327 6.793 6 10 6c3.206 0 6.057 2.327 6.74 5.602a.5.5 0 0 0 .98-.204C16.943 7.673 13.693 5 10 5c-3.693 0-6.943 2.673-7.72 6.398a.5.5 0 0 0 .98.204z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M9.99 8a3.5 3.5 0 1 1 0 7a3.5 3.5 0 0 1 0-7z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var EyeShow20Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'EyeShow20Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', EyeShow20Filled_hoisted_1, [EyeShow20Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/EyeHide20Filled.js

const EyeHide20Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 20 20'
}
const EyeHide20Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M2.854 2.146a.5.5 0 1 0-.708.708l3.5 3.498a8.097 8.097 0 0 0-3.366 5.046a.5.5 0 1 0 .979.204a7.09 7.09 0 0 1 3.108-4.528L7.95 8.656a3.5 3.5 0 1 0 4.884 4.884l4.313 4.314a.5.5 0 0 0 .708-.708l-15-15z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M10.124 8.003l3.363 3.363a3.5 3.5 0 0 0-3.363-3.363z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M7.531 5.41l.803.803A6.632 6.632 0 0 1 10 6c3.206 0 6.057 2.327 6.74 5.602a.5.5 0 1 0 .98-.204C16.943 7.673 13.693 5 10 5c-.855 0-1.687.143-2.469.41z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var EyeHide20Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'EyeHide20Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', EyeHide20Filled_hoisted_1, [EyeHide20Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/ZoomOut20Filled.js

const ZoomOut20Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 20 20'
}
const ZoomOut20Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M14 8.5a5.5 5.5 0 1 0-2.177 4.383l4.147 4.147l.084.073a.75.75 0 0 0 .976-1.133l-4.147-4.147A5.476 5.476 0 0 0 14 8.5zm-3-.75a.75.75 0 0 1 0 1.5H6a.75.75 0 0 1 0-1.5h5z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var ZoomOut20Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ZoomOut20Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', ZoomOut20Filled_hoisted_1, [ZoomOut20Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/ZoomIn20Filled.js

const ZoomIn20Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 20 20'
}
const ZoomIn20Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M14 8.5c0 1.248-.416 2.4-1.117 3.323l4.147 4.147a.75.75 0 0 1-.976 1.133l-.084-.073l-4.147-4.147A5.5 5.5 0 1 1 14 8.5zM8.5 5.25a.75.75 0 0 0-.75.75v1.75H6a.75.75 0 0 0 0 1.5h1.75V11a.75.75 0 0 0 1.5 0V9.25H11a.75.75 0 0 0 0-1.5H9.25V6a.75.75 0 0 0-.75-.75z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var ZoomIn20Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ZoomIn20Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', ZoomIn20Filled_hoisted_1, [ZoomIn20Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/FullScreenMaximize24Filled.js

const FullScreenMaximize24Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 24 24'
}
const FullScreenMaximize24Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M5 6a1 1 0 0 1 1-1h2a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v2a1 1 0 0 0 2 0V6z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M5 18a1 1 0 0 0 1 1h2a1 1 0 1 1 0 2H6a3 3 0 0 1-3-3v-2a1 1 0 1 1 2 0v2z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M18 5a1 1 0 0 1 1 1v2a1 1 0 1 0 2 0V6a3 3 0 0 0-3-3h-2a1 1 0 1 0 0 2h2z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M19 18a1 1 0 0 1-1 1h-2a1 1 0 1 0 0 2h2a3 3 0 0 0 3-3v-2a1 1 0 1 0-2 0v2z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var FullScreenMaximize24Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'FullScreenMaximize24Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', FullScreenMaximize24Filled_hoisted_1, [FullScreenMaximize24Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./node_modules/@vicons/fluent/es/FullScreenMinimize24Filled.js

const FullScreenMinimize24Filled_hoisted_1 = {
  xmlns: 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  viewBox: '0 0 24 24'
}
const FullScreenMinimize24Filled_hoisted_2 = /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(
  'g',
  {
    fill: 'none'
  },
  [
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M9 4a1 1 0 0 0-2 0v2.5a.5.5 0 0 1-.5.5H4a1 1 0 0 0 0 2h2.5A2.5 2.5 0 0 0 9 6.5V4z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M9 20a1 1 0 1 1-2 0v-2.5a.5.5 0 0 0-.5-.5H4a1 1 0 1 1 0-2h2.5A2.5 2.5 0 0 1 9 17.5V20z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M16 3a1 1 0 0 0-1 1v2.5A2.5 2.5 0 0 0 17.5 9H20a1 1 0 1 0 0-2h-2.5a.5.5 0 0 1-.5-.5V4a1 1 0 0 0-1-1z',
      fill: 'currentColor'
    }),
    /*#__PURE__*/ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])('path', {
      d: 'M15 20a1 1 0 1 0 2 0v-2.5a.5.5 0 0 1 .5-.5H20a1 1 0 1 0 0-2h-2.5a2.5 2.5 0 0 0-2.5 2.5V20z',
      fill: 'currentColor'
    })
  ],
  -1
  /* HOISTED */
)
/* harmony default export */ var FullScreenMinimize24Filled = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'FullScreenMinimize24Filled',
  render: function render(_ctx, _cache) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])('svg', FullScreenMinimize24Filled_hoisted_1, [FullScreenMinimize24Filled_hoisted_2])
  }
}));

// CONCATENATED MODULE: ./src/components/Schema.tsx



















var Schema = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'SCHEMA',
  props: {
    selects: {
      type: Array,
      required: true
    },
    tables: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props) {
    var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props),
        tables = _toRefs.tables,
        selects = _toRefs.selects;

    var jsplumb = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])();
    var board = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])();
    var scrollable = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])();
    var fullscreen = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var modalFilter = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var modalResult = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var filter = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
    var table = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])('');
    var inx = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(-1);
    var zoom = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(1);
    var state = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({
      filter: filter,
      table: table,
      inx: inx
    });
    var position = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({
      x: 0,
      y: 0,
      top: 0,
      left: 0
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      ready(function () {
        var container = document.getElementById("board");
        var instance = newInstance({
          dragOptions: {
            cursor: 'pointer',
            trackScroll: true,
            zIndex: 2000,
            grid: {
              w: 10,
              h: 10
            },
            containment: ContainmentType.notNegative
          },
          maxConnections: -1,
          connector: {
            type: jsplumb_connector_flowchart_es_FlowchartConnector.type,
            options: {
              stub: [10, 50],
              gap: 10,
              cornerRadius: 5,
              alwaysRespectStubs: true,
              cssClass: 'jtk-conector-up-always'
            }
          },
          container: container
        });
        instance.batch(function () {
          instance.bind(EVENT_CONNECTION, function (connInfo) {
            var connection = connInfo.connection,
                sourceEndpoint = connInfo.sourceEndpoint,
                targetEndpoint = connInfo.targetEndpoint;
            var sourceEndData = sourceEndpoint.getData();
            var targetEndData = targetEndpoint.getData();
            var trueTargetData = sourceEndData.relations.find(function (r) {
              return r.related_model == targetEndData.classname;
            });
            var label = connection.getOverlay("label");
            label.setLabel((trueTargetData === null || trueTargetData === void 0 ? void 0 : trueTargetData.type) || 'UNDEFINED');
            label.component.addClass((trueTargetData === null || trueTargetData === void 0 ? void 0 : trueTargetData.type) || 'UNDEFINED');
            connection.addOverlay({
              type: 'Custom',
              options: {
                location: [5, 0],
                id: 'symbol',
                create: function create() {
                  var d = document.createElement('div');

                  d.onclick = function (e) {
                    var _jsplumb$value;

                    (_jsplumb$value = jsplumb.value) === null || _jsplumb$value === void 0 ? void 0 : _jsplumb$value.deleteConnection(connection);
                    e.preventDefault();
                    e.stopPropagation();
                  };

                  d.className = 'jtk-relationship-symbol ' + (trueTargetData === null || trueTargetData === void 0 ? void 0 : trueTargetData.type) || false;
                  d.style.cursor = 'pointer';
                  var label = '';

                  switch (trueTargetData === null || trueTargetData === void 0 ? void 0 : trueTargetData.type) {
                    case 'BelongsTo':
                      label = '-1:1>';
                      break;

                    default:
                      label = '-¿?>';
                      break;
                  }

                  d.innerHTML = '<span>' + label + '</span>';
                  return d;
                }
              }
            });
          });
        });
        jsplumb.value = instance;
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(JsPlumbKey, jsplumb);

    var openModal = function openModal(key, keyFilter) {
      state.table = key;
      var table = tables.value.get(key);
      if (!table) return;

      if (keyFilter !== undefined) {
        state.inx = keyFilter;
        state.filter = Object.assign({}, table.value.filter.methods[keyFilter]);
      } else {
        state.filter = {
          name: '',
          xtreme: false,
          xtremeData: '',
          paramType: 'input',
          params: []
        };
        state.inx = table.value.filter.methods.length;
      }

      modalFilter.value = true;
    };

    var closeModal = function closeModal(save, rfilter) {
      if (save) {
        var ctable = tables.value.get(state.table);
        ctable.value.filter.methods[state.inx] = rfilter;
      }

      modalFilter.value = false;
    };

    var handleFullScreen = function handleFullScreen(value) {
      if (value) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }

      fullscreen.value = value;
    };

    var moveHandler = function moveHandler(e) {
      if (scrollable.value) {
        var dx = e.clientX - position.value.x;
        var dy = e.clientY - position.value.y;

        if (zoom.value < 1) {
          var toDecimal = function toDecimal(num) {
            return Math.round((num + Number.EPSILON) * 100) / 100;
          };

          var zoomF = toDecimal(zoom.value);
          var stop = scrollable.value.scrollTop;
          var sheight = scrollable.value.scrollHeight;
          var cheight = scrollable.value.clientHeight;
          var zoomOF = 1 / zoomF;

          if (stop < (sheight - cheight * zoomOF) / zoomOF) {
            scrollable.value.scrollTop = position.value.top - dy;
          } else if (position.value.top - dy < scrollable.value.scrollTop) {
            scrollable.value.scrollTop = position.value.top - dy;
          }
        } else {
          scrollable.value.scrollTop = position.value.top - dy;
        }

        scrollable.value.scrollLeft = position.value.left - dx;
      }
    };

    var upHandler = function upHandler() {
      if (scrollable.value) {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', upHandler);
      }
    };

    var downHandler = function downHandler(e) {
      if (scrollable.value) {
        position.value = {
          left: scrollable.value.scrollLeft,
          top: scrollable.value.scrollTop,
          x: e.clientX,
          y: e.clientY
        };
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', upHandler);
      }
    };

    var handleZoom = function handleZoom(step) {
      var newValue = step + zoom.value;

      if (board.value && newValue >= 0.5 && newValue <= 1.6) {
        var _jsplumb$value2;

        board.value.style.transform = "scale(".concat(newValue, ")");
        (_jsplumb$value2 = jsplumb.value) === null || _jsplumb$value2 === void 0 ? void 0 : _jsplumb$value2.setZoom(newValue);
        zoom.value = newValue;
      }
    };

    return function () {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
        "ref": scrollable,
        "class": "scrollable",
        "onMousedown": downHandler
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("div", {
        "id": "board",
        "ref": board
      }, [jsplumb.value && function () {
        var data = [];

        var _iterator = _createForOfIteratorHelper(tables.value),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            data.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Table, {
              "key": key,
              "table": value,
              "selects": selects.value,
              "onOpenModal": openModal
            }, null));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return data;
      }()])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Space, {
        "style": "width: 100%; padding: 10px; position: fixed; bottom: 0px;",
        "justify": "space-between"
      }, {
        default: function _default() {
          return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
            "type": "info",
            "size": "small",
            "round": true,
            "onClick": function onClick() {
              return modalResult.value = !modalResult.value;
            }
          }, {
            icon: function icon() {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                default: function _default() {
                  return [modalResult ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(EyeShow20Filled, null, null) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(EyeHide20Filled, null, null)];
                }
              });
            }
          }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(ButtonGroup, {
            "size": "small"
          }, {
            default: function _default() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                "type": "info",
                "onClick": function onClick() {
                  return handleZoom(-.1);
                },
                "round": true
              }, {
                icon: function icon() {
                  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(ZoomOut20Filled, null, null)];
                    }
                  });
                }
              }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("span", {
                "style": {
                  borderLeft: '1px solid white',
                  borderRight: '1px solid white',
                  background: '#2080f0',
                  color: 'white',
                  display: 'flex',
                  alignItems: 'center',
                  padding: '0px 10px'
                }
              }, [zoom.value.toFixed(2)]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
                "type": "info",
                "onClick": function onClick() {
                  return handleZoom(+.1);
                },
                "round": true
              }, {
                icon: function icon() {
                  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                    default: function _default() {
                      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(ZoomIn20Filled, null, null)];
                    }
                  });
                }
              })];
            }
          }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Button, {
            "type": "info",
            "size": "small",
            "onClick": function onClick() {
              return handleFullScreen(!fullscreen.value);
            },
            "round": true
          }, {
            icon: function icon() {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(src_Icon, null, {
                default: function _default() {
                  return [!fullscreen.value ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FullScreenMaximize24Filled, null, null) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FullScreenMinimize24Filled, null, null)];
                }
              });
            }
          })];
        }
      }), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(FilterModal, {
        "show": modalFilter.value,
        "onCloseModal": closeModal,
        "filter": state.filter
      }, null), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Modal, {
        'show': modalResult.value,
        "onUpdate:show": function onUpdateShow($event) {
          return modalResult.value = $event;
        }
      }, {
        default: function _default() {
          return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(Card, {
            "title": "Metodo",
            "bordered": false
          }, {
            default: function _default() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])("pre", null, [JSON.stringify(tables.value, null, 2)])];
            }
          })];
        }
      })]);
    };
  }
});

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib-no-default.js




/***/ }),

/***/ "fb6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var isArray = __webpack_require__("e8b5");
var isConstructor = __webpack_require__("68ee");
var isObject = __webpack_require__("861d");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");
var toIndexedObject = __webpack_require__("fc6a");
var createProperty = __webpack_require__("8418");
var wellKnownSymbol = __webpack_require__("b622");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var un$Slice = __webpack_require__("f36a");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var Array = global.Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return un$Slice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "fc6a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("44ad");
var requireObjectCoercible = __webpack_require__("1d80");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "fce3":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});


/***/ }),

/***/ "fdbc":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "fdbf":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__("4930");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ })

/******/ });
});
//# sourceMappingURL=laravel-modeler-query.umd.js.map